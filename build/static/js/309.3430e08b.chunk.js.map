{"version":3,"file":"static/js/309.3430e08b.chunk.js","mappings":"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","sources":["../node_modules/react-feather/dist/icons/at-sign.js","../node_modules/react-feather/dist/icons/calendar.js","../node_modules/react-feather/dist/icons/map-pin.js","../node_modules/@babel/runtime/helpers/esm/typeof.js","../node_modules/@babel/runtime/helpers/esm/toPropertyKey.js","../node_modules/@babel/runtime/helpers/esm/toPrimitive.js","../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../node_modules/@babel/runtime/helpers/esm/checkPrivateRedeclaration.js","../node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js","../node_modules/@babel/runtime/helpers/esm/classExtractFieldDescriptor.js","../node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet.js","../node_modules/@babel/runtime/helpers/esm/classApplyDescriptorGet.js","../node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet.js","../node_modules/@babel/runtime/helpers/esm/classApplyDescriptorSet.js","../node_modules/ethers/src.ts/utils/properties.ts","../node_modules/ethers/src.ts/utils/errors.ts","../node_modules/ethers/src.ts/abi/typed.ts","../node_modules/@babel/runtime/helpers/esm/classPrivateMethodInitSpec.js","../node_modules/@babel/runtime/helpers/esm/classPrivateMethodGet.js","../node_modules/@noble/hashes/esm/_assert.js","../node_modules/@noble/hashes/esm/_u64.js","../node_modules/@noble/hashes/esm/cryptoBrowser.js","../node_modules/@noble/hashes/esm/utils.js","../node_modules/@noble/hashes/esm/sha3.js","../node_modules/ethers/src.ts/utils/data.ts","../node_modules/ethers/src.ts/crypto/keccak.ts","../node_modules/ethers/src.ts/utils/utf8.ts","../node_modules/ethers/src.ts/hash/id.ts","../node_modules/ethers/src.ts/utils/maths.ts","../node_modules/ethers/src.ts/abi/coders/abstract-coder.ts","../node_modules/ethers/src.ts/address/address.ts","../node_modules/ethers/src.ts/abi/coders/address.ts","../node_modules/ethers/src.ts/abi/coders/anonymous.ts","../node_modules/ethers/src.ts/abi/coders/array.ts","../node_modules/ethers/src.ts/abi/coders/boolean.ts","../node_modules/ethers/src.ts/abi/coders/bytes.ts","../node_modules/ethers/src.ts/abi/coders/fixed-bytes.ts","../node_modules/ethers/src.ts/abi/coders/null.ts","../node_modules/ethers/src.ts/abi/coders/number.ts","../node_modules/ethers/src.ts/abi/coders/string.ts","../node_modules/ethers/src.ts/abi/coders/tuple.ts","../node_modules/ethers/src.ts/abi/fragments.ts","../node_modules/ethers/src.ts/abi/abi-coder.ts","../node_modules/ethers/src.ts/abi/interface.ts","../node_modules/ethers/src.ts/address/checks.ts","../node_modules/ethers/src.ts/transaction/accesslist.ts","../node_modules/ethers/src.ts/providers/provider.ts","../node_modules/ethers/src.ts/utils/events.ts","../node_modules/ethers/src.ts/contract/wrappers.ts","../node_modules/ethers/src.ts/contract/contract.ts"],"sourcesContent":["function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport React, { forwardRef } from 'react';\nimport PropTypes from 'prop-types';\nvar AtSign = forwardRef(function (_ref, ref) {\n  var _ref$color = _ref.color,\n      color = _ref$color === void 0 ? 'currentColor' : _ref$color,\n      _ref$size = _ref.size,\n      size = _ref$size === void 0 ? 24 : _ref$size,\n      rest = _objectWithoutProperties(_ref, [\"color\", \"size\"]);\n\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({\n    ref: ref,\n    xmlns: \"http://www.w3.org/2000/svg\",\n    width: size,\n    height: size,\n    viewBox: \"0 0 24 24\",\n    fill: \"none\",\n    stroke: color,\n    strokeWidth: \"2\",\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\"\n  }, rest), /*#__PURE__*/React.createElement(\"circle\", {\n    cx: \"12\",\n    cy: \"12\",\n    r: \"4\"\n  }), /*#__PURE__*/React.createElement(\"path\", {\n    d: \"M16 8v5a3 3 0 0 0 6 0v-1a10 10 0 1 0-3.92 7.94\"\n  }));\n});\nAtSign.propTypes = {\n  color: PropTypes.string,\n  size: PropTypes.oneOfType([PropTypes.string, PropTypes.number])\n};\nAtSign.displayName = 'AtSign';\nexport default AtSign;","function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport React, { forwardRef } from 'react';\nimport PropTypes from 'prop-types';\nvar Calendar = forwardRef(function (_ref, ref) {\n  var _ref$color = _ref.color,\n      color = _ref$color === void 0 ? 'currentColor' : _ref$color,\n      _ref$size = _ref.size,\n      size = _ref$size === void 0 ? 24 : _ref$size,\n      rest = _objectWithoutProperties(_ref, [\"color\", \"size\"]);\n\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({\n    ref: ref,\n    xmlns: \"http://www.w3.org/2000/svg\",\n    width: size,\n    height: size,\n    viewBox: \"0 0 24 24\",\n    fill: \"none\",\n    stroke: color,\n    strokeWidth: \"2\",\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\"\n  }, rest), /*#__PURE__*/React.createElement(\"rect\", {\n    x: \"3\",\n    y: \"4\",\n    width: \"18\",\n    height: \"18\",\n    rx: \"2\",\n    ry: \"2\"\n  }), /*#__PURE__*/React.createElement(\"line\", {\n    x1: \"16\",\n    y1: \"2\",\n    x2: \"16\",\n    y2: \"6\"\n  }), /*#__PURE__*/React.createElement(\"line\", {\n    x1: \"8\",\n    y1: \"2\",\n    x2: \"8\",\n    y2: \"6\"\n  }), /*#__PURE__*/React.createElement(\"line\", {\n    x1: \"3\",\n    y1: \"10\",\n    x2: \"21\",\n    y2: \"10\"\n  }));\n});\nCalendar.propTypes = {\n  color: PropTypes.string,\n  size: PropTypes.oneOfType([PropTypes.string, PropTypes.number])\n};\nCalendar.displayName = 'Calendar';\nexport default Calendar;","function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport React, { forwardRef } from 'react';\nimport PropTypes from 'prop-types';\nvar MapPin = forwardRef(function (_ref, ref) {\n  var _ref$color = _ref.color,\n      color = _ref$color === void 0 ? 'currentColor' : _ref$color,\n      _ref$size = _ref.size,\n      size = _ref$size === void 0 ? 24 : _ref$size,\n      rest = _objectWithoutProperties(_ref, [\"color\", \"size\"]);\n\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({\n    ref: ref,\n    xmlns: \"http://www.w3.org/2000/svg\",\n    width: size,\n    height: size,\n    viewBox: \"0 0 24 24\",\n    fill: \"none\",\n    stroke: color,\n    strokeWidth: \"2\",\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\"\n  }, rest), /*#__PURE__*/React.createElement(\"path\", {\n    d: \"M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z\"\n  }), /*#__PURE__*/React.createElement(\"circle\", {\n    cx: \"12\",\n    cy: \"10\",\n    r: \"3\"\n  }));\n});\nMapPin.propTypes = {\n  color: PropTypes.string,\n  size: PropTypes.oneOfType([PropTypes.string, PropTypes.number])\n};\nMapPin.displayName = 'MapPin';\nexport default MapPin;","export default function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}","import _typeof from \"./typeof.js\";\nimport toPrimitive from \"./toPrimitive.js\";\nexport default function _toPropertyKey(arg) {\n  var key = toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}","import _typeof from \"./typeof.js\";\nexport default function _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}","import toPropertyKey from \"./toPropertyKey.js\";\nexport default function _defineProperty(obj, key, value) {\n  key = toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}","export default function _checkPrivateRedeclaration(obj, privateCollection) {\n  if (privateCollection.has(obj)) {\n    throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n  }\n}","import checkPrivateRedeclaration from \"./checkPrivateRedeclaration.js\";\nexport default function _classPrivateFieldInitSpec(obj, privateMap, value) {\n  checkPrivateRedeclaration(obj, privateMap);\n  privateMap.set(obj, value);\n}","export default function _classExtractFieldDescriptor(receiver, privateMap, action) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to \" + action + \" private field on non-instance\");\n  }\n  return privateMap.get(receiver);\n}","import classApplyDescriptorGet from \"./classApplyDescriptorGet.js\";\nimport classExtractFieldDescriptor from \"./classExtractFieldDescriptor.js\";\nexport default function _classPrivateFieldGet(receiver, privateMap) {\n  var descriptor = classExtractFieldDescriptor(receiver, privateMap, \"get\");\n  return classApplyDescriptorGet(receiver, descriptor);\n}","export default function _classApplyDescriptorGet(receiver, descriptor) {\n  if (descriptor.get) {\n    return descriptor.get.call(receiver);\n  }\n  return descriptor.value;\n}","import classApplyDescriptorSet from \"./classApplyDescriptorSet.js\";\nimport classExtractFieldDescriptor from \"./classExtractFieldDescriptor.js\";\nexport default function _classPrivateFieldSet(receiver, privateMap, value) {\n  var descriptor = classExtractFieldDescriptor(receiver, privateMap, \"set\");\n  classApplyDescriptorSet(receiver, descriptor, value);\n  return value;\n}","export default function _classApplyDescriptorSet(receiver, descriptor, value) {\n  if (descriptor.set) {\n    descriptor.set.call(receiver, value);\n  } else {\n    if (!descriptor.writable) {\n      throw new TypeError(\"attempted to set read only private field\");\n    }\n    descriptor.value = value;\n  }\n}","/**\n *  Property helper functions.\n *\n *  @_subsection api/utils:Properties  [about-properties]\n */\n\nfunction checkType(value: any, type: string, name: string): void {\n    const types = type.split(\"|\").map(t => t.trim());\n    for (let i = 0; i < types.length; i++) {\n        switch (type) {\n            case \"any\":\n                return;\n            case \"bigint\":\n            case \"boolean\":\n            case \"number\":\n            case \"string\":\n                if (typeof(value) === type) { return; }\n        }\n    }\n\n    const error: any = new Error(`invalid value for type ${ type }`);\n    error.code = \"INVALID_ARGUMENT\";\n    error.argument = `value.${ name }`;\n    error.value = value;\n\n    throw error;\n}\n\n/**\n *  Resolves to a new object that is a copy of %%value%%, but with all\n *  values resolved.\n */\nexport async function resolveProperties<T>(value: { [ P in keyof T ]: T[P] | Promise<T[P]>}): Promise<T> {\n    const keys = Object.keys(value);\n    const results = await Promise.all(keys.map((k) => Promise.resolve(value[<keyof T>k])));\n    return results.reduce((accum: any, v, index) => {\n        accum[keys[index]] = v;\n        return accum;\n    }, <{ [ P in keyof T]: T[P] }>{ });\n}\n\n/**\n *  Assigns the %%values%% to %%target%% as read-only values.\n *\n *  It %%types%% is specified, the values are checked.\n */\nexport function defineProperties<T>(\n target: T,\n values: { [ K in keyof T ]?: T[K] },\n types?: { [ K in keyof T ]?: string }): void {\n\n    for (let key in values) {\n        let value = values[key];\n\n        const type = (types ? types[key]: null);\n        if (type) { checkType(value, type, key); }\n\n        Object.defineProperty(target, key, { enumerable: true, value, writable: false });\n    }\n}\n","/**\n *  About Errors.\n *\n *  @_section: api/utils/errors:Errors  [about-errors]\n */\n\nimport { version } from \"../_version.js\";\n\nimport { defineProperties } from \"./properties.js\";\n\nimport type {\n    TransactionRequest, TransactionReceipt, TransactionResponse\n} from \"../providers/index.js\";\n\nimport type { FetchRequest, FetchResponse } from \"./fetch.js\";\n\nexport type ErrorInfo<T> = Omit<T, \"code\" | \"name\" | \"message\">;\n\n\nfunction stringify(value: any): any {\n    if (value == null) { return \"null\"; }\n\n    if (Array.isArray(value)) {\n        return \"[ \" + (value.map(stringify)).join(\", \") + \" ]\";\n    }\n\n    if (value instanceof Uint8Array) {\n        const HEX = \"0123456789abcdef\";\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n            result += HEX[value[i] >> 4];\n            result += HEX[value[i] & 0xf];\n        }\n        return result;\n    }\n\n    if (typeof(value) === \"object\" && typeof(value.toJSON) === \"function\") {\n        return stringify(value.toJSON());\n    }\n\n    switch (typeof(value)) {\n        case \"boolean\": case \"symbol\":\n            return value.toString();\n        case \"bigint\":\n            return BigInt(value).toString();\n        case \"number\":\n            return (value).toString();\n        case \"string\":\n            return JSON.stringify(value);\n        case \"object\": {\n            const keys = Object.keys(value);\n            keys.sort();\n            return \"{ \" + keys.map((k) => `${ stringify(k) }: ${ stringify(value[k]) }`).join(\", \") + \" }\";\n        }\n    }\n\n    return `[ COULD NOT SERIALIZE ]`;\n}\n\n/**\n *  All errors emitted by ethers have an **ErrorCode** to help\n *  identify and coalesce errors to simplfy programatic analysis.\n *\n *  Each **ErrorCode** is the %%code%% proerty of a coresponding\n *  [[EthersError]].\n *\n *  **Generic Errors**\n *\n *  **``\"UNKNOWN_ERROR\"``** - see [[UnknownError]]\n *\n *  **``\"NOT_IMPLEMENTED\"``** - see [[NotImplementedError]]\n *\n *  **``\"UNSUPPORTED_OPERATION\"``** - see [[UnsupportedOperationError]]\n *\n *  **``\"NETWORK_ERROR\"``** - see [[NetworkError]]\n *\n *  **``\"SERVER_ERROR\"``** - see [[ServerError]]\n *\n *  **``\"TIMEOUT\"``** - see [[TimeoutError]]\n *\n *  **``\"BAD_DATA\"``** - see [[BadDataError]]\n *\n *  **``\"CANCELLED\"``** - see [[CancelledError]]\n *\n *  **Operational Errors**\n *\n *  **``\"BUFFER_OVERRUN\"``** - see [[BufferOverrunError]]\n *\n *  **``\"NUMERIC_FAULT\"``** - see [[NumericFaultError]]\n *\n *  **Argument Errors**\n *\n *  **``\"INVALID_ARGUMENT\"``** - see [[InvalidArgumentError]]\n *\n *  **``\"MISSING_ARGUMENT\"``** - see [[MissingArgumentError]]\n *\n *  **``\"UNEXPECTED_ARGUMENT\"``** - see [[UnexpectedArgumentError]]\n *\n *  **``\"VALUE_MISMATCH\"``** - //unused//\n *\n *  **Blockchain Errors**\n *\n *  **``\"CALL_EXCEPTION\"``** - see [[CallExceptionError]]\n *\n *  **``\"INSUFFICIENT_FUNDS\"``** - see [[InsufficientFundsError]]\n *\n *  **``\"NONCE_EXPIRED\"``** - see [[NonceExpiredError]]\n *\n *  **``\"REPLACEMENT_UNDERPRICED\"``** - see [[ReplacementUnderpricedError]]\n *\n *  **``\"TRANSACTION_REPLACED\"``** - see [[TransactionReplacedError]]\n *\n *  **``\"UNCONFIGURED_NAME\"``** - see [[UnconfiguredNameError]]\n *\n *  **``\"OFFCHAIN_FAULT\"``** - see [[OffchainFaultError]]\n *\n *  **User Interaction Errors**\n *\n *  **``\"ACTION_REJECTED\"``** - see [[ActionRejectedError]]\n */\nexport type ErrorCode =\n\n    // Generic Errors\n    \"UNKNOWN_ERROR\" | \"NOT_IMPLEMENTED\" | \"UNSUPPORTED_OPERATION\" |\n    \"NETWORK_ERROR\" | \"SERVER_ERROR\" | \"TIMEOUT\" | \"BAD_DATA\" |\n    \"CANCELLED\" |\n\n    // Operational Errors\n    \"BUFFER_OVERRUN\" |  \"NUMERIC_FAULT\" |\n\n    // Argument Errors\n    \"INVALID_ARGUMENT\" | \"MISSING_ARGUMENT\" | \"UNEXPECTED_ARGUMENT\" |\n    \"VALUE_MISMATCH\" |\n\n    // Blockchain Errors\n    \"CALL_EXCEPTION\" | \"INSUFFICIENT_FUNDS\" | \"NONCE_EXPIRED\" |\n    \"REPLACEMENT_UNDERPRICED\" | \"TRANSACTION_REPLACED\" |\n    \"UNCONFIGURED_NAME\" | \"OFFCHAIN_FAULT\" |\n\n    // User Interaction\n    \"ACTION_REJECTED\"\n;\n\n/**\n *  All errors in Ethers include properties to assist in\n *  machine-readable errors.\n */\nexport interface EthersError<T extends ErrorCode = ErrorCode> extends Error {\n    /**\n     *  The string error code.\n     */\n    code: ErrorCode;\n\n    /**\n     *  Additional info regarding the error that may be useful.\n     *\n     *  This is generally helpful mostly for human-based debugging.\n     */\n    info?: Record<string, any>;\n\n    /**\n     *  Any related error.\n     */\n    error?: Error;\n}\n\n// Generic Errors\n\n/**\n *  This Error is a catch-all for when there is no way for Ethers to\n *  know what the underlying problem is.\n */\nexport interface UnknownError extends EthersError<\"UNKNOWN_ERROR\"> {\n    [ key: string ]: any;\n}\n\n/**\n *  This Error is mostly used as a stub for functionality that is\n *  intended for the future, but is currently not implemented.\n */\nexport interface NotImplementedError extends EthersError<\"NOT_IMPLEMENTED\"> {\n    /**\n     *  The attempted operation.\n     */\n    operation: string;\n}\n\n/**\n *  This Error indicates that the attempted operation is not supported.\n *\n *  This could range from a specifc JSON-RPC end-point not supporting\n *  a feature to a specific configuration of an object prohibiting the\n *  operation.\n *\n *  For example, a [[Wallet]] with no connected [[Provider]] is unable\n *  to send a transaction.\n */\nexport interface UnsupportedOperationError extends EthersError<\"UNSUPPORTED_OPERATION\"> {\n    /**\n     *  The attempted operation.\n     */\n    operation: string;\n}\n\nexport interface NetworkError extends EthersError<\"NETWORK_ERROR\"> {\n    event: string;\n}\n\n/**\n *  This Error indicates there was a problem fetching a resource from\n *  a server.\n */\nexport interface ServerError extends EthersError<\"SERVER_ERROR\"> {\n    /**\n     *  The requested resource.\n     */\n    request: FetchRequest | string;\n\n    /**\n     *  The response received from the server, if available.\n     */\n    response?: FetchResponse;\n}\n\n/**\n *  This Error indicates that the timeout duration has expired and\n *  that the operation has been implicitly cancelled.\n *\n *  The side-effect of the operation may still occur, as this\n *  generally means a request has been sent and there has simply\n *  been no response to indicate whether it was processed or not.\n */\nexport interface TimeoutError extends EthersError<\"TIMEOUT\"> {\n    /**\n     *  The attempted operation.\n     */\n    operation: string;\n\n    /**\n     *  The reason.\n     */\n    reason: string;\n\n    /**\n     *  The resource request, if available.\n     */\n    request?: FetchRequest;\n}\n\n/**\n *  This Error indicates that a provided set of data cannot\n *  be correctly interpretted.\n */\nexport interface BadDataError extends EthersError<\"BAD_DATA\"> {\n    /**\n     *  The data.\n     */\n    value: any;\n}\n\n/**\n *  This Error indicates that the operation was cancelled by a\n *  programmatic call, for example to ``cancel()``.\n */\nexport interface CancelledError extends EthersError<\"CANCELLED\"> {\n}\n\n\n// Operational Errors\n\n/**\n *  This Error indicates an attempt was made to read outside the bounds\n *  of protected data.\n *\n *  Most operations in Ethers are protected by bounds checks, to mitigate\n *  exploits when parsing data.\n */\nexport interface BufferOverrunError extends EthersError<\"BUFFER_OVERRUN\"> {\n    /**\n     *  The buffer that was overrun.\n     */\n    buffer: Uint8Array;\n\n    /**\n     *  The length of the buffer.\n     */\n    length: number;\n\n    /**\n     *  The offset that was requested.\n     */\n    offset: number;\n}\n\n/**\n *  This Error indicates an operation which would result in incorrect\n *  arithmetic output has occurred.\n *\n *  For example, trying to divide by zero or using a ``uint8`` to store\n *  a negative value.\n */\nexport interface NumericFaultError extends EthersError<\"NUMERIC_FAULT\"> {\n    /**\n     *  The attempted operation.\n     */\n    operation: string;\n\n    /**\n     *  The fault reported.\n     */\n    fault: string;\n\n    /**\n     *  The value the operation was attempted against.\n     */\n    value: any;\n}\n\n\n// Argument Errors\n\n/**\n *  This Error indicates an incorrect type or value was passed to\n *  a function or method.\n */\nexport interface InvalidArgumentError extends EthersError<\"INVALID_ARGUMENT\"> {\n    /**\n     *  The name of the argument.\n     */\n    argument: string;\n\n    /**\n     *  The value that was provided.\n     */\n    value: any;\n\n    info?: Record<string, any>\n}\n\n/**\n *  This Error indicates there were too few arguments were provided.\n */\nexport interface MissingArgumentError extends EthersError<\"MISSING_ARGUMENT\"> {\n    /**\n     *  The number of arguments received.\n     */\n    count: number;\n\n    /**\n     *  The number of arguments expected.\n     */\n    expectedCount: number;\n}\n\n/**\n *  This Error indicates too many arguments were provided.\n */\nexport interface UnexpectedArgumentError extends EthersError<\"UNEXPECTED_ARGUMENT\"> {\n    /**\n     *  The number of arguments received.\n     */\n    count: number;\n\n    /**\n     *  The number of arguments expected.\n     */\n    expectedCount: number;\n}\n\n\n// Blockchain Errors\n\n/**\n *  The action that resulted in the error.\n */\nexport type CallExceptionAction = \"call\" | \"estimateGas\" | \"getTransactionResult\" | \"unknown\";\n\n/**\n *  The related transaction that caused the error.\n */\nexport type CallExceptionTransaction = {\n    to: null | string;\n    from?: string;\n    data: string;\n};\n\n/**\n *  This **Error** indicates a transaction reverted.\n */\nexport interface CallExceptionError extends EthersError<\"CALL_EXCEPTION\"> {\n    /**\n     *  The action being performed when the revert was encountered.\n     */\n    action: CallExceptionAction;\n\n    /**\n     *  The revert data returned.\n     */\n    data: null | string;\n\n    /**\n     *  A human-readable representation of data, if possible.\n     */\n    reason: null | string;\n\n    /**\n     *  The transaction that triggered the exception.\n     */\n    transaction: CallExceptionTransaction,\n\n    /**\n     *  The contract invocation details, if available.\n     */\n    invocation: null | {\n        method: string;\n        signature: string;\n        args: Array<any>;\n    }\n\n    /**\n     *  The built-in or custom revert error, if available\n     */\n    revert: null | {\n        signature: string;\n        name: string;\n        args: Array<any>;\n    }\n}\n\n/**\n *  The sending account has insufficient funds to cover the\n *  entire transaction cost.\n */\nexport interface InsufficientFundsError extends EthersError<\"INSUFFICIENT_FUNDS\"> {\n    /**\n     *  The transaction.\n     */\n    transaction: TransactionRequest;\n}\n\n/**\n *  The sending account has already used this nonce in a\n *  transaction that has been included.\n */\nexport interface NonceExpiredError extends EthersError<\"NONCE_EXPIRED\"> {\n    /**\n     *  The transaction.\n     */\n    transaction: TransactionRequest;\n}\n\n/**\n *  A CCIP-read exception, which cannot be recovered from or\n *  be further processed.\n */\nexport interface OffchainFaultError extends EthersError<\"OFFCHAIN_FAULT\"> {\n    /**\n     *  The transaction.\n     */\n    transaction?: TransactionRequest;\n\n    /**\n     *  The reason the CCIP-read failed.\n     */\n    reason: string;\n}\n\n/**\n *  An attempt was made to replace a transaction, but with an\n *  insufficient additional fee to afford evicting the old\n *  transaction from the memory pool.\n */\nexport interface ReplacementUnderpricedError extends EthersError<\"REPLACEMENT_UNDERPRICED\"> {\n    /**\n     *  The transaction.\n     */\n    transaction: TransactionRequest;\n}\n\n/**\n *  A pending transaction was replaced by another.\n */\nexport interface TransactionReplacedError extends EthersError<\"TRANSACTION_REPLACED\"> {\n    /**\n     *  If the transaction was cancelled, such that the original\n     *  effects of the transaction cannot be assured.\n     */\n    cancelled: boolean;\n\n    /**\n     *  The reason the transaction was replaced.\n     */\n    reason: \"repriced\" | \"cancelled\" | \"replaced\";\n\n    /**\n     *  The hash of the replaced transaction.\n     */\n    hash: string;\n\n    /**\n     *  The transaction that replaced the transaction.\n     */\n    replacement: TransactionResponse;\n\n    /**\n     *  The receipt of the transaction that replace the transaction.\n     */\n    receipt: TransactionReceipt;\n}\n\n/**\n *  This Error indicates an ENS name was used, but the name has not\n *  been configured.\n *\n *  This could indicate an ENS name is unowned or that the current\n *  address being pointed to is the [[ZeroAddress]].\n */\nexport interface UnconfiguredNameError extends EthersError<\"UNCONFIGURED_NAME\"> {\n    /**\n     *  The ENS name that was requested\n     */\n    value: string;\n}\n\n/**\n *  This Error indicates a request was rejected by the user.\n *\n *  In most clients (such as MetaMask), when an operation requires user\n *  authorization (such as ``signer.sendTransaction``), the client\n *  presents a dialog box to the user. If the user denies the request\n *  this error is thrown.\n */\nexport interface ActionRejectedError extends EthersError<\"ACTION_REJECTED\"> {\n    /**\n     *  The requested action.\n     */\n    action: \"requestAccess\" | \"sendTransaction\" | \"signMessage\" | \"signTransaction\" | \"signTypedData\" | \"unknown\",\n\n    /**\n     *  The reason the action was rejected.\n     *\n     *  If there is already a pending request, some clients may indicate\n     *  there is already a ``\"pending\"`` action. This prevents an app\n     *  from spamming the user.\n     */\n    reason: \"expired\" | \"rejected\" | \"pending\"\n}\n\n// Coding; converts an ErrorCode its Typed Error\n\n/**\n *  A conditional type that transforms the [[ErrorCode]] T into\n *  its EthersError type.\n *\n *  @flatworm-skip-docs\n */\nexport type CodedEthersError<T> =\n    T extends \"UNKNOWN_ERROR\" ? UnknownError:\n    T extends \"NOT_IMPLEMENTED\" ? NotImplementedError:\n    T extends \"UNSUPPORTED_OPERATION\" ? UnsupportedOperationError:\n    T extends \"NETWORK_ERROR\" ? NetworkError:\n    T extends \"SERVER_ERROR\" ? ServerError:\n    T extends \"TIMEOUT\" ? TimeoutError:\n    T extends \"BAD_DATA\" ? BadDataError:\n    T extends \"CANCELLED\" ? CancelledError:\n\n    T extends \"BUFFER_OVERRUN\" ? BufferOverrunError:\n    T extends \"NUMERIC_FAULT\" ? NumericFaultError:\n\n    T extends \"INVALID_ARGUMENT\" ? InvalidArgumentError:\n    T extends \"MISSING_ARGUMENT\" ? MissingArgumentError:\n    T extends \"UNEXPECTED_ARGUMENT\" ? UnexpectedArgumentError:\n\n    T extends \"CALL_EXCEPTION\" ? CallExceptionError:\n    T extends \"INSUFFICIENT_FUNDS\" ? InsufficientFundsError:\n    T extends \"NONCE_EXPIRED\" ? NonceExpiredError:\n    T extends \"OFFCHAIN_FAULT\" ? OffchainFaultError:\n    T extends \"REPLACEMENT_UNDERPRICED\" ? ReplacementUnderpricedError:\n    T extends \"TRANSACTION_REPLACED\" ? TransactionReplacedError:\n    T extends \"UNCONFIGURED_NAME\" ? UnconfiguredNameError:\n\n    T extends \"ACTION_REJECTED\" ? ActionRejectedError:\n\n    never;\n\n\n\n/**\n *  Returns true if the %%error%% matches an error thrown by ethers\n *  that matches the error %%code%%.\n *\n *  In TypeScript envornoments, this can be used to check that %%error%%\n *  matches an EthersError type, which means the expected properties will\n *  be set.\n *\n *  @See [ErrorCodes](api:ErrorCode)\n *  @example\n *    try {\n *      // code....\n *    } catch (e) {\n *      if (isError(e, \"CALL_EXCEPTION\")) {\n *          // The Type Guard has validated this object\n *          console.log(e.data);\n *      }\n *    }\n */\nexport function isError<K extends ErrorCode, T extends CodedEthersError<K>>(error: any, code: K): error is T {\n    return (error && (<EthersError>error).code === code);\n}\n\n/**\n *  Returns true if %%error%% is a [[CallExceptionError].\n */\nexport function isCallException(error: any): error is CallExceptionError {\n    return isError(error, \"CALL_EXCEPTION\");\n}\n\n/**\n *  Returns a new Error configured to the format ethers emits errors, with\n *  the %%message%%, [[api:ErrorCode]] %%code%% and additioanl properties\n *  for the corresponding EthersError.\n *\n *  Each error in ethers includes the version of ethers, a\n *  machine-readable [[ErrorCode]], and depneding on %%code%%, additional\n *  required properties. The error message will also include the %%meeage%%,\n *  ethers version, %%code%% and all aditional properties, serialized.\n */\nexport function makeError<K extends ErrorCode, T extends CodedEthersError<K>>(message: string, code: K, info?: ErrorInfo<T>): T {\n    {\n        const details: Array<string> = [];\n        if (info) {\n            if (\"message\" in info || \"code\" in info || \"name\" in info) {\n                throw new Error(`value will overwrite populated values: ${ stringify(info) }`);\n            }\n            for (const key in info) {\n                const value = <any>(info[<keyof ErrorInfo<T>>key]);\n//                try {\n                    details.push(key + \"=\" + stringify(value));\n//                } catch (error: any) {\n//                console.log(\"MMM\", error.message);\n//                    details.push(key + \"=[could not serialize object]\");\n//                }\n            }\n        }\n        details.push(`code=${ code }`);\n        details.push(`version=${ version }`);\n\n        if (details.length) {\n            message += \" (\" + details.join(\", \") + \")\";\n        }\n    }\n\n    let error;\n    switch (code) {\n        case \"INVALID_ARGUMENT\":\n            error = new TypeError(message);\n            break;\n        case \"NUMERIC_FAULT\":\n        case \"BUFFER_OVERRUN\":\n            error = new RangeError(message);\n            break;\n        default:\n            error = new Error(message);\n    }\n\n    defineProperties<EthersError>(<EthersError>error, { code });\n\n    if (info) { Object.assign(error, info); }\n\n    return <T>error;\n}\n\n/**\n *  Throws an EthersError with %%message%%, %%code%% and additional error\n *  %%info%% when %%check%% is falsish..\n *\n *  @see [[api:makeError]]\n */\nexport function assert<K extends ErrorCode, T extends CodedEthersError<K>>(check: unknown, message: string, code: K, info?: ErrorInfo<T>): asserts check {\n    if (!check) { throw makeError(message, code, info); }\n}\n\n\n/**\n *  A simple helper to simply ensuring provided arguments match expected\n *  constraints, throwing if not.\n *\n *  In TypeScript environments, the %%check%% has been asserted true, so\n *  any further code does not need additional compile-time checks.\n */\nexport function assertArgument(check: unknown, message: string, name: string, value: unknown): asserts check {\n    assert(check, message, \"INVALID_ARGUMENT\", { argument: name, value: value });\n}\n\nexport function assertArgumentCount(count: number, expectedCount: number, message?: string): void {\n    if (message == null) { message = \"\"; }\n    if (message) { message = \": \" + message; }\n\n    assert(count >= expectedCount, \"missing arguemnt\" + message, \"MISSING_ARGUMENT\", {\n        count: count,\n        expectedCount: expectedCount\n    });\n\n    assert(count <= expectedCount, \"too many arguemnts\" + message, \"UNEXPECTED_ARGUMENT\", {\n        count: count,\n        expectedCount: expectedCount\n    });\n}\n\nconst _normalizeForms = [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].reduce((accum, form) => {\n    try {\n        // General test for normalize\n        /* c8 ignore start */\n        if (\"test\".normalize(form) !== \"test\") { throw new Error(\"bad\"); };\n        /* c8 ignore stop */\n\n        if (form === \"NFD\") {\n            const check = String.fromCharCode(0xe9).normalize(\"NFD\");\n            const expected = String.fromCharCode(0x65, 0x0301)\n            /* c8 ignore start */\n            if (check !== expected) { throw new Error(\"broken\") }\n            /* c8 ignore stop */\n        }\n\n        accum.push(form);\n    } catch(error) { }\n\n    return accum;\n}, <Array<string>>[]);\n\n/**\n *  Throws if the normalization %%form%% is not supported.\n */\nexport function assertNormalize(form: string): void {\n    assert(_normalizeForms.indexOf(form) >= 0, \"platform missing String.prototype.normalize\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"String.prototype.normalize\", info: { form }\n    });\n}\n\n/**\n *  Many classes use file-scoped values to guard the constructor,\n *  making it effectively private. This facilitates that pattern\n *  by ensuring the %%givenGaurd%% matches the file-scoped %%guard%%,\n *  throwing if not, indicating the %%className%% if provided.\n */\nexport function assertPrivate(givenGuard: any, guard: any, className?: string): void {\n    if (className == null) { className = \"\"; }\n    if (givenGuard !== guard) {\n        let method = className, operation = \"new\";\n        if (className) {\n            method += \".\";\n            operation += \" \" + className;\n        }\n        assert(false, `private constructor; use ${ method }from* methods`, \"UNSUPPORTED_OPERATION\", {\n            operation\n        });\n    }\n}\n","/**\n *  About typed...\n *\n *  @_subsection: api/abi:Typed Values\n */\n\nimport { assertPrivate, defineProperties } from \"../utils/index.js\";\n\nimport type { Addressable } from \"../address/index.js\";\nimport type { BigNumberish, BytesLike } from \"../utils/index.js\";\n\nimport type { Result } from \"./coders/abstract-coder.js\";\n\nconst _gaurd = { };\n\nfunction n(value: BigNumberish, width: number): Typed {\n    let signed = false;\n    if (width < 0) {\n        signed = true;\n        width *= -1;\n    }\n\n    // @TODO: Check range is valid for value\n    return new Typed(_gaurd, `${ signed ? \"\": \"u\" }int${ width }`, value, { signed, width });\n}\n\nfunction b(value: BytesLike, size?: number): Typed {\n    // @TODO: Check range is valid for value\n    return new Typed(_gaurd, `bytes${ (size) ? size: \"\" }`, value, { size });\n}\n\nexport interface TypedNumber extends Typed {\n    value: number;\n    defaultValue(): number;\n    minValue(): number;\n    maxValue(): number;\n}\n\nexport interface TypedBigInt extends Typed {\n    value: bigint;\n    defaultValue(): bigint;\n    minValue(): bigint;\n    maxValue(): bigint;\n}\n\nexport interface TypedData extends Typed {\n    value: string;\n    defaultValue(): string;\n}\n\nexport interface TypedString extends Typed {\n    value: string;\n    defaultValue(): string;\n}\n\nconst _typedSymbol = Symbol.for(\"_ethers_typed\");\n\nexport class Typed {\n    readonly type!: string;\n    readonly value!: any;\n\n    readonly #options: any;\n\n    readonly _typedSymbol!: Symbol;\n\n    constructor(gaurd: any, type: string, value: any, options?: any) {\n        if (options == null) { options = null; }\n        assertPrivate(_gaurd, gaurd, \"Typed\");\n        defineProperties<Typed>(this, { _typedSymbol, type, value });\n        this.#options = options;\n\n        // Check the value is valid\n        this.format();\n    }\n\n    format(): string {\n        if (this.type === \"array\") {\n            throw new Error(\"\");\n        } else if (this.type === \"dynamicArray\") {\n            throw new Error(\"\");\n        } else if (this.type === \"tuple\") {\n            return `tuple(${ this.value.map((v: Typed) => v.format()).join(\",\") })`\n        }\n\n        return this.type;\n    }\n\n    defaultValue(): string | number | bigint | Result {\n        return 0;\n    }\n\n    minValue(): string | number | bigint {\n        return 0;\n    }\n\n    maxValue(): string | number | bigint {\n        return 0;\n    }\n\n    isBigInt(): this is TypedBigInt {\n        return !!(this.type.match(/^u?int[0-9]+$/));\n    }\n\n    isData(): this is TypedData {\n        return this.type.startsWith(\"bytes\");\n    }\n\n    isString(): this is TypedString {\n        return (this.type === \"string\");\n    }\n\n    get tupleName(): null | string {\n        if (this.type !== \"tuple\") { throw TypeError(\"not a tuple\"); }\n        return this.#options;\n    }\n\n    // Returns the length of this type as an array\n    // - `null` indicates the length is unforced, it could be dynamic\n    // - `-1` indicates the length is dynamic\n    // - any other value indicates it is a static array and is its length\n    get arrayLength(): null | number {\n        if (this.type !== \"array\") { throw TypeError(\"not an array\"); }\n        if (this.#options === true) { return -1; }\n        if (this.#options === false) { return (<Array<any>>(this.value)).length; }\n        return null;\n    }\n\n    static from(type: string, value: any): Typed {\n        return new Typed(_gaurd, type, value);\n    }\n\n    static uint8(v: BigNumberish): Typed { return n(v, 8); }\n    static uint16(v: BigNumberish): Typed { return n(v, 16); }\n    static uint24(v: BigNumberish): Typed { return n(v, 24); }\n    static uint32(v: BigNumberish): Typed { return n(v, 32); }\n    static uint40(v: BigNumberish): Typed { return n(v, 40); }\n    static uint48(v: BigNumberish): Typed { return n(v, 48); }\n    static uint56(v: BigNumberish): Typed { return n(v, 56); }\n    static uint64(v: BigNumberish): Typed { return n(v, 64); }\n    static uint72(v: BigNumberish): Typed { return n(v, 72); }\n    static uint80(v: BigNumberish): Typed { return n(v, 80); }\n    static uint88(v: BigNumberish): Typed { return n(v, 88); }\n    static uint96(v: BigNumberish): Typed { return n(v, 96); }\n    static uint104(v: BigNumberish): Typed { return n(v, 104); }\n    static uint112(v: BigNumberish): Typed { return n(v, 112); }\n    static uint120(v: BigNumberish): Typed { return n(v, 120); }\n    static uint128(v: BigNumberish): Typed { return n(v, 128); }\n    static uint136(v: BigNumberish): Typed { return n(v, 136); }\n    static uint144(v: BigNumberish): Typed { return n(v, 144); }\n    static uint152(v: BigNumberish): Typed { return n(v, 152); }\n    static uint160(v: BigNumberish): Typed { return n(v, 160); }\n    static uint168(v: BigNumberish): Typed { return n(v, 168); }\n    static uint176(v: BigNumberish): Typed { return n(v, 176); }\n    static uint184(v: BigNumberish): Typed { return n(v, 184); }\n    static uint192(v: BigNumberish): Typed { return n(v, 192); }\n    static uint200(v: BigNumberish): Typed { return n(v, 200); }\n    static uint208(v: BigNumberish): Typed { return n(v, 208); }\n    static uint216(v: BigNumberish): Typed { return n(v, 216); }\n    static uint224(v: BigNumberish): Typed { return n(v, 224); }\n    static uint232(v: BigNumberish): Typed { return n(v, 232); }\n    static uint240(v: BigNumberish): Typed { return n(v, 240); }\n    static uint248(v: BigNumberish): Typed { return n(v, 248); }\n    static uint256(v: BigNumberish): Typed { return n(v, 256); }\n    static uint(v: BigNumberish): Typed { return n(v, 256); }\n\n    static int8(v: BigNumberish): Typed { return n(v, -8); }\n    static int16(v: BigNumberish): Typed { return n(v, -16); }\n    static int24(v: BigNumberish): Typed { return n(v, -24); }\n    static int32(v: BigNumberish): Typed { return n(v, -32); }\n    static int40(v: BigNumberish): Typed { return n(v, -40); }\n    static int48(v: BigNumberish): Typed { return n(v, -48); }\n    static int56(v: BigNumberish): Typed { return n(v, -56); }\n    static int64(v: BigNumberish): Typed { return n(v, -64); }\n    static int72(v: BigNumberish): Typed { return n(v, -72); }\n    static int80(v: BigNumberish): Typed { return n(v, -80); }\n    static int88(v: BigNumberish): Typed { return n(v, -88); }\n    static int96(v: BigNumberish): Typed { return n(v, -96); }\n    static int104(v: BigNumberish): Typed { return n(v, -104); }\n    static int112(v: BigNumberish): Typed { return n(v, -112); }\n    static int120(v: BigNumberish): Typed { return n(v, -120); }\n    static int128(v: BigNumberish): Typed { return n(v, -128); }\n    static int136(v: BigNumberish): Typed { return n(v, -136); }\n    static int144(v: BigNumberish): Typed { return n(v, -144); }\n    static int152(v: BigNumberish): Typed { return n(v, -152); }\n    static int160(v: BigNumberish): Typed { return n(v, -160); }\n    static int168(v: BigNumberish): Typed { return n(v, -168); }\n    static int176(v: BigNumberish): Typed { return n(v, -176); }\n    static int184(v: BigNumberish): Typed { return n(v, -184); }\n    static int192(v: BigNumberish): Typed { return n(v, -192); }\n    static int200(v: BigNumberish): Typed { return n(v, -200); }\n    static int208(v: BigNumberish): Typed { return n(v, -208); }\n    static int216(v: BigNumberish): Typed { return n(v, -216); }\n    static int224(v: BigNumberish): Typed { return n(v, -224); }\n    static int232(v: BigNumberish): Typed { return n(v, -232); }\n    static int240(v: BigNumberish): Typed { return n(v, -240); }\n    static int248(v: BigNumberish): Typed { return n(v, -248); }\n    static int256(v: BigNumberish): Typed { return n(v, -256); }\n    static int(v: BigNumberish): Typed { return n(v, -256); }\n\n    static bytes1(v: BytesLike): Typed { return b(v, 1); }\n    static bytes2(v: BytesLike): Typed { return b(v, 2); }\n    static bytes3(v: BytesLike): Typed { return b(v, 3); }\n    static bytes4(v: BytesLike): Typed { return b(v, 4); }\n    static bytes5(v: BytesLike): Typed { return b(v, 5); }\n    static bytes6(v: BytesLike): Typed { return b(v, 6); }\n    static bytes7(v: BytesLike): Typed { return b(v, 7); }\n    static bytes8(v: BytesLike): Typed { return b(v, 8); }\n    static bytes9(v: BytesLike): Typed { return b(v, 9); }\n    static bytes10(v: BytesLike): Typed { return b(v, 10); }\n    static bytes11(v: BytesLike): Typed { return b(v, 11); }\n    static bytes12(v: BytesLike): Typed { return b(v, 12); }\n    static bytes13(v: BytesLike): Typed { return b(v, 13); }\n    static bytes14(v: BytesLike): Typed { return b(v, 14); }\n    static bytes15(v: BytesLike): Typed { return b(v, 15); }\n    static bytes16(v: BytesLike): Typed { return b(v, 16); }\n    static bytes17(v: BytesLike): Typed { return b(v, 17); }\n    static bytes18(v: BytesLike): Typed { return b(v, 18); }\n    static bytes19(v: BytesLike): Typed { return b(v, 19); }\n    static bytes20(v: BytesLike): Typed { return b(v, 20); }\n    static bytes21(v: BytesLike): Typed { return b(v, 21); }\n    static bytes22(v: BytesLike): Typed { return b(v, 22); }\n    static bytes23(v: BytesLike): Typed { return b(v, 23); }\n    static bytes24(v: BytesLike): Typed { return b(v, 24); }\n    static bytes25(v: BytesLike): Typed { return b(v, 25); }\n    static bytes26(v: BytesLike): Typed { return b(v, 26); }\n    static bytes27(v: BytesLike): Typed { return b(v, 27); }\n    static bytes28(v: BytesLike): Typed { return b(v, 28); }\n    static bytes29(v: BytesLike): Typed { return b(v, 29); }\n    static bytes30(v: BytesLike): Typed { return b(v, 30); }\n    static bytes31(v: BytesLike): Typed { return b(v, 31); }\n    static bytes32(v: BytesLike): Typed { return b(v, 32); }\n\n    static address(v: string | Addressable): Typed { return new Typed(_gaurd, \"address\", v); }\n    static bool(v: any): Typed { return new Typed(_gaurd, \"bool\", !!v); }\n    static bytes(v: BytesLike): Typed { return new Typed(_gaurd, \"bytes\", v); }\n    static string(v: string): Typed { return new Typed(_gaurd, \"string\", v); }\n\n    static array(v: Array<any | Typed>, dynamic?: null | boolean): Typed {\n        throw new Error(\"not implemented yet\");\n        return new Typed(_gaurd, \"array\", v, dynamic);\n    }\n\n    static tuple(v: Array<any | Typed> | Record<string, any | Typed>, name?: string): Typed {\n        throw new Error(\"not implemented yet\");\n        return new Typed(_gaurd, \"tuple\", v, name);\n    }\n\n    static overrides(v: Record<string, any>): Typed {\n        return new Typed(_gaurd, \"overrides\", Object.assign({ }, v));\n    }\n\n    /**\n     *  Returns true only if %%value%% is a [[Typed]] instance.\n     */\n    static isTyped(value: any): value is Typed {\n        return (value && value._typedSymbol === _typedSymbol);\n    }\n\n    /**\n     *  If the value is a [[Typed]] instance, validates the underlying value\n     *  and returns it, otherwise returns value directly.\n     *\n     *  This is useful for functions that with to accept either a [[Typed]]\n     *  object or values.\n     */\n    static dereference<T>(value: Typed | T, type: string): T {\n        if (Typed.isTyped(value)) {\n            if (value.type !== type) {\n                throw new Error(`invalid type: expecetd ${ type }, got ${ value.type }`);\n            }\n            return value.value;\n        }\n        return value;\n    }\n}\n","import checkPrivateRedeclaration from \"./checkPrivateRedeclaration.js\";\nexport default function _classPrivateMethodInitSpec(obj, privateSet) {\n  checkPrivateRedeclaration(obj, privateSet);\n  privateSet.add(obj);\n}","export default function _classPrivateMethodGet(receiver, privateSet, fn) {\n  if (!privateSet.has(receiver)) {\n    throw new TypeError(\"attempted to get private field on non-instance\");\n  }\n  return fn;\n}","export function number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`Wrong positive integer: ${n}`);\n}\nexport function bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`Expected boolean, not ${b}`);\n}\nexport function bytes(b, ...lengths) {\n    if (!(b instanceof Uint8Array))\n        throw new TypeError('Expected Uint8Array');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nexport function hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nexport function exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nexport function output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nconst assert = {\n    number,\n    bool,\n    bytes,\n    hash,\n    exists,\n    output,\n};\nexport default assert;\n","const U32_MASK64 = BigInt(2 ** 32 - 1);\nconst _32n = BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nexport function fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nexport function split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nexport const toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (h, l) => l;\nconst rotr32L = (h, l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\n// Removing \"export\" has 5% perf penalty -_-\nexport function add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n","export const crypto = {\n    node: undefined,\n    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,\n};\n","/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// The import here is via the package name. This is to ensure\n// that exports mapping/resolution does fall into place.\nimport { crypto } from '@noble/hashes/crypto';\n// Cast array to different type\nexport const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nexport const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\n// There is almost no big endian hardware, but js typed arrays uses platform specific endianness.\n// So, just to be sure not to corrupt anything.\nif (!isLE)\n    throw new Error('Non little-endian hardware is not supported');\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xde, 0xad, 0xbe, 0xef]))\n */\nexport function bytesToHex(uint8a) {\n    // pre-caching improves the speed 6x\n    if (!(uint8a instanceof Uint8Array))\n        throw new Error('Uint8Array expected');\n    let hex = '';\n    for (let i = 0; i < uint8a.length; i++) {\n        hex += hexes[uint8a[i]];\n    }\n    return hex;\n}\n/**\n * @example hexToBytes('deadbeef')\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n    }\n    if (hex.length % 2)\n        throw new Error('hexToBytes: received invalid unpadded hex');\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow. However, call to async function will return Promise\n// which will be fullfiled only on next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string') {\n        throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);\n    }\n    return new TextEncoder().encode(str);\n}\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!(data instanceof Uint8Array))\n        throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);\n    return data;\n}\n/**\n * Concats Uint8Array-s into one; like `Buffer.concat([buf1, buf2])`\n * @example concatBytes(buf1, buf2)\n */\nexport function concatBytes(...arrays) {\n    if (!arrays.every((a) => a instanceof Uint8Array))\n        throw new Error('Uint8Array list expected');\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\n// For runtime check if class implements interface\nexport class Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\n// Check if object doens't have custom constructor (like Uint8Array/Array)\nconst isPlainObject = (obj) => Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;\nexport function checkOpts(defaults, opts) {\n    if (opts !== undefined && (typeof opts !== 'object' || !isPlainObject(opts)))\n        throw new TypeError('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nexport function wrapConstructor(hashConstructor) {\n    const hashC = (message) => hashConstructor().update(toBytes(message)).digest();\n    const tmp = hashConstructor();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashConstructor();\n    return hashC;\n}\nexport function wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG\n */\nexport function randomBytes(bytesLength = 32) {\n    if (crypto.web) {\n        return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n    }\n    else if (crypto.node) {\n        return new Uint8Array(crypto.node.randomBytes(bytesLength).buffer);\n    }\n    else {\n        throw new Error(\"The environment doesn't have randomBytes function\");\n    }\n}\n","import assert from './_assert.js';\nimport u64 from './_u64.js';\nimport { Hash, u32, toBytes, wrapConstructor, wrapConstructorWithOpts, } from './utils.js';\n// Various per round constants calculations\nconst [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _7n = BigInt(7);\nconst _256n = BigInt(256);\nconst _0x71n = BigInt(0x71);\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n    // Pi\n    [x, y] = [y, (2 * x + 3 * y) % 5];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n    // Iota\n    let t = _0n;\n    for (let j = 0; j < 7; j++) {\n        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n        if (R & _2n)\n            t ^= _1n << ((_1n << BigInt(j)) - _1n);\n    }\n    _SHA3_IOTA.push(t);\n}\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = u64.split(_SHA3_IOTA, true);\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s) => s > 32 ? u64.rotlBH(h, l, s) : u64.rotlSH(h, l, s);\nconst rotlL = (h, l, s) => s > 32 ? u64.rotlBL(h, l, s) : u64.rotlSL(h, l, s);\n// Same as keccakf1600, but allows to skip some rounds\nexport function keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for (let round = 24 - rounds; round < 24; round++) {\n        // Theta \n        for (let x = 0; x < 10; x++)\n            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for (let x = 0; x < 10; x += 2) {\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for (let y = 0; y < 50; y += 10) {\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho () and Pi ()\n        let curH = s[2];\n        let curL = s[3];\n        for (let t = 0; t < 24; t++) {\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi ()\n        for (let y = 0; y < 50; y += 10) {\n            for (let x = 0; x < 10; x++)\n                B[x] = s[y + x];\n            for (let x = 0; x < 10; x++)\n                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota ()\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    B.fill(0);\n}\nexport class Keccak extends Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {\n        super();\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        // Can be passed from user as dkLen\n        assert.number(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        if (0 >= this.blockLen || this.blockLen >= 200)\n            throw new Error('Sha3 supports only keccak-f1600 function');\n        this.state = new Uint8Array(200);\n        this.state32 = u32(this.state);\n    }\n    keccak() {\n        keccakP(this.state32, this.rounds);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        assert.exists(this);\n        const { blockLen, state } = this;\n        data = toBytes(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for (let i = 0; i < take; i++)\n                state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen)\n                this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished)\n            return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)\n            this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        assert.exists(this, false);\n        assert.bytes(out);\n        this.finish();\n        const bufferOut = this.state;\n        const { blockLen } = this;\n        for (let pos = 0, len = out.length; pos < len;) {\n            if (this.posOut >= blockLen)\n                this.keccak();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF)\n            throw new Error('XOF is not possible for this instance');\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        assert.number(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        assert.output(out, this);\n        if (this.finished)\n            throw new Error('digest() was already called');\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        this.state.fill(0);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n}\nconst gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));\nexport const sha3_224 = gen(0x06, 144, 224 / 8);\n/**\n * SHA3-256 hash function\n * @param message - that would be hashed\n */\nexport const sha3_256 = gen(0x06, 136, 256 / 8);\nexport const sha3_384 = gen(0x06, 104, 384 / 8);\nexport const sha3_512 = gen(0x06, 72, 512 / 8);\nexport const keccak_224 = gen(0x01, 144, 224 / 8);\n/**\n * keccak-256 hash function. Different from SHA3-256.\n * @param message - that would be hashed\n */\nexport const keccak_256 = gen(0x01, 136, 256 / 8);\nexport const keccak_384 = gen(0x01, 104, 384 / 8);\nexport const keccak_512 = gen(0x01, 72, 512 / 8);\nconst genShake = (suffix, blockLen, outputLen) => wrapConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));\nexport const shake128 = genShake(0x1f, 168, 128 / 8);\nexport const shake256 = genShake(0x1f, 136, 256 / 8);\n","/**\n *  Some data helpers.\n *\n *\n *  @_subsection api/utils:Data Helpers  [about-data]\n */\nimport { assert, assertArgument } from \"./errors.js\";\n\n/**\n *  A [[HexString]] whose length is even, which ensures it is a valid\n *  representation of binary data.\n */\nexport type DataHexString = string;\n\n/**\n *  A string which is prefixed with ``0x`` and followed by any number\n *  of case-agnostic hexadecimal characters.\n *\n *  It must match the regular expression ``/0x[0-9A-Fa-f]*\\/``.\n */\nexport type HexString = string;\n\n/**\n *  An object that can be used to represent binary data.\n */\nexport type BytesLike = DataHexString | Uint8Array;\n\nfunction _getBytes(value: BytesLike, name?: string, copy?: boolean): Uint8Array {\n    if (value instanceof Uint8Array) {\n        if (copy) { return new Uint8Array(value); }\n        return value;\n    }\n\n    if (typeof(value) === \"string\" && value.match(/^0x([0-9a-f][0-9a-f])*$/i)) {\n        const result = new Uint8Array((value.length - 2) / 2);\n        let offset = 2;\n        for (let i = 0; i < result.length; i++) {\n            result[i] = parseInt(value.substring(offset, offset + 2), 16);\n            offset += 2;\n        }\n        return result;\n    }\n\n    assertArgument(false, \"invalid BytesLike value\", name || \"value\", value);\n}\n\n/**\n *  Get a typed Uint8Array for %%value%%. If already a Uint8Array\n *  the original %%value%% is returned; if a copy is required use\n *  [[getBytesCopy]].\n *\n *  @see: getBytesCopy\n */\nexport function getBytes(value: BytesLike, name?: string): Uint8Array {\n    return _getBytes(value, name, false);\n}\n\n/**\n *  Get a typed Uint8Array for %%value%%, creating a copy if necessary\n *  to prevent any modifications of the returned value from being\n *  reflected elsewhere.\n *\n *  @see: getBytes\n */\nexport function getBytesCopy(value: BytesLike, name?: string): Uint8Array {\n    return _getBytes(value, name, true);\n}\n\n\n/**\n *  Returns true if %%value%% is a valid [[HexString]].\n *\n *  If %%length%% is ``true`` or a //number//, it also checks that\n *  %%value%% is a valid [[DataHexString]] of %%length%% (if a //number//)\n *  bytes of data (e.g. ``0x1234`` is 2 bytes).\n */\nexport function isHexString(value: any, length?: number | boolean): value is `0x${ string }` {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n\n    if (typeof(length) === \"number\" && value.length !== 2 + 2 * length) { return false; }\n    if (length === true && (value.length % 2) !== 0) { return false; }\n\n    return true;\n}\n\n/**\n *  Returns true if %%value%% is a valid representation of arbitrary\n *  data (i.e. a valid [[DataHexString]] or a Uint8Array).\n */\nexport function isBytesLike(value: any): value is BytesLike {\n    return (isHexString(value, true) || (value instanceof Uint8Array));\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\n/**\n *  Returns a [[DataHexString]] representation of %%data%%.\n */\nexport function hexlify(data: BytesLike): string {\n    const bytes = getBytes(data);\n\n    let result = \"0x\";\n    for (let i = 0; i < bytes.length; i++) {\n        const v = bytes[i];\n        result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n    }\n    return result;\n}\n\n/**\n *  Returns a [[DataHexString]] by concatenating all values\n *  within %%data%%.\n */\nexport function concat(datas: ReadonlyArray<BytesLike>): string {\n    return \"0x\" + datas.map((d) => hexlify(d).substring(2)).join(\"\");\n}\n\n/**\n *  Returns the length of %%data%%, in bytes.\n */\nexport function dataLength(data: BytesLike): number {\n    if (isHexString(data, true)) { return (data.length - 2) / 2; }\n    return getBytes(data).length;\n}\n\n/**\n *  Returns a [[DataHexString]] by slicing %%data%% from the %%start%%\n *  offset to the %%end%% offset.\n *\n *  By default %%start%% is 0 and %%end%% is the length of %%data%%.\n */\nexport function dataSlice(data: BytesLike, start?: number, end?: number): string {\n    const bytes = getBytes(data);\n    if (end != null && end > bytes.length) {\n        assert(false, \"cannot slice beyond data bounds\", \"BUFFER_OVERRUN\", {\n            buffer: bytes, length: bytes.length, offset: end\n        });\n    }\n    return hexlify(bytes.slice((start == null) ? 0: start, (end == null) ? bytes.length: end));\n}\n\n/**\n *  Return the [[DataHexString]] result by stripping all **leading**\n ** zero bytes from %%data%%.\n */\nexport function stripZerosLeft(data: BytesLike): string {\n    let bytes = hexlify(data).substring(2);\n    while (bytes.startsWith(\"00\")) { bytes = bytes.substring(2); }\n    return \"0x\" + bytes;\n}\n\nfunction zeroPad(data: BytesLike, length: number, left: boolean): string {\n    const bytes = getBytes(data);\n    assert(length >= bytes.length, \"padding exceeds data length\", \"BUFFER_OVERRUN\", {\n        buffer: new Uint8Array(bytes),\n        length: length,\n        offset: length + 1\n    });\n\n    const result = new Uint8Array(length);\n    result.fill(0);\n    if (left) {\n        result.set(bytes, length - bytes.length);\n    } else {\n        result.set(bytes, 0);\n    }\n\n    return hexlify(result);\n}\n\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **left**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **values** are in Solidity\n *  (e.g. ``uint128``).\n */\nexport function zeroPadValue(data: BytesLike, length: number): string {\n    return zeroPad(data, length, true);\n}\n\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **right**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **bytes** are in Solidity\n *  (e.g. ``bytes16``).\n */\nexport function zeroPadBytes(data: BytesLike, length: number): string {\n    return zeroPad(data, length, false);\n}\n","/**\n *  Cryptographic hashing functions\n *\n *  @_subsection: api/crypto:Hash Functions [about-crypto-hashing]\n */\n\nimport { keccak_256 } from \"@noble/hashes/sha3\";\n\nimport { getBytes, hexlify } from \"../utils/index.js\";\n\nimport type { BytesLike } from \"../utils/index.js\";\n\n\nlet locked = false;\n\nconst _keccak256 = function(data: Uint8Array): Uint8Array {\n    return keccak_256(data);\n}\n\nlet __keccak256: (data: Uint8Array) => BytesLike = _keccak256;\n\n/**\n *  Compute the cryptographic KECCAK256 hash of %%data%%.\n *\n *  The %%data%% **must** be a data representation, to compute the\n *  hash of UTF-8 data use the [[id]] function.\n *\n *  @returns DataHexstring\n *  @example:\n *    keccak256(\"0x\")\n *    //_result:\n *\n *    keccak256(\"0x1337\")\n *    //_result:\n *\n *    keccak256(new Uint8Array([ 0x13, 0x37 ]))\n *    //_result:\n *\n *    // Strings are assumed to be DataHexString, otherwise it will\n *    // throw. To hash UTF-8 data, see the note above.\n *    keccak256(\"Hello World\")\n *    //_error:\n */\nexport function keccak256(_data: BytesLike): string {\n    const data = getBytes(_data, \"data\");\n    return hexlify(__keccak256(data));\n}\nkeccak256._ = _keccak256;\nkeccak256.lock = function(): void { locked = true; }\nkeccak256.register = function(func: (data: Uint8Array) => BytesLike) {\n    if (locked) { throw new TypeError(\"keccak256 is locked\"); }\n    __keccak256 = func;\n}\nObject.freeze(keccak256);\n","/**\n *  Using strings in Ethereum (or any security-basd system) requires\n *  additional care. These utilities attempt to mitigate some of the\n *  safety issues as well as provide the ability to recover and analyse\n *  strings.\n *\n *  @_subsection api/utils:Strings and UTF-8  [about-strings]\n */\nimport { getBytes } from \"./data.js\";\nimport { assertArgument, assertNormalize } from \"./errors.js\";\n\nimport type { BytesLike } from \"./index.js\";\n\n\n///////////////////////////////\n\n/**\n *  The stanard normalization forms.\n */\nexport type UnicodeNormalizationForm = \"NFC\" | \"NFD\" | \"NFKC\" | \"NFKD\";\n\n/**\n *  When using the UTF-8 error API the following errors can be intercepted\n *  and processed as the %%reason%% passed to the [[Utf8ErrorFunc]].\n *\n *  **``\"UNEXPECTED_CONTINUE\"``** - a continuation byte was present where there\n *  was nothing to continue.\n *\n *  **``\"BAD_PREFIX\"``** - an invalid (non-continuation) byte to start a\n *  UTF-8 codepoint was found.\n *\n *  **``\"OVERRUN\"``** - the string is too short to process the expected\n *  codepoint length.\n *\n *  **``\"MISSING_CONTINUE\"``** - a missing continuation byte was expected but\n *  not found. The %%offset%% indicates the index the continuation byte\n *  was expected at.\n *\n *  **``\"OUT_OF_RANGE\"``** - the computed code point is outside the range\n *  for UTF-8. The %%badCodepoint%% indicates the computed codepoint, which was\n *  outside the valid UTF-8 range.\n *\n *  **``\"UTF16_SURROGATE\"``** - the UTF-8 strings contained a UTF-16 surrogate\n *  pair. The %%badCodepoint%% is the computed codepoint, which was inside the\n *  UTF-16 surrogate range.\n *\n *  **``\"OVERLONG\"``** - the string is an overlong representation. The\n *  %%badCodepoint%% indicates the computed codepoint, which has already\n *  been bounds checked.\n *\n *\n *  @returns string\n */\nexport type Utf8ErrorReason = \"UNEXPECTED_CONTINUE\" | \"BAD_PREFIX\" | \"OVERRUN\" |\n    \"MISSING_CONTINUE\" | \"OUT_OF_RANGE\" | \"UTF16_SURROGATE\" | \"OVERLONG\";\n\n\n/**\n *  A callback that can be used with [[toUtf8String]] to analysis or\n *  recovery from invalid UTF-8 data.\n *\n *  Parsing UTF-8 data is done through a simple Finite-State Machine (FSM)\n *  which calls the ``Utf8ErrorFunc`` if a fault is detected.\n *\n *  The %%reason%% indicates where in the FSM execution the fault\n *  occurred and the %%offset%% indicates where the input failed.\n *\n *  The %%bytes%% represents the raw UTF-8 data that was provided and\n *  %%output%% is the current array of UTF-8 code-points, which may\n *  be updated by the ``Utf8ErrorFunc``.\n *\n *  The value of the %%badCodepoint%% depends on the %%reason%%. See\n *  [[Utf8ErrorReason]] for details.\n *\n *  The function should return the number of bytes that should be skipped\n *  when control resumes to the FSM.\n */\nexport type Utf8ErrorFunc = (reason: Utf8ErrorReason, offset: number, bytes: Uint8Array, output: Array<number>, badCodepoint?: number) => number;\n\n\nfunction errorFunc(reason: Utf8ErrorReason, offset: number, bytes: Uint8Array, output: Array<number>, badCodepoint?: number): number {\n    assertArgument(false, `invalid codepoint at offset ${ offset }; ${ reason }`, \"bytes\", bytes);\n}\n\nfunction ignoreFunc(reason: Utf8ErrorReason, offset: number, bytes: Uint8Array, output: Array<number>, badCodepoint?: number): number {\n\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n    if (reason === \"BAD_PREFIX\" || reason === \"UNEXPECTED_CONTINUE\") {\n        let i = 0;\n        for (let o = offset + 1; o < bytes.length; o++) {\n            if (bytes[o] >> 6 !== 0x02) { break; }\n            i++;\n        }\n        return i;\n    }\n\n    // This byte runs us past the end of the string, so just jump to the end\n    // (but the first byte was read already read and therefore skipped)\n    if (reason === \"OVERRUN\") {\n        return bytes.length - offset - 1;\n    }\n\n    // Nothing to skip\n    return 0;\n}\n\nfunction replaceFunc(reason: Utf8ErrorReason, offset: number, bytes: Uint8Array, output: Array<number>, badCodepoint?: number): number {\n\n    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\n    if (reason === \"OVERLONG\") {\n        assertArgument(typeof(badCodepoint) === \"number\", \"invalid bad code point for replacement\", \"badCodepoint\", badCodepoint);\n        output.push(badCodepoint);\n        return 0;\n    }\n\n    // Put the replacement character into the output\n    output.push(0xfffd);\n\n    // Otherwise, process as if ignoring errors\n    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\n}\n\n/**\n *  A handful of popular, built-in UTF-8 error handling strategies.\n *\n *  **``\"error\"``** - throws on ANY illegal UTF-8 sequence or\n *  non-canonical (overlong) codepoints (this is the default)\n *\n *  **``\"ignore\"``** - silently drops any illegal UTF-8 sequence\n *  and accepts non-canonical (overlong) codepoints\n *\n *  **``\"replace\"``** - replace any illegal UTF-8 sequence with the\n *  UTF-8 replacement character (i.e. ``\"\\\\ufffd\"``) and accepts\n *  non-canonical (overlong) codepoints\n *\n *  @returns: Record<\"error\" | \"ignore\" | \"replace\", Utf8ErrorFunc>\n */\nexport const Utf8ErrorFuncs: Readonly<Record<\"error\" | \"ignore\" | \"replace\", Utf8ErrorFunc>> = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n});\n\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction getUtf8CodePoints(_bytes: BytesLike, onError?: Utf8ErrorFunc): Array<number> {\n    if (onError == null) { onError = Utf8ErrorFuncs.error; }\n\n    const bytes = getBytes(_bytes, \"bytes\");\n\n    const result: Array<number> = [];\n    let i = 0;\n\n    // Invalid bytes are ignored\n    while(i < bytes.length) {\n\n        const c = bytes[i++];\n\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result.push(c);\n            continue;\n        }\n\n        // Multibyte; how many bytes left for this character?\n        let extraLength = null;\n        let overlongMask = null;\n\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n\n        // 1110 xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n\n        // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n\n        } else {\n            if ((c & 0xc0) === 0x80) {\n                i += onError(\"UNEXPECTED_CONTINUE\", i - 1, bytes, result);\n            } else {\n                i += onError(\"BAD_PREFIX\", i - 1, bytes, result);\n            }\n            continue;\n        }\n\n        // Do we have enough bytes in our data?\n        if (i - 1 + extraLength >= bytes.length) {\n            i += onError(\"OVERRUN\", i - 1, bytes, result);\n            continue;\n        }\n\n        // Remove the length prefix from the char\n        let res: null | number = c & ((1 << (8 - extraLength - 1)) - 1);\n\n        for (let j = 0; j < extraLength; j++) {\n            let nextChar = bytes[i];\n\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) != 0x80) {\n                i += onError(\"MISSING_CONTINUE\", i, bytes, result);\n                res = null;\n                break;\n            };\n\n            res = (res << 6) | (nextChar & 0x3f);\n            i++;\n        }\n\n        // See above loop for invalid continuation byte\n        if (res === null) { continue; }\n\n        // Maximum code point\n        if (res > 0x10ffff) {\n            i += onError(\"OUT_OF_RANGE\", i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            i += onError(\"UTF16_SURROGATE\", i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Check for overlong sequences (more bytes than needed)\n        if (res <= overlongMask) {\n            i += onError(\"OVERLONG\", i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        result.push(res);\n    }\n\n    return result;\n}\n\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\n\n/**\n *  Returns the UTF-8 byte representation of %%str%%.\n *\n *  If %%form%% is specified, the string is normalized.\n */\nexport function toUtf8Bytes(str: string, form?: UnicodeNormalizationForm): Uint8Array {\n\n    if (form != null) {\n        assertNormalize(form);\n        str = str.normalize(form);\n    }\n\n    let result = [];\n    for (let i = 0; i < str.length; i++) {\n        const c = str.charCodeAt(i);\n\n        if (c < 0x80) {\n            result.push(c);\n\n        } else if (c < 0x800) {\n            result.push((c >> 6) | 0xc0);\n            result.push((c & 0x3f) | 0x80);\n\n        } else if ((c & 0xfc00) == 0xd800) {\n            i++;\n            const c2 = str.charCodeAt(i);\n\n            assertArgument(i < str.length && ((c2 & 0xfc00) === 0xdc00),\n                \"invalid surrogate pair\", \"str\", str);\n\n            // Surrogate Pair\n            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push((pair >> 18) | 0xf0);\n            result.push(((pair >> 12) & 0x3f) | 0x80);\n            result.push(((pair >> 6) & 0x3f) | 0x80);\n            result.push((pair & 0x3f) | 0x80);\n\n        } else {\n            result.push((c >> 12) | 0xe0);\n            result.push(((c >> 6) & 0x3f) | 0x80);\n            result.push((c & 0x3f) | 0x80);\n        }\n    }\n\n    return new Uint8Array(result);\n};\n\n//export \nfunction _toUtf8String(codePoints: Array<number>): string {\n    return codePoints.map((codePoint) => {\n        if (codePoint <= 0xffff) {\n            return String.fromCharCode(codePoint);\n        }\n        codePoint -= 0x10000;\n        return String.fromCharCode(\n            (((codePoint >> 10) & 0x3ff) + 0xd800),\n            ((codePoint & 0x3ff) + 0xdc00)\n        );\n    }).join(\"\");\n}\n\n/**\n *  Returns the string represented by the UTF-8 data %%bytes%%.\n *\n *  When %%onError%% function is specified, it is called on UTF-8\n *  errors allowing recovery using the [[Utf8ErrorFunc]] API.\n *  (default: [error](Utf8ErrorFuncs))\n */\nexport function toUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}\n\n/**\n *  Returns the UTF-8 code-points for %%str%%.\n *\n *  If %%form%% is specified, the string is normalized.\n */\nexport function toUtf8CodePoints(str: string, form?: UnicodeNormalizationForm): Array<number> {\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\n}\n\n","import { keccak256 } from \"../crypto/index.js\";\nimport { toUtf8Bytes } from \"../utils/index.js\";\n\n/**\n *  A simple hashing function which operates on UTF-8 strings to\n *  compute an 32-byte irentifier.\n *\n *  This simply computes the [UTF-8 bytes](toUtf8Bytes) and computes\n *  the [[keccak256]].\n *\n *  @example:\n *    id(\"hello world\")\n *    //_result:\n */\nexport function id(value: string): string {\n    return keccak256(toUtf8Bytes(value));\n}\n","/**\n *  Some mathematic operations.\n *\n *  @_subsection: api/utils:Math Helpers  [about-maths]\n */\nimport { hexlify, isBytesLike } from \"./data.js\";\nimport { assert, assertArgument } from \"./errors.js\";\n\nimport type { BytesLike } from \"./data.js\";\n\n/**\n *  Any type that can be used where a numeric value is needed.\n */\nexport type Numeric = number | bigint;\n\n/**\n *  Any type that can be used where a big number is needed.\n */\nexport type BigNumberish = string | Numeric;\n\n\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\n\n//const BN_Max256 = (BN_1 << BigInt(256)) - BN_1;\n\n\n// IEEE 754 support 53-bits of mantissa\nconst maxValue = 0x1fffffffffffff;\n\n/**\n *  Convert %%value%% from a twos-compliment representation of %%width%%\n *  bits to its value.\n *\n *  If the highest bit is ``1``, the result will be negative.\n */\nexport function fromTwos(_value: BigNumberish, _width: Numeric): bigint {\n    const value = getUint(_value, \"value\");\n    const width = BigInt(getNumber(_width, \"width\"));\n\n    assert((value >> width) === BN_0, \"overflow\", \"NUMERIC_FAULT\", {\n        operation: \"fromTwos\", fault: \"overflow\", value: _value\n    });\n\n    // Top bit set; treat as a negative value\n    if (value >> (width - BN_1)) {\n        const mask = (BN_1 << width) - BN_1;\n        return -(((~value) & mask) + BN_1);\n    }\n\n    return value;\n}\n\n/**\n *  Convert %%value%% to a twos-compliment representation of\n *  %%width%% bits.\n *\n *  The result will always be positive.\n */\nexport function toTwos(_value: BigNumberish, _width: Numeric): bigint {\n    let value = getBigInt(_value, \"value\");\n    const width = BigInt(getNumber(_width, \"width\"));\n\n    const limit = (BN_1 << (width - BN_1));\n\n    if (value < BN_0) {\n        value = -value;\n        assert(value <= limit, \"too low\", \"NUMERIC_FAULT\", {\n            operation: \"toTwos\", fault: \"overflow\", value: _value\n        });\n        const mask = (BN_1 << width) - BN_1;\n        return ((~value) & mask) + BN_1;\n    } else {\n        assert(value < limit, \"too high\", \"NUMERIC_FAULT\", {\n            operation: \"toTwos\", fault: \"overflow\", value: _value\n        });\n    }\n\n    return value;\n}\n\n/**\n *  Mask %%value%% with a bitmask of %%bits%% ones.\n */\nexport function mask(_value: BigNumberish, _bits: Numeric): bigint {\n    const value = getUint(_value, \"value\");\n    const bits = BigInt(getNumber(_bits, \"bits\"));\n    return value & ((BN_1 << bits) - BN_1);\n}\n\n/**\n *  Gets a BigInt from %%value%%. If it is an invalid value for\n *  a BigInt, then an ArgumentError will be thrown for %%name%%.\n */\nexport function getBigInt(value: BigNumberish, name?: string): bigint {\n    switch (typeof(value)) {\n        case \"bigint\": return value;\n        case \"number\":\n            assertArgument(Number.isInteger(value), \"underflow\", name || \"value\", value);\n            assertArgument(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return BigInt(value);\n        case \"string\":\n            try {\n                if (value === \"\") { throw new Error(\"empty string\"); }\n                if (value[0] === \"-\" && value[1] !== \"-\") {\n                    return -BigInt(value.substring(1));\n                }\n                return BigInt(value);\n            } catch(e: any) {\n                assertArgument(false, `invalid BigNumberish string: ${ e.message }`, name || \"value\", value);\n            }\n    }\n    assertArgument(false, \"invalid BigNumberish value\", name || \"value\", value);\n}\n\nexport function getUint(value: BigNumberish, name?: string): bigint {\n    const result = getBigInt(value, name);\n    assert(result >= BN_0, \"unsigned value cannot be negative\", \"NUMERIC_FAULT\", {\n        fault: \"overflow\", operation: \"getUint\", value\n    });\n    return result;\n}\n\nconst Nibbles = \"0123456789abcdef\";\n\n/*\n * Converts %%value%% to a BigInt. If %%value%% is a Uint8Array, it\n * is treated as Big Endian data.\n */\nexport function toBigInt(value: BigNumberish | Uint8Array): bigint {\n    if (value instanceof Uint8Array) {\n        let result = \"0x0\";\n        for (const v of value) {\n            result += Nibbles[v >> 4];\n            result += Nibbles[v & 0x0f];\n        }\n        return BigInt(result);\n    }\n\n    return getBigInt(value);\n}\n\n/**\n *  Gets a //number// from %%value%%. If it is an invalid value for\n *  a //number//, then an ArgumentError will be thrown for %%name%%.\n */\nexport function getNumber(value: BigNumberish, name?: string): number {\n    switch (typeof(value)) {\n        case \"bigint\":\n            assertArgument(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return Number(value);\n        case \"number\":\n            assertArgument(Number.isInteger(value), \"underflow\", name || \"value\", value);\n            assertArgument(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return value;\n        case \"string\":\n            try {\n                if (value === \"\") { throw new Error(\"empty string\"); }\n                return getNumber(BigInt(value), name);\n            } catch(e: any) {\n                assertArgument(false, `invalid numeric string: ${ e.message }`, name || \"value\", value);\n            }\n    }\n    assertArgument(false, \"invalid numeric value\", name || \"value\", value);\n}\n\n\n/**\n *  Converts %%value%% to a number. If %%value%% is a Uint8Array, it\n *  is treated as Big Endian data. Throws if the value is not safe.\n */\nexport function toNumber(value: BigNumberish | Uint8Array): number {\n    return getNumber(toBigInt(value));\n}\n\n/**\n *  Converts %%value%% to a Big Endian hexstring, optionally padded to\n *  %%width%% bytes.\n */\nexport function toBeHex(_value: BigNumberish, _width?: Numeric): string {\n    const value = getUint(_value, \"value\");\n\n    let result = value.toString(16);\n\n    if (_width == null) {\n        // Ensure the value is of even length\n        if (result.length % 2) { result = \"0\" + result; }\n    } else {\n        const width = getNumber(_width, \"width\");\n        assert(width * 2 >= result.length, `value exceeds width (${ width } bits)`, \"NUMERIC_FAULT\", {\n            operation: \"toBeHex\",\n            fault: \"overflow\",\n            value: _value\n        });\n\n        // Pad the value to the required width\n        while (result.length < (width * 2)) { result = \"0\" + result; }\n\n    }\n\n    return \"0x\" + result;\n}\n\n/**\n *  Converts %%value%% to a Big Endian Uint8Array.\n */\nexport function toBeArray(_value: BigNumberish): Uint8Array {\n    const value = getUint(_value, \"value\");\n\n    if (value === BN_0) { return new Uint8Array([ ]); }\n\n    let hex = value.toString(16);\n    if (hex.length % 2) { hex = \"0\" + hex; }\n\n    const result = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < result.length; i++) {\n        const offset = i * 2;\n        result[i] = parseInt(hex.substring(offset, offset + 2), 16);\n    }\n\n    return result;\n}\n\n/**\n *  Returns a [[HexString]] for %%value%% safe to use as a //Quantity//.\n *\n *  A //Quantity// does not have and leading 0 values unless the value is\n *  the literal value `0x0`. This is most commonly used for JSSON-RPC\n *  numeric values.\n */\nexport function toQuantity(value: BytesLike | BigNumberish): string {\n    let result = hexlify(isBytesLike(value) ? value: toBeArray(value)).substring(2);\n    while (result.startsWith(\"0\")) { result = result.substring(1); }\n    if (result === \"\") { result = \"0\"; }\n    return \"0x\" + result;\n}\n","\nimport {\n    defineProperties, concat, getBytesCopy, getNumber, hexlify,\n    toBeArray, toBigInt, toNumber,\n    assert, assertArgument\n} from \"../../utils/index.js\";\n\nimport type { BigNumberish, BytesLike } from \"../../utils/index.js\";\n\n/**\n * @_ignore:\n */\nexport const WordSize: number = 32;\nconst Padding = new Uint8Array(WordSize);\n\n// Properties used to immediate pass through to the underlying object\n// - `then` is used to detect if an object is a Promise for await\nconst passProperties = [ \"then\" ];\n\nconst _guard = { };\n\nfunction throwError(name: string, error: Error): never {\n    const wrapped = new Error(`deferred error during ABI decoding triggered accessing ${ name }`);\n    (<any>wrapped).error = error;\n    throw wrapped;\n}\n\n/**\n *  A [[Result]] is a sub-class of Array, which allows accessing any\n *  of its values either positionally by its index or, if keys are\n *  provided by its name.\n *\n *  @_docloc: api/abi\n */\nexport class Result extends Array<any> {\n    readonly #names: ReadonlyArray<null | string>;\n\n    [ K: string | number ]: any\n\n    /**\n     *  @private\n     */\n    constructor(...args: Array<any>) {\n        // To properly sub-class Array so the other built-in\n        // functions work, the constructor has to behave fairly\n        // well. So, in the event we are created via fromItems()\n        // we build the read-only Result object we want, but on\n        // any other input, we use the default constructor\n\n        // constructor(guard: any, items: Array<any>, keys?: Array<null | string>);\n        const guard = args[0];\n        let items: Array<any> = args[1];\n        let names: Array<null | string> = (args[2] || [ ]).slice();\n\n        let wrap = true;\n        if (guard !== _guard) {\n            items = args;\n            names = [ ];\n            wrap = false;\n        }\n\n        // Can't just pass in ...items since an array of length 1\n        // is a special case in the super.\n        super(items.length);\n        items.forEach((item, index) => { this[index] = item; });\n\n        // Find all unique keys\n        const nameCounts = names.reduce((accum, name) => {\n            if (typeof(name) === \"string\") {\n                accum.set(name, (accum.get(name) || 0) + 1);\n            }\n            return accum;\n        }, <Map<string, number>>(new Map()));\n\n        // Remove any key thats not unique\n        this.#names = Object.freeze(items.map((item, index) => {\n            const name = names[index];\n            if (name != null && nameCounts.get(name) === 1) {\n                return name;\n            }\n            return null;\n        }));\n\n        if (!wrap) { return; }\n\n        // A wrapped Result is immutable\n        Object.freeze(this);\n\n        // Proxy indices and names so we can trap deferred errors\n        return new Proxy(this, {\n            get: (target, prop, receiver) => {\n                if (typeof(prop) === \"string\") {\n\n                    // Index accessor\n                    if (prop.match(/^[0-9]+$/)) {\n                        const index = getNumber(prop, \"%index\");\n                        if (index < 0 || index >= this.length) {\n                            throw new RangeError(\"out of result range\");\n                        }\n\n                        const item = target[index];\n                        if (item instanceof Error) {\n                            throwError(`index ${ index }`, item);\n                        }\n                        return item;\n                    }\n\n                    // Pass important checks (like `then` for Promise) through\n                    if (passProperties.indexOf(prop) >= 0) {\n                        return Reflect.get(target, prop, receiver);\n                    }\n\n                    const value = target[prop];\n                    if (value instanceof Function) {\n                        // Make sure functions work with private variables\n                        // See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy#no_private_property_forwarding\n                        return function(this: any, ...args: Array<any>) {\n                            return value.apply((this === receiver) ? target: this, args);\n                        };\n\n                    } else if (!(prop in target)) {\n                        // Possible name accessor\n                        return target.getValue.apply((this === receiver) ? target: this, [ prop ]);\n                    }\n                }\n\n                return Reflect.get(target, prop, receiver);\n            }\n        });\n    }\n\n    /**\n     *  Returns the Result as a normal Array.\n     *\n     *  This will throw if there are any outstanding deferred\n     *  errors.\n     */\n    toArray(): Array<any> {\n        const result: Array<any> = [ ];\n        this.forEach((item, index) => {\n            if (item instanceof Error) { throwError(`index ${ index }`, item); }\n            result.push(item);\n        });\n        return result;\n    }\n\n    /**\n     *  Returns the Result as an Object with each name-value pair.\n     *\n     *  This will throw if any value is unnamed, or if there are\n     *  any outstanding deferred errors.\n     */\n    toObject(): Record<string, any> {\n        return this.#names.reduce((accum, name, index) => {\n            assert(name != null, \"value at index ${ index } unnamed\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"toObject()\"\n            });\n\n            // Add values for names that don't conflict\n            if (!(name in accum)) {\n                accum[name] = this.getValue(name);\n            }\n\n            return accum;\n        }, <Record<string, any>>{});\n    }\n\n    /**\n     *  @_ignore\n     */\n    slice(start?: number | undefined, end?: number | undefined): Result {\n        if (start == null) { start = 0; }\n        if (start < 0) {\n            start += this.length;\n            if (start < 0) { start = 0; }\n        }\n\n        if (end == null) { end = this.length; }\n        if (end < 0) {\n            end += this.length;\n            if (end < 0) { end = 0; }\n        }\n        if (end > this.length) { end = this.length; }\n\n        const result = [ ], names = [ ];\n        for (let i = start; i < end; i++) {\n            result.push(this[i]);\n            names.push(this.#names[i]);\n        }\n\n        return new Result(_guard, result, names);\n    }\n\n    /**\n     *  @_ignore\n     */\n    filter(callback: (el: any, index: number, array: Result) => boolean, thisArg?: any): Result {\n        const result = [ ], names = [ ];\n        for (let i = 0; i < this.length; i++) {\n            const item = this[i];\n            if (item instanceof Error) {\n                throwError(`index ${ i }`, item);\n            }\n\n            if (callback.call(thisArg, item, i, this)) {\n                result.push(item);\n                names.push(this.#names[i]);\n            }\n        }\n\n        return new Result(_guard, result, names);\n    }\n\n\n    /**\n     *  Returns the value for %%name%%.\n     *\n     *  Since it is possible to have a key whose name conflicts with\n     *  a method on a [[Result]] or its superclass Array, or any\n     *  JavaScript keyword, this ensures all named values are still\n     *  accessible by name.\n     */\n    getValue(name: string): any {\n        const index = this.#names.indexOf(name);\n        if (index === -1) { return undefined; }\n\n        const value = this[index];\n\n        if (value instanceof Error) {\n            throwError(`property ${ JSON.stringify(name) }`, (<any>value).error);\n        }\n\n        return value;\n    }\n\n    /**\n     *  Creates a new [[Result]] for %%items%% with each entry\n     *  also accessible by its corresponding name in %%keys%%.\n     */\n    static fromItems(items: Array<any>, keys?: Array<null | string>): Result {\n        return new Result(_guard, items, keys);\n    }\n}\n\n/**\n *  Returns all errors found in a [[Result]].\n *\n *  Since certain errors encountered when creating a [[Result]] do\n *  not impact the ability to continue parsing data, they are\n *  deferred until they are actually accessed. Hence a faulty string\n *  in an Event that is never used does not impact the program flow.\n *\n *  However, sometimes it may be useful to access, identify or\n *  validate correctness of a [[Result]].\n *\n *  @_docloc api/abi\n */\nexport function checkResultErrors(result: Result): Array<{ path: Array<string | number>, error: Error }> {\n    // Find the first error (if any)\n    const errors: Array<{ path: Array<string | number>, error: Error }> = [ ];\n\n    const checkErrors = function(path: Array<string | number>, object: any): void {\n        if (!Array.isArray(object)) { return; }\n        for (let key in object) {\n            const childPath = path.slice();\n            childPath.push(key);\n\n            try {\n                 checkErrors(childPath, object[key]);\n            } catch (error: any) {\n                errors.push({ path: childPath, error: error });\n            }\n        }\n    }\n    checkErrors([ ], result);\n\n    return errors;\n\n}\n\nfunction getValue(value: BigNumberish): Uint8Array {\n    let bytes = toBeArray(value);\n\n    assert (bytes.length <= WordSize, \"value out-of-bounds\",\n        \"BUFFER_OVERRUN\", { buffer: bytes, length: WordSize, offset: bytes.length });\n\n    if (bytes.length !== WordSize) {\n        bytes = getBytesCopy(concat([ Padding.slice(bytes.length % WordSize), bytes ]));\n    }\n\n    return bytes;\n}\n\n/**\n *  @_ignore\n */\nexport abstract class Coder {\n\n    // The coder name:\n    //   - address, uint256, tuple, array, etc.\n    readonly name!: string;\n\n    // The fully expanded type, including composite types:\n    //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.\n    readonly type!: string;\n\n    // The localName bound in the signature, in this example it is \"baz\":\n    //   - tuple(address foo, uint bar) baz\n    readonly localName!: string;\n\n    // Whether this type is dynamic:\n    //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.\n    //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)\n    readonly dynamic!: boolean;\n\n    constructor(name: string, type: string, localName: string, dynamic: boolean) {\n        defineProperties<Coder>(this, { name, type, localName, dynamic }, {\n            name: \"string\", type: \"string\", localName: \"string\", dynamic: \"boolean\"\n        });\n    }\n\n    _throwError(message: string, value: any): never {\n        assertArgument(false, message, this.localName, value);\n    }\n\n    abstract encode(writer: Writer, value: any): number;\n    abstract decode(reader: Reader): any;\n\n    abstract defaultValue(): any;\n}\n\n/**\n *  @_ignore\n */\nexport class Writer {\n    // An array of WordSize lengthed objects to concatenation\n    #data: Array<Uint8Array>;\n    #dataLength: number;\n\n    constructor() {\n        this.#data = [ ];\n        this.#dataLength = 0;\n    }\n\n    get data(): string {\n        return concat(this.#data);\n    }\n    get length(): number { return this.#dataLength; }\n\n    #writeData(data: Uint8Array): number {\n        this.#data.push(data);\n        this.#dataLength += data.length;\n        return data.length;\n    }\n\n    appendWriter(writer: Writer): number {\n        return this.#writeData(getBytesCopy(writer.data));\n    }\n\n    // Arrayish item; pad on the right to *nearest* WordSize\n    writeBytes(value: BytesLike): number {\n        let bytes = getBytesCopy(value);\n        const paddingOffset = bytes.length % WordSize;\n        if (paddingOffset) {\n            bytes = getBytesCopy(concat([ bytes, Padding.slice(paddingOffset) ]))\n        }\n        return this.#writeData(bytes);\n    }\n\n    // Numeric item; pad on the left *to* WordSize\n    writeValue(value: BigNumberish): number {\n        return this.#writeData(getValue(value));\n    }\n\n    // Inserts a numeric place-holder, returning a callback that can\n    // be used to asjust the value later\n    writeUpdatableValue(): (value: BigNumberish) => void {\n        const offset = this.#data.length;\n        this.#data.push(Padding);\n        this.#dataLength += WordSize;\n        return (value: BigNumberish) => {\n            this.#data[offset] = getValue(value);\n        };\n    }\n}\n\n/**\n *  @_ignore\n */\nexport class Reader {\n    // Allows incomplete unpadded data to be read; otherwise an error\n    // is raised if attempting to overrun the buffer. This is required\n    // to deal with an old Solidity bug, in which event data for\n    // external (not public thoguh) was tightly packed.\n    readonly allowLoose!: boolean;\n\n    readonly #data: Uint8Array;\n    #offset: number;\n\n    constructor(data: BytesLike, allowLoose?: boolean) {\n        defineProperties<Reader>(this, { allowLoose: !!allowLoose });\n\n        this.#data = getBytesCopy(data);\n\n        this.#offset = 0;\n    }\n\n    get data(): string { return hexlify(this.#data); }\n    get dataLength(): number { return this.#data.length; }\n    get consumed(): number { return this.#offset; }\n    get bytes(): Uint8Array { return new Uint8Array(this.#data); }\n\n    #peekBytes(offset: number, length: number, loose?: boolean): Uint8Array {\n        let alignedLength = Math.ceil(length / WordSize) * WordSize;\n        if (this.#offset + alignedLength > this.#data.length) {\n            if (this.allowLoose && loose && this.#offset + length <= this.#data.length) {\n                alignedLength = length;\n            } else {\n                assert(false, \"data out-of-bounds\", \"BUFFER_OVERRUN\", {\n                    buffer: getBytesCopy(this.#data),\n                    length: this.#data.length,\n                    offset: this.#offset + alignedLength\n                });\n            }\n        }\n        return this.#data.slice(this.#offset, this.#offset + alignedLength)\n    }\n\n    // Create a sub-reader with the same underlying data, but offset\n    subReader(offset: number): Reader {\n        return new Reader(this.#data.slice(this.#offset + offset), this.allowLoose);\n    }\n\n    // Read bytes\n    readBytes(length: number, loose?: boolean): Uint8Array {\n        let bytes = this.#peekBytes(0, length, !!loose);\n        this.#offset += bytes.length;\n        // @TODO: Make sure the length..end bytes are all 0?\n        return bytes.slice(0, length);\n    }\n\n    // Read a numeric values\n    readValue(): bigint {\n        return toBigInt(this.readBytes(WordSize));\n    }\n\n    readIndex(): number {\n        return toNumber(this.readBytes(WordSize));\n    }\n}\n","import { keccak256 } from \"../crypto/index.js\";\nimport { getBytes, assertArgument } from \"../utils/index.js\";\n\n\nconst BN_0 = BigInt(0);\nconst BN_36 = BigInt(36);\n\nfunction getChecksumAddress(address: string): string {\n//    if (!isHexString(address, 20)) {\n//        logger.throwArgumentError(\"invalid address\", \"address\", address);\n//    }\n\n    address = address.toLowerCase();\n\n    const chars = address.substring(2).split(\"\");\n\n    const expanded = new Uint8Array(40);\n    for (let i = 0; i < 40; i++) {\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n\n    const hashed = getBytes(keccak256(expanded));\n\n    for (let i = 0; i < 40; i += 2) {\n        if ((hashed[i >> 1] >> 4) >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n\n    return \"0x\" + chars.join(\"\");\n}\n\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n\n// Create lookup table\nconst ibanLookup: { [character: string]: string } = { };\nfor (let i = 0; i < 10; i++) { ibanLookup[String(i)] = String(i); }\nfor (let i = 0; i < 26; i++) { ibanLookup[String.fromCharCode(65 + i)] = String(10 + i); }\n\n// How many decimal digits can we process? (for 64-bit float, this is 15)\n// i.e. Math.floor(Math.log10(Number.MAX_SAFE_INTEGER));\nconst safeDigits = 15;\n\nfunction ibanChecksum(address: string): string {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n\n    let expanded = address.split(\"\").map((c) => { return ibanLookup[c]; }).join(\"\");\n\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while (expanded.length >= safeDigits){\n        let block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n\n    let checksum = String(98 - (parseInt(expanded, 10) % 97));\n    while (checksum.length < 2) { checksum = \"0\" + checksum; }\n\n    return checksum;\n};\n\nconst Base36 = (function() {;\n    const result: Record<string, bigint> = { };\n    for (let i = 0; i < 36; i++) {\n        const key = \"0123456789abcdefghijklmnopqrstuvwxyz\"[i];\n        result[key] = BigInt(i);\n    }\n    return result;\n})();\n\nfunction fromBase36(value: string): bigint {\n    value = value.toLowerCase();\n\n    let result = BN_0;\n    for (let i = 0; i < value.length; i++) {\n        result = result * BN_36 + Base36[value[i]];\n    }\n    return result;\n}\n\n/**\n *  Returns a normalized and checksumed address for %%address%%.\n *  This accepts non-checksum addresses, checksum addresses and\n *  [[getIcapAddress]] formats.\n *\n *  The checksum in Ethereum uses the capitalization (upper-case\n *  vs lower-case) of the characters within an address to encode\n *  its checksum, which offers, on average, a checksum of 15-bits.\n *\n *  If %%address%% contains both upper-case and lower-case, it is\n *  assumed to already be a checksum address and its checksum is\n *  validated, and if the address fails its expected checksum an\n *  error is thrown.\n *\n *  If you wish the checksum of %%address%% to be ignore, it should\n *  be converted to lower-case (i.e. ``.toLowercase()``) before\n *  being passed in. This should be a very rare situation though,\n *  that you wish to bypass the safegaurds in place to protect\n *  against an address that has been incorrectly copied from another\n *  source.\n *\n *  @example:\n *    // Adds the checksum (via upper-casing specific letters)\n *    getAddress(\"0x8ba1f109551bd432803012645ac136ddd64dba72\")\n *    //_result:\n *\n *    // Converts ICAP address and adds checksum\n *    getAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\");\n *    //_result:\n *\n *    // Throws an error if an address contains mixed case,\n *    // but the checksum fails\n *    getAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_error:\n */\nexport function getAddress(address: string): string {\n\n    assertArgument(typeof(address) === \"string\", \"invalid address\", \"address\", address);\n\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n\n        // Missing the 0x prefix\n        if (!address.startsWith(\"0x\")) { address = \"0x\" + address; }\n\n        const result = getChecksumAddress(address);\n\n        // It is a checksummed address with a bad checksum\n        assertArgument(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result === address,\n            \"bad address checksum\", \"address\", address);\n\n        return result;\n    }\n\n    // Maybe ICAP? (we only support direct mode)\n    if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n        // It is an ICAP address with a bad checksum\n        assertArgument(address.substring(2, 4) === ibanChecksum(address), \"bad icap checksum\", \"address\", address);\n\n        let result = fromBase36(address.substring(4)).toString(16);\n        while (result.length < 40) { result = \"0\" + result; }\n        return  getChecksumAddress(\"0x\" + result);\n    }\n\n    assertArgument(false, \"invalid address\", \"address\", address);\n}\n\n/**\n *  The [ICAP Address format](link-icap) format is an early checksum\n *  format which attempts to be compatible with the banking\n *  industry [IBAN format](link-wiki-iban) for bank accounts.\n *\n *  It is no longer common or a recommended format.\n *\n *  @example:\n *    getIcapAddress(\"0x8ba1f109551bd432803012645ac136ddd64dba72\");\n *    //_result:\n *\n *    getIcapAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\");\n *    //_result:\n *\n *    // Throws an error if the ICAP checksum is wrong\n *    getIcapAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK37\");\n *    //_error:\n */\nexport function getIcapAddress(address: string): string {\n    //let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\n    let base36 = BigInt(getAddress(address)).toString(36).toUpperCase();\n    while (base36.length < 30) { base36 = \"0\" + base36; }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n}\n","import { getAddress } from \"../../address/index.js\";\nimport { toBeHex } from \"../../utils/maths.js\";\n\nimport { Typed } from \"../typed.js\";\nimport { Coder } from \"./abstract-coder.js\";\n\nimport type { Reader, Writer } from \"./abstract-coder.js\";\n\n\n/**\n *  @_ignore\n */\nexport class AddressCoder extends Coder {\n\n    constructor(localName: string) {\n        super(\"address\", \"address\", localName, false);\n    }\n\n    defaultValue(): string {\n        return \"0x0000000000000000000000000000000000000000\";\n    }\n\n    encode(writer: Writer, _value: string | Typed): number {\n        let value = Typed.dereference(_value, \"string\");\n        try {\n            value = getAddress(value);\n        } catch (error: any) {\n            return this._throwError(error.message, _value);\n        }\n        return writer.writeValue(value);\n    }\n\n    decode(reader: Reader): any {\n        return getAddress(toBeHex(reader.readValue(), 20));\n    }\n}\n","import { Coder } from \"./abstract-coder.js\";\n\nimport type { Reader, Writer } from \"./abstract-coder.js\";\n\n/**\n *  Clones the functionality of an existing Coder, but without a localName\n *\n *  @_ignore\n */\nexport class AnonymousCoder extends Coder {\n    private coder: Coder;\n\n    constructor(coder: Coder) {\n        super(coder.name, coder.type, \"_\", coder.dynamic);\n        this.coder = coder;\n    }\n\n    defaultValue(): any {\n        return this.coder.defaultValue();\n    }\n\n    encode(writer: Writer, value: any): number {\n        return this.coder.encode(writer, value);\n    }\n\n    decode(reader: Reader): any {\n        return this.coder.decode(reader);\n    }\n}\n","import {\n    defineProperties, isError, assert, assertArgument, assertArgumentCount\n} from \"../../utils/index.js\";\n\nimport { Typed } from \"../typed.js\";\n\nimport { Coder, Result, WordSize, Writer } from \"./abstract-coder.js\";\nimport { AnonymousCoder } from \"./anonymous.js\";\n\nimport type { Reader } from \"./abstract-coder.js\";\n\n/**\n *  @_ignore\n */\nexport function pack(writer: Writer, coders: ReadonlyArray<Coder>, values: Array<any> | { [ name: string ]: any }): number {\n    let arrayValues: Array<any> = [ ];\n\n    if (Array.isArray(values)) {\n       arrayValues = values;\n\n    } else if (values && typeof(values) === \"object\") {\n        let unique: { [ name: string ]: boolean } = { };\n\n        arrayValues = coders.map((coder) => {\n            const name = coder.localName;\n            assert(name, \"cannot encode object for signature with missing names\",\n                \"INVALID_ARGUMENT\", { argument: \"values\", info: { coder }, value: values });\n\n            assert(!unique[name], \"cannot encode object for signature with duplicate names\",\n                \"INVALID_ARGUMENT\", { argument: \"values\", info: { coder }, value: values });\n\n            unique[name] = true;\n\n            return values[name];\n        });\n\n    } else {\n        assertArgument(false, \"invalid tuple value\", \"tuple\", values);\n    }\n\n    assertArgument(coders.length === arrayValues.length, \"types/value length mismatch\", \"tuple\", values);\n\n    let staticWriter = new Writer();\n    let dynamicWriter = new Writer();\n\n    let updateFuncs: Array<(baseOffset: number) => void> = [];\n    coders.forEach((coder, index) => {\n        let value = arrayValues[index];\n\n        if (coder.dynamic) {\n            // Get current dynamic offset (for the future pointer)\n            let dynamicOffset = dynamicWriter.length;\n\n            // Encode the dynamic value into the dynamicWriter\n            coder.encode(dynamicWriter, value);\n\n            // Prepare to populate the correct offset once we are done\n            let updateFunc = staticWriter.writeUpdatableValue();\n            updateFuncs.push((baseOffset: number) => {\n                updateFunc(baseOffset + dynamicOffset);\n            });\n\n        } else {\n            coder.encode(staticWriter, value);\n        }\n    });\n\n    // Backfill all the dynamic offsets, now that we know the static length\n    updateFuncs.forEach((func) => { func(staticWriter.length); });\n\n    let length = writer.appendWriter(staticWriter);\n    length += writer.appendWriter(dynamicWriter);\n    return length;\n}\n\n/**\n *  @_ignore\n */\nexport function unpack(reader: Reader, coders: ReadonlyArray<Coder>): Result {\n    let values: Array<any> = [];\n    let keys: Array<null | string> = [ ];\n\n    // A reader anchored to this base\n    let baseReader = reader.subReader(0);\n\n    coders.forEach((coder) => {\n        let value: any = null;\n\n        if (coder.dynamic) {\n            let offset = reader.readIndex();\n            let offsetReader = baseReader.subReader(offset);\n            try {\n                value = coder.decode(offsetReader);\n            } catch (error: any) {\n                // Cannot recover from this\n                if (isError(error, \"BUFFER_OVERRUN\")) {\n                    throw error;\n                }\n\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n\n        } else {\n            try {\n                value = coder.decode(reader);\n            } catch (error: any) {\n                // Cannot recover from this\n                if (isError(error, \"BUFFER_OVERRUN\")) {\n                    throw error;\n                }\n\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n        }\n\n        if (value == undefined) {\n            throw new Error(\"investigate\");\n        }\n\n        values.push(value);\n        keys.push(coder.localName || null);\n    });\n\n    return Result.fromItems(values, keys);\n}\n\n/**\n *  @_ignore\n */\nexport class ArrayCoder extends Coder {\n    readonly coder!: Coder;\n    readonly length!: number;\n\n    constructor(coder: Coder, length: number, localName: string) {\n        const type = (coder.type + \"[\" + (length >= 0 ? length: \"\") + \"]\");\n        const dynamic = (length === -1 || coder.dynamic);\n        super(\"array\", type, localName, dynamic);\n        defineProperties<ArrayCoder>(this, { coder, length });\n    }\n\n    defaultValue(): Array<any> {\n        // Verifies the child coder is valid (even if the array is dynamic or 0-length)\n        const defaultChild = this.coder.defaultValue();\n\n        const result: Array<any> = [];\n        for (let i = 0; i < this.length; i++) {\n            result.push(defaultChild);\n        }\n        return result;\n    }\n\n    encode(writer: Writer, _value: Array<any> | Typed): number {\n        const value = Typed.dereference(_value, \"array\");\n\n        if(!Array.isArray(value)) {\n            this._throwError(\"expected array value\", value);\n        }\n\n        let count = this.length;\n\n        if (count === -1) {\n            count = value.length;\n            writer.writeValue(value.length);\n        }\n\n        assertArgumentCount(value.length, count, \"coder array\" + (this.localName? (\" \"+ this.localName): \"\"));\n\n        let coders = [];\n        for (let i = 0; i < value.length; i++) { coders.push(this.coder); }\n\n        return pack(writer, coders, value);\n    }\n\n    decode(reader: Reader): any {\n        let count = this.length;\n        if (count === -1) {\n            count = reader.readIndex();\n\n            // Check that there is *roughly* enough data to ensure\n            // stray random data is not being read as a length. Each\n            // slot requires at least 32 bytes for their value (or 32\n            // bytes as a link to the data). This could use a much\n            // tighter bound, but we are erroring on the side of safety.\n            assert(count * WordSize <= reader.dataLength, \"insufficient data length\",\n                \"BUFFER_OVERRUN\", { buffer: reader.bytes, offset: count * WordSize, length: reader.dataLength });\n        }\n        let coders = [];\n        for (let i = 0; i < count; i++) { coders.push(new AnonymousCoder(this.coder)); }\n\n        return unpack(reader, coders);\n    }\n}\n\n","import { Typed } from \"../typed.js\";\nimport { Coder } from \"./abstract-coder.js\";\n\nimport type { Reader, Writer } from \"./abstract-coder.js\";\n\n/**\n *  @_ignore\n */\nexport class BooleanCoder extends Coder {\n\n    constructor(localName: string) {\n        super(\"bool\", \"bool\", localName, false);\n    }\n\n    defaultValue(): boolean {\n        return false;\n    }\n\n    encode(writer: Writer, _value: boolean | Typed): number {\n        const value = Typed.dereference(_value, \"bool\");\n        return writer.writeValue(value ? 1: 0);\n    }\n\n    decode(reader: Reader): any {\n        return !!reader.readValue();\n    }\n}\n","import { getBytesCopy, hexlify } from \"../../utils/index.js\";\n\nimport { Coder } from \"./abstract-coder.js\";\n\nimport type { Reader, Writer } from \"./abstract-coder.js\";\n\n\n/**\n *  @_ignore\n */\nexport class DynamicBytesCoder extends Coder {\n    constructor(type: string, localName: string) {\n       super(type, type, localName, true);\n    }\n\n    defaultValue(): string {\n        return \"0x\";\n    }\n\n    encode(writer: Writer, value: any): number {\n        value = getBytesCopy(value);\n        let length = writer.writeValue(value.length);\n        length += writer.writeBytes(value);\n        return length;\n    }\n\n    decode(reader: Reader): any {\n        return reader.readBytes(reader.readIndex(), true);\n    }\n}\n\n/**\n *  @_ignore\n */\nexport class BytesCoder extends DynamicBytesCoder {\n    constructor(localName: string) {\n        super(\"bytes\", localName);\n    }\n\n    decode(reader: Reader): any {\n        return hexlify(super.decode(reader));\n    }\n}\n","\nimport { defineProperties, getBytesCopy, hexlify } from \"../../utils/index.js\";\n\nimport { Typed } from \"../typed.js\";\nimport { Coder } from \"./abstract-coder.js\";\n\nimport type { BytesLike } from \"../../utils/index.js\";\n\nimport type { Reader, Writer } from \"./abstract-coder.js\";\n\n\n/**\n *  @_ignore\n */\nexport class FixedBytesCoder extends Coder {\n    readonly size!: number;\n\n    constructor(size: number, localName: string) {\n        let name = \"bytes\" + String(size);\n        super(name, name, localName, false);\n        defineProperties<FixedBytesCoder>(this, { size }, { size: \"number\" });\n    }\n\n    defaultValue(): string {\n        return (\"0x0000000000000000000000000000000000000000000000000000000000000000\").substring(0, 2 + this.size * 2);\n    }\n\n    encode(writer: Writer, _value: BytesLike | Typed): number {\n        let data = getBytesCopy(Typed.dereference(_value, this.type));\n        if (data.length !== this.size) { this._throwError(\"incorrect data length\", _value); }\n        return writer.writeBytes(data);\n    }\n\n    decode(reader: Reader): any {\n        return hexlify(reader.readBytes(this.size));\n    }\n}\n","import { Coder } from \"./abstract-coder.js\";\nimport type { Reader, Writer } from \"./abstract-coder.js\";\n\nconst Empty = new Uint8Array([ ]);\n\n/**\n *  @_ignore\n */\nexport class NullCoder extends Coder {\n\n    constructor(localName: string) {\n        super(\"null\", \"\", localName, false);\n    }\n\n    defaultValue(): null {\n        return null;\n    }\n\n    encode(writer: Writer, value: any): number {\n        if (value != null) { this._throwError(\"not null\", value); }\n        return writer.writeBytes(Empty);\n    }\n\n    decode(reader: Reader): any {\n        reader.readBytes(0);\n        return null;\n    }\n}\n","import {\n    defineProperties, fromTwos, getBigInt, mask, toTwos\n} from \"../../utils/index.js\";\n\nimport { Typed } from \"../typed.js\";\nimport { Coder, WordSize } from \"./abstract-coder.js\";\n\nimport type { BigNumberish } from \"../../utils/index.js\";\n\nimport type { Reader, Writer } from \"./abstract-coder.js\";\n\n\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_MAX_UINT256 = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n\n/**\n *  @_ignore\n */\nexport class NumberCoder extends Coder {\n    readonly size!: number;\n    readonly signed!: boolean;\n\n    constructor(size: number, signed: boolean, localName: string) {\n        const name = ((signed ? \"int\": \"uint\") + (size * 8));\n        super(name, name, localName, false);\n\n        defineProperties<NumberCoder>(this, { size, signed }, { size: \"number\", signed: \"boolean\" });\n    }\n\n    defaultValue(): number {\n        return 0;\n    }\n\n    encode(writer: Writer, _value: BigNumberish | Typed): number {\n        let value = getBigInt(Typed.dereference(_value, this.type));\n\n        // Check bounds are safe for encoding\n        let maxUintValue = mask(BN_MAX_UINT256, WordSize * 8);\n        if (this.signed) {\n            let bounds = mask(maxUintValue, (this.size * 8) - 1);\n            if (value > bounds || value < -(bounds + BN_1)) {\n                this._throwError(\"value out-of-bounds\", _value);\n            }\n            value = toTwos(value, 8 * WordSize);\n        } else if (value < BN_0 || value > mask(maxUintValue, this.size * 8)) {\n            this._throwError(\"value out-of-bounds\", _value);\n        }\n\n        return writer.writeValue(value);\n    }\n\n    decode(reader: Reader): any {\n        let value = mask(reader.readValue(), this.size * 8);\n\n        if (this.signed) {\n            value = fromTwos(value, this.size * 8);\n        }\n\n        return value;\n    }\n}\n\n","import { toUtf8Bytes, toUtf8String } from \"../../utils/utf8.js\";\n\nimport { Typed } from \"../typed.js\";\nimport { DynamicBytesCoder } from \"./bytes.js\";\n\nimport type { Reader, Writer } from \"./abstract-coder.js\";\n\n\n/**\n *  @_ignore\n */\nexport class StringCoder extends DynamicBytesCoder {\n\n    constructor(localName: string) {\n        super(\"string\", localName);\n    }\n\n    defaultValue(): string {\n        return \"\";\n    }\n\n    encode(writer: Writer, _value: string | Typed): number {\n        return super.encode(writer, toUtf8Bytes(Typed.dereference(_value, \"string\")));\n    }\n\n    decode(reader: Reader): any {\n        return toUtf8String(super.decode(reader));\n    }\n}\n","import { defineProperties } from \"../../utils/properties.js\";\n\nimport { Typed } from \"../typed.js\";\nimport { Coder } from \"./abstract-coder.js\";\n\nimport { pack, unpack } from \"./array.js\";\n\nimport type { Reader, Writer } from \"./abstract-coder.js\";\n\n/**\n *  @_ignore\n */\nexport class TupleCoder extends Coder {\n    readonly coders!: ReadonlyArray<Coder>;\n\n    constructor(coders: Array<Coder>, localName: string) {\n        let dynamic = false;\n        const types: Array<string> = [];\n        coders.forEach((coder) => {\n            if (coder.dynamic) { dynamic = true; }\n            types.push(coder.type);\n        });\n        const type = (\"tuple(\" + types.join(\",\") + \")\");\n\n        super(\"tuple\", type, localName, dynamic);\n        defineProperties<TupleCoder>(this, { coders: Object.freeze(coders.slice()) });\n    }\n\n    defaultValue(): any {\n        const values: any = [ ];\n        this.coders.forEach((coder) => {\n            values.push(coder.defaultValue());\n        });\n\n        // We only output named properties for uniquely named coders\n        const uniqueNames = this.coders.reduce((accum, coder) => {\n            const name = coder.localName;\n            if (name) {\n                if (!accum[name]) { accum[name] = 0; }\n                accum[name]++;\n            }\n            return accum;\n        }, <{ [ name: string ]: number }>{ });\n\n        // Add named values\n        this.coders.forEach((coder: Coder, index: number) => {\n            let name = coder.localName;\n            if (!name || uniqueNames[name] !== 1) { return; }\n\n            if (name === \"length\") { name = \"_length\"; }\n\n            if (values[name] != null) { return; }\n\n            values[name] = values[index];\n        });\n\n        return Object.freeze(values);\n    }\n\n    encode(writer: Writer, _value: Array<any> | { [ name: string ]: any } | Typed): number {\n        const value = Typed.dereference(_value, \"tuple\");\n        return pack(writer, this.coders, value);\n    }\n\n    decode(reader: Reader): any {\n        return unpack(reader, this.coders);\n    }\n}\n\n","/**\n *  About frgaments...\n *\n *  @_subsection api/abi/abi-coder:Fragments  [about-fragments]\n */\n\nimport {\n    defineProperties, getBigInt, getNumber,\n    assert, assertPrivate, assertArgument\n} from \"../utils/index.js\";\nimport { id } from \"../hash/index.js\";\n\n/**\n *  A type description in a JSON API.\n */\nexport interface JsonFragmentType {\n    /**\n     *  The parameter name.\n     */\n    readonly name?: string;\n\n    /**\n     *  If the parameter is indexed.\n     */\n    readonly indexed?: boolean;\n\n    /**\n     *  The type of the parameter.\n     */\n    readonly type?: string;\n\n    /**\n     *  The internal Solidity type.\n     */\n    readonly internalType?: string;\n\n    /**\n     *  The components for a tuple.\n     */\n    readonly components?: ReadonlyArray<JsonFragmentType>;\n}\n\n/**\n *  A fragment for a method, event or error in a JSON API.\n */\nexport interface JsonFragment {\n    /**\n     *  The name of the error, event, function, etc.\n     */\n    readonly name?: string;\n\n    /**\n     *  The type of the fragment (e.g. ``event``, ``\"function\"``, etc.)\n     */\n    readonly type?: string;\n\n    /**\n     *  If the event is anonymous.\n     */\n    readonly anonymous?: boolean;\n\n    /**\n     *  If the function is payable.\n     */\n    readonly payable?: boolean;\n\n    /**\n     *  If the function is constant.\n     */\n    readonly constant?: boolean;\n\n    /**\n     *  The mutability state of the function.\n     */\n    readonly stateMutability?: string;\n\n    /**\n     *  The input parameters.\n     */\n    readonly inputs?: ReadonlyArray<JsonFragmentType>;\n\n    /**\n     *  The output parameters.\n     */\n    readonly outputs?: ReadonlyArray<JsonFragmentType>;\n\n    /**\n     *  The gas limit to use when sending a transaction for this function.\n     */\n    readonly gas?: string;\n};\n\n/**\n *  The format to serialize the output as.\n */\nexport type FormatType =\n    // Bare formatting, as is needed for computing a sighash of an event or function\n    \"sighash\" |\n\n    // Human-Readable with Minimal spacing and without names (compact human-readable)\n    \"minimal\" |\n\n    // Human-Readable with nice spacing, including all names\n    \"full\" |\n\n    // JSON-format a la Solidity\n    \"json\";\n\n// [ \"a\", \"b\" ] => { \"a\": 1, \"b\": 1 }\nfunction setify(items: Array<string>): ReadonlySet<string> {\n    const result: Set<string> = new Set();\n    items.forEach((k) => result.add(k));\n    return Object.freeze(result);\n}\n\n// Visibility Keywords\nconst _kwVisib = \"constant external internal payable private public pure view\";\nconst KwVisib = setify(_kwVisib.split(\" \"));\n\nconst _kwTypes = \"constructor error event fallback function receive struct\";\nconst KwTypes = setify(_kwTypes.split(\" \"));\n\nconst _kwModifiers = \"calldata memory storage payable indexed\";\nconst KwModifiers = setify(_kwModifiers.split(\" \"));\n\nconst _kwOther = \"tuple returns\";\n\n// All Keywords\nconst _keywords = [ _kwTypes, _kwModifiers, _kwOther, _kwVisib ].join(\" \");\nconst Keywords = setify(_keywords.split(\" \"));\n\n// Single character tokens\nconst SimpleTokens: Record<string, string> = {\n  \"(\": \"OPEN_PAREN\", \")\": \"CLOSE_PAREN\",\n  \"[\": \"OPEN_BRACKET\", \"]\": \"CLOSE_BRACKET\",\n  \",\": \"COMMA\", \"@\": \"AT\"\n};\n\n// Parser regexes to consume the next token\nconst regexWhitespacePrefix = new RegExp(\"^(\\\\s*)\");\nconst regexNumberPrefix = new RegExp(\"^([0-9]+)\");\nconst regexIdPrefix = new RegExp(\"^([a-zA-Z$_][a-zA-Z0-9$_]*)\");\n\n// Parser regexs to check validity\nconst regexId = new RegExp(\"^([a-zA-Z$_][a-zA-Z0-9$_]*)$\");\nconst regexType = new RegExp(\"^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$\");\n\n/**\n *  @ignore:\n */\ntype Token = Readonly<{\n    // Type of token (e.g. TYPE, KEYWORD, NUMBER, etc)\n    type: string;\n\n    // Offset into the original source code\n    offset: number;\n\n    // Actual text content of the token\n    text: string;\n\n    // The parenthesis depth\n    depth: number;\n\n    // If a parenthesis, the offset (in tokens) that balances it\n    match: number;\n\n    // For parenthesis and commas, the offset (in tokens) to the\n    // previous/next parenthesis or comma in the list\n    linkBack: number;\n    linkNext: number;\n\n    // If a BRACKET, the value inside\n    value: number;\n}>;\n\nclass TokenString {\n    #offset: number;\n    #tokens: ReadonlyArray<Token>;\n\n    get offset(): number { return this.#offset; }\n    get length(): number { return this.#tokens.length - this.#offset; }\n\n    constructor(tokens: ReadonlyArray<Token>) {\n        this.#offset = 0;\n        this.#tokens = tokens.slice();\n    }\n\n    clone(): TokenString { return new TokenString(this.#tokens); }\n    reset(): void { this.#offset = 0; }\n\n    #subTokenString(from: number = 0, to: number = 0): TokenString {\n        return new TokenString(this.#tokens.slice(from, to).map((t) => {\n            return Object.freeze(Object.assign({ }, t, {\n                match: (t.match - from),\n                linkBack: (t.linkBack - from),\n                linkNext: (t.linkNext - from),\n            }));\n        }));\n    }\n\n    // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens\n    popKeyword(allowed: ReadonlySet<string>): string {\n        const top = this.peek();\n        if (top.type !== \"KEYWORD\" || !allowed.has(top.text)) { throw new Error(`expected keyword ${ top.text }`); }\n        return this.pop().text;\n    }\n\n    // Pops and returns the value of the next token if it is `type`; throws if out of tokens\n    popType(type: string): string {\n        if (this.peek().type !== type) { throw new Error(`expected ${ type }; got ${ JSON.stringify(this.peek()) }`); }\n        return this.pop().text;\n    }\n\n    // Pops and returns a \"(\" TOKENS \")\"\n    popParen(): TokenString {\n        const top = this.peek();\n        if (top.type !== \"OPEN_PAREN\") { throw new Error(\"bad start\"); }\n        const result = this.#subTokenString(this.#offset + 1, top.match + 1);\n        this.#offset = top.match + 1;\n        return result;\n    }\n\n    // Pops and returns the items within \"(\" ITEM1 \",\" ITEM2 \",\" ... \")\"\n    popParams(): Array<TokenString> {\n        const top = this.peek();\n\n        if (top.type !== \"OPEN_PAREN\") { throw new Error(\"bad start\"); }\n\n        const result: Array<TokenString> = [ ];\n\n        while(this.#offset < top.match - 1) {\n            const link = this.peek().linkNext;\n            result.push(this.#subTokenString(this.#offset + 1, link));\n            this.#offset = link;\n        }\n\n        this.#offset = top.match + 1;\n\n        return result;\n    }\n\n    // Returns the top Token, throwing if out of tokens\n    peek(): Token {\n        if (this.#offset >= this.#tokens.length) {\n            throw new Error(\"out-of-bounds\");\n        }\n        return this.#tokens[this.#offset];\n    }\n\n    // Returns the next value, if it is a keyword in `allowed`\n    peekKeyword(allowed: ReadonlySet<string>): null | string {\n        const top = this.peekType(\"KEYWORD\");\n        return (top != null && allowed.has(top)) ? top: null;\n    }\n\n    // Returns the value of the next token if it is `type`\n    peekType(type: string): null | string {\n        if (this.length === 0) { return null; }\n        const top = this.peek();\n        return (top.type === type) ? top.text: null;\n    }\n\n    // Returns the next token; throws if out of tokens\n    pop(): Token {\n        const result = this.peek();\n        this.#offset++;\n        return result;\n    }\n\n    toString(): string {\n        const tokens: Array<string> = [ ];\n        for (let i = this.#offset; i < this.#tokens.length; i++) {\n            const token = this.#tokens[i];\n            tokens.push(`${ token.type }:${ token.text }`);\n        }\n        return `<TokenString ${ tokens.join(\" \") }>`\n    }\n}\n\ntype Writeable<T> = { -readonly [P in keyof T]: T[P] };\n\nfunction lex(text: string): TokenString {\n    const tokens: Array<Token> = [ ];\n\n    const throwError = (message: string) => {\n        const token = (offset < text.length) ? JSON.stringify(text[offset]): \"$EOI\";\n        throw new Error(`invalid token ${ token } at ${ offset }: ${ message }`);\n    };\n\n    let brackets: Array<number> = [ ];\n    let commas: Array<number> = [ ];\n\n    let offset = 0;\n    while (offset < text.length) {\n\n        // Strip off any leading whitespace\n        let cur = text.substring(offset);\n        let match = cur.match(regexWhitespacePrefix);\n        if (match) {\n            offset += match[1].length;\n            cur = text.substring(offset);\n        }\n\n        const token = { depth: brackets.length, linkBack: -1, linkNext: -1, match: -1, type: \"\", text: \"\", offset, value: -1 };\n        tokens.push(token);\n\n        let type = (SimpleTokens[cur[0]] || \"\");\n        if (type) {\n            token.type = type;\n            token.text = cur[0];\n            offset++;\n\n            if (type === \"OPEN_PAREN\") {\n                brackets.push(tokens.length - 1);\n                commas.push(tokens.length - 1);\n\n            } else if (type == \"CLOSE_PAREN\") {\n                if (brackets.length === 0) { throwError(\"no matching open bracket\"); }\n\n                token.match = brackets.pop() as number;\n                (<Writeable<Token>>(tokens[token.match])).match = tokens.length - 1;\n                token.depth--;\n\n                token.linkBack = commas.pop() as number;\n                (<Writeable<Token>>(tokens[token.linkBack])).linkNext = tokens.length - 1;\n\n            } else if (type === \"COMMA\") {\n                token.linkBack = commas.pop() as number;\n                (<Writeable<Token>>(tokens[token.linkBack])).linkNext = tokens.length - 1;\n                commas.push(tokens.length - 1);\n\n            } else if (type === \"OPEN_BRACKET\") {\n                token.type = \"BRACKET\";\n\n            } else if (type === \"CLOSE_BRACKET\") {\n                // Remove the CLOSE_BRACKET\n                let suffix = (tokens.pop() as Token).text;\n                if (tokens.length > 0 && tokens[tokens.length - 1].type === \"NUMBER\") {\n                    const value = (tokens.pop() as Token).text;\n                    suffix = value + suffix;\n                    (<Writeable<Token>>(tokens[tokens.length - 1])).value = getNumber(value);\n                }\n                if (tokens.length === 0 || tokens[tokens.length - 1].type !== \"BRACKET\") {\n                    throw new Error(\"missing opening bracket\");\n                }\n                (<Writeable<Token>>(tokens[tokens.length - 1])).text += suffix;\n            }\n\n            continue;\n        }\n\n        match = cur.match(regexIdPrefix);\n        if (match) {\n            token.text = match[1];\n            offset += token.text.length;\n\n            if (Keywords.has(token.text)) {\n                token.type = \"KEYWORD\";\n                continue;\n            }\n\n            if (token.text.match(regexType)) {\n                token.type = \"TYPE\";\n                continue;\n            }\n\n            token.type = \"ID\";\n            continue;\n        }\n\n        match = cur.match(regexNumberPrefix);\n        if (match) {\n            token.text = match[1];\n            token.type = \"NUMBER\";\n            offset += token.text.length;\n            continue;\n        }\n\n        throw new Error(`unexpected token ${ JSON.stringify(cur[0]) } at position ${ offset }`);\n    }\n\n    return new TokenString(tokens.map((t) => Object.freeze(t)));\n}\n\n// Check only one of `allowed` is in `set`\nfunction allowSingle(set: ReadonlySet<string>, allowed: ReadonlySet<string>): void {\n    let included: Array<string> = [ ];\n    for (const key in allowed.keys()) {\n        if (set.has(key)) { included.push(key); }\n    }\n    if (included.length > 1) { throw new Error(`conflicting types: ${ included.join(\", \") }`); }\n}\n\n// Functions to process a Solidity Signature TokenString from left-to-right for...\n\n// ...the name with an optional type, returning the name\nfunction consumeName(type: string, tokens: TokenString): string {\n    if (tokens.peekKeyword(KwTypes)) {\n        const keyword = tokens.pop().text;\n        if (keyword !== type) {\n            throw new Error(`expected ${ type }, got ${ keyword }`);\n        }\n    }\n\n    return tokens.popType(\"ID\");\n}\n\n// ...all keywords matching allowed, returning the keywords\nfunction consumeKeywords(tokens: TokenString, allowed?: ReadonlySet<string>): ReadonlySet<string> {\n    const keywords: Set<string> = new Set();\n    while (true) {\n        const keyword = tokens.peekType(\"KEYWORD\");\n\n        if (keyword == null || (allowed && !allowed.has(keyword))) { break; }\n        tokens.pop();\n\n        if (keywords.has(keyword)) { throw new Error(`duplicate keywords: ${ JSON.stringify(keyword) }`); }\n        keywords.add(keyword);\n    }\n\n    return Object.freeze(keywords);\n}\n\n// ...all visibility keywords, returning the coalesced mutability\nfunction consumeMutability(tokens: TokenString): \"payable\" | \"nonpayable\" | \"view\" | \"pure\" {\n    let modifiers = consumeKeywords(tokens, KwVisib);\n\n    // Detect conflicting modifiers\n    allowSingle(modifiers, setify(\"constant payable nonpayable\".split(\" \")));\n    allowSingle(modifiers, setify(\"pure view payable nonpayable\".split(\" \")));\n\n    // Process mutability states\n    if (modifiers.has(\"view\")) { return \"view\"; }\n    if (modifiers.has(\"pure\")) { return \"pure\"; }\n    if (modifiers.has(\"payable\")) { return \"payable\"; }\n    if (modifiers.has(\"nonpayable\")) { return \"nonpayable\"; }\n\n    // Process legacy `constant` last\n    if (modifiers.has(\"constant\")) { return \"view\"; }\n\n    return \"nonpayable\";\n}\n\n// ...a parameter list, returning the ParamType list\nfunction consumeParams(tokens: TokenString, allowIndexed?: boolean): Array<ParamType> {\n    return tokens.popParams().map((t) => ParamType.from(t, allowIndexed));\n}\n\n// ...a gas limit, returning a BigNumber or null if none\nfunction consumeGas(tokens: TokenString): null | bigint {\n    if (tokens.peekType(\"AT\")) {\n        tokens.pop();\n        if (tokens.peekType(\"NUMBER\")) {\n            return getBigInt(tokens.pop().text);\n        }\n        throw new Error(\"invalid gas\");\n    }\n    return null;\n}\n\nfunction consumeEoi(tokens: TokenString): void {\n    if (tokens.length) {\n        throw new Error(`unexpected tokens: ${ tokens.toString() }`);\n    }\n}\n\nconst regexArrayType = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\n\nfunction verifyBasicType(type: string): string {\n    const match = type.match(regexType);\n    assertArgument(match, \"invalid type\", \"type\", type);\n    if (type === \"uint\") { return \"uint256\"; }\n    if (type === \"int\") { return \"int256\"; }\n\n    if (match[2]) {\n        // bytesXX\n        const length = parseInt(match[2]);\n        assertArgument(length !== 0 && length <= 32, \"invalid bytes length\", \"type\", type);\n\n    } else if (match[3]) {\n        // intXX or uintXX\n        const size = parseInt(match[3] as string);\n        assertArgument(size !== 0 && size <= 256 && (size % 8) === 0, \"invalid numeric width\", \"type\", type);\n    }\n\n    return type;\n}\n\n// Make the Fragment constructors effectively private\nconst _guard = { };\n\n\n/**\n *  When [walking](ParamType-walk) a [[ParamType]], this is called\n *  on each component.\n */\nexport type ParamTypeWalkFunc = (type: string, value: any) => any;\n\n/**\n *  When [walking asynchronously](ParamType-walkAsync) a [[ParamType]],\n *  this is called on each component.\n */\nexport type ParamTypeWalkAsyncFunc = (type: string, value: any) => any | Promise<any>;\n\nconst internal = Symbol.for(\"_ethers_internal\");\n\nconst ParamTypeInternal = \"_ParamTypeInternal\";\nconst ErrorFragmentInternal = \"_ErrorInternal\";\nconst EventFragmentInternal = \"_EventInternal\";\nconst ConstructorFragmentInternal = \"_ConstructorInternal\";\nconst FallbackFragmentInternal = \"_FallbackInternal\";\nconst FunctionFragmentInternal = \"_FunctionInternal\";\nconst StructFragmentInternal = \"_StructInternal\";\n\n/**\n *  Each input and output of a [[Fragment]] is an Array of **PAramType**.\n */\nexport class ParamType {\n\n    /**\n     *  The local name of the parameter (or ``\"\"`` if unbound)\n     */\n    readonly name!: string;\n\n    /**\n     *  The fully qualified type (e.g. ``\"address\"``, ``\"tuple(address)\"``,\n     *  ``\"uint256[3][]\"``)\n     */\n    readonly type!: string;\n\n    /**\n     *  The base type (e.g. ``\"address\"``, ``\"tuple\"``, ``\"array\"``)\n     */\n    readonly baseType!: string;\n\n    /**\n     *  True if the parameters is indexed.\n     *\n     *  For non-indexable types this is ``null``.\n     */\n    readonly indexed!: null | boolean;\n\n    /**\n     *  The components for the tuple.\n     *\n     *  For non-tuple types this is ``null``.\n     */\n    readonly components!: null | ReadonlyArray<ParamType>;\n\n    /**\n     *  The array length, or ``-1`` for dynamic-lengthed arrays.\n     *\n     *  For non-array types this is ``null``.\n     */\n    readonly arrayLength!: null | number;\n\n    /**\n     *  The type of each child in the array.\n     *\n     *  For non-array types this is ``null``.\n     */\n    readonly arrayChildren!: null | ParamType;\n\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, name: string, type: string, baseType: string, indexed: null | boolean, components: null | ReadonlyArray<ParamType>, arrayLength: null | number, arrayChildren: null | ParamType) {\n        assertPrivate(guard, _guard, \"ParamType\");\n        Object.defineProperty(this, internal, { value: ParamTypeInternal });\n\n        if (components) { components = Object.freeze(components.slice()); }\n\n        if (baseType === \"array\") {\n            if (arrayLength == null || arrayChildren == null) {\n                throw new Error(\"\");\n            }\n        } else if (arrayLength != null || arrayChildren != null) {\n            throw new Error(\"\");\n        }\n\n        if (baseType === \"tuple\") {\n            if (components == null) { throw new Error(\"\"); }\n        } else if (components != null) {\n            throw new Error(\"\");\n        }\n\n        defineProperties<ParamType>(this, {\n            name, type, baseType, indexed, components, arrayLength, arrayChildren\n        });\n    }\n\n    /**\n     *  Return a string representation of this type.\n     *\n     *  For example,\n     *\n     *  ``sighash\" => \"(uint256,address)\"``\n     *\n     *  ``\"minimal\" => \"tuple(uint256,address) indexed\"``\n     *\n     *  ``\"full\" => \"tuple(uint256 foo, address bar) indexed baz\"``\n     */\n    format(format?: FormatType): string {\n        if (format == null) { format = \"sighash\"; }\n        if (format === \"json\") {\n            let result: any = {\n                type: ((this.baseType === \"tuple\") ? \"tuple\": this.type),\n                name: (this.name || undefined)\n            };\n            if (typeof(this.indexed) === \"boolean\") { result.indexed = this.indexed; }\n            if (this.isTuple()) {\n                result.components = this.components.map((c) => JSON.parse(c.format(format)));\n            }\n            return JSON.stringify(result);\n        }\n\n        let result = \"\";\n\n        // Array\n        if (this.isArray()) {\n            result += this.arrayChildren.format(format);\n            result += `[${ (this.arrayLength < 0 ? \"\": String(this.arrayLength)) }]`;\n        } else {\n            if (this.isTuple()) {\n                if (format !== \"sighash\") { result += this.type; }\n                result += \"(\" + this.components.map(\n                    (comp) => comp.format(format)\n                ).join((format === \"full\") ? \", \": \",\") + \")\";\n            } else {\n                result += this.type;\n            }\n        }\n\n        if (format !== \"sighash\") {\n            if (this.indexed === true) { result += \" indexed\"; }\n            if (format === \"full\" && this.name) {\n                result += \" \" + this.name;\n            }\n        }\n\n        return result;\n    }\n\n    /*\n     *  Returns true if %%value%% is an Array type.\n     *\n     *  This provides a type gaurd ensuring that the\n     *  [[arrayChildren]] and [[arrayLength]] are non-null.\n     */\n    //static isArray(value: any): value is { arrayChildren: ParamType, arrayLength: number } {\n    //    return value && (value.baseType === \"array\")\n    //}\n\n    /**\n     *  Returns true if %%this%% is an Array type.\n     *\n     *  This provides a type gaurd ensuring that [[arrayChildren]]\n     *  and [[arrayLength]] are non-null.\n     */\n    isArray(): this is (ParamType & { arrayChildren: ParamType, arrayLength: number }) {\n        return (this.baseType === \"array\")\n    }\n\n    /**\n     *  Returns true if %%this%% is a Tuple type.\n     *\n     *  This provides a type gaurd ensuring that [[components]]\n     *  is non-null.\n     */\n    isTuple(): this is (ParamType & { components: ReadonlyArray<ParamType> }) {\n        return (this.baseType === \"tuple\");\n    }\n\n    /**\n     *  Returns true if %%this%% is an Indexable type.\n     *\n     *  This provides a type gaurd ensuring that [[indexed]]\n     *  is non-null.\n     */\n    isIndexable(): this is (ParamType & { indexed: boolean }) {\n        return (this.indexed != null);\n    }\n\n    /**\n     *  Walks the **ParamType** with %%value%%, calling %%process%%\n     *  on each type, destructing the %%value%% recursively.\n     */\n    walk(value: any, process: ParamTypeWalkFunc): any {\n        if (this.isArray()) {\n            if (!Array.isArray(value)) { throw new Error(\"invalid array value\"); }\n            if (this.arrayLength !== -1 && value.length !== this.arrayLength) {\n                throw new Error(\"array is wrong length\");\n            }\n            const _this = this;\n            return value.map((v) => (_this.arrayChildren.walk(v, process)));\n        }\n\n        if (this.isTuple()) {\n            if (!Array.isArray(value)) { throw new Error(\"invalid tuple value\"); }\n            if (value.length !== this.components.length) {\n                throw new Error(\"array is wrong length\");\n            }\n            const _this = this;\n            return value.map((v, i) => (_this.components[i].walk(v, process)));\n        }\n\n        return process(this.type, value);\n    }\n\n    #walkAsync(promises: Array<Promise<void>>, value: any, process: ParamTypeWalkAsyncFunc, setValue: (value: any) => void): void {\n\n        if (this.isArray()) {\n            if (!Array.isArray(value)) { throw new Error(\"invalid array value\"); }\n            if (this.arrayLength !== -1 && value.length !== this.arrayLength) {\n                throw new Error(\"array is wrong length\");\n            }\n            const childType = this.arrayChildren;\n\n            const result = value.slice();\n            result.forEach((value, index) => {\n                childType.#walkAsync(promises, value, process, (value: any) => {\n                    result[index] = value;\n                });\n            });\n            setValue(result);\n            return;\n        }\n\n        if (this.isTuple()) {\n            const components = this.components;\n\n            // Convert the object into an array\n            let result: Array<any>;\n            if (Array.isArray(value)) {\n                result = value.slice();\n\n            } else {\n                if (value == null || typeof(value) !== \"object\") {\n                    throw new Error(\"invalid tuple value\");\n                }\n\n                result = components.map((param) => {\n                    if (!param.name) { throw new Error(\"cannot use object value with unnamed components\"); }\n                    if (!(param.name in value)) {\n                        throw new Error(`missing value for component ${ param.name }`);\n                    }\n                    return value[param.name];\n                });\n            }\n\n            if (result.length !== this.components.length) {\n                throw new Error(\"array is wrong length\");\n            }\n\n            result.forEach((value, index) => {\n                components[index].#walkAsync(promises, value, process, (value: any) => {\n                    result[index] = value;\n                });\n            });\n            setValue(result);\n            return;\n        }\n\n        const result = process(this.type, value);\n        if (result.then) {\n            promises.push((async function() { setValue(await result); })());\n        } else {\n            setValue(result);\n        }\n    }\n\n    /**\n     *  Walks the **ParamType** with %%value%%, asynchronously calling\n     *  %%process%% on each type, destructing the %%value%% recursively.\n     *\n     *  This can be used to resolve ENS naes by walking and resolving each\n     *  ``\"address\"`` type.\n     */\n    async walkAsync(value: any, process: ParamTypeWalkAsyncFunc): Promise<any> {\n        const promises: Array<Promise<void>> = [ ];\n        const result: [ any ] = [ value ];\n        this.#walkAsync(promises, value, process, (value: any) => {\n            result[0] = value;\n        });\n        if (promises.length) { await Promise.all(promises); }\n        return result[0];\n    }\n\n    /**\n     *  Creates a new **ParamType** for %%obj%%.\n     *\n     *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,\n     *  otherwise the ``indexed`` keyword will throw an error.\n     */\n    static from(obj: any, allowIndexed?: boolean): ParamType {\n        if (ParamType.isParamType(obj)) { return obj; }\n\n        if (typeof(obj) === \"string\") {\n            return ParamType.from(lex(obj), allowIndexed);\n\n        } else if (obj instanceof TokenString) {\n            let type = \"\", baseType = \"\";\n            let comps: null | Array<ParamType> = null;\n\n            if (consumeKeywords(obj, setify([ \"tuple\" ])).has(\"tuple\") || obj.peekType(\"OPEN_PAREN\")) {\n                // Tuple\n                baseType = \"tuple\";\n                comps = obj.popParams().map((t) => ParamType.from(t));\n                type = `tuple(${ comps.map((c) => c.format()).join(\",\") })`;\n            } else {\n                // Normal\n                type = verifyBasicType(obj.popType(\"TYPE\"));\n                baseType = type;\n            }\n\n            // Check for Array\n            let arrayChildren: null | ParamType  = null;\n            let arrayLength: null | number = null;\n\n            while (obj.length && obj.peekType(\"BRACKET\")) {\n                const bracket = obj.pop(); //arrays[i];\n                arrayChildren = new ParamType(_guard, \"\", type, baseType, null, comps, arrayLength, arrayChildren);\n                arrayLength = bracket.value;\n                type += bracket.text;\n                baseType = \"array\";\n                comps = null;\n            }\n\n            let indexed = null;\n            const keywords = consumeKeywords(obj, KwModifiers);\n            if (keywords.has(\"indexed\")) {\n                if (!allowIndexed) { throw new Error(\"\"); }\n                indexed = true;\n            }\n\n            const name = (obj.peekType(\"ID\") ? obj.pop().text: \"\");\n\n            if (obj.length) { throw new Error(\"leftover tokens\"); }\n\n            return new ParamType(_guard, name, type, baseType, indexed, comps, arrayLength, arrayChildren);\n        }\n\n        const name = obj.name;\n        assertArgument(!name || (typeof(name) === \"string\" && name.match(regexId)),\n            \"invalid name\", \"obj.name\", name);\n\n        let indexed = obj.indexed;\n        if (indexed != null) {\n            assertArgument(allowIndexed, \"parameter cannot be indexed\", \"obj.indexed\", obj.indexed);\n            indexed = !!indexed;\n        }\n\n        let type = obj.type;\n\n        let arrayMatch = type.match(regexArrayType);\n        if (arrayMatch) {\n            const arrayLength = parseInt(arrayMatch[2] || \"-1\");\n            const arrayChildren = ParamType.from({\n                type: arrayMatch[1],\n                components: obj.components\n            });\n\n            return new ParamType(_guard, name || \"\", type, \"array\", indexed, null, arrayLength, arrayChildren);\n        }\n\n        if (type === \"tuple\" || type.startsWith(\"tuple(\"/* fix: ) */) || type.startsWith(\"(\" /* fix: ) */)) {\n            const comps = (obj.components != null) ? obj.components.map((c: any) => ParamType.from(c)): null;\n            const tuple = new ParamType(_guard, name || \"\", type, \"tuple\", indexed, comps, null, null);\n            // @TODO: use lexer to validate and normalize type\n            return tuple;\n        }\n\n        type = verifyBasicType(obj.type);\n\n        return new ParamType(_guard, name || \"\", type, type, indexed, null, null, null);\n    }\n\n    /**\n     *  Returns true if %%value%% is a **ParamType**.\n     */\n    static isParamType(value: any): value is ParamType {\n        return (value && value[internal] === ParamTypeInternal);\n    }\n}\n\n/**\n *  The type of a [[Fragment]].\n */\nexport type FragmentType = \"constructor\" | \"error\" | \"event\" | \"fallback\" | \"function\" | \"struct\";\n\n/**\n *  An abstract class to represent An individual fragment from a parse ABI.\n */\nexport abstract class Fragment {\n    /**\n     *  The type of the fragment.\n     */\n    readonly type!: FragmentType;\n\n    /**\n     *  The inputs for the fragment.\n     */\n    readonly inputs!: ReadonlyArray<ParamType>;\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, type: FragmentType, inputs: ReadonlyArray<ParamType>) {\n        assertPrivate(guard, _guard, \"Fragment\");\n        inputs = Object.freeze(inputs.slice());\n        defineProperties<Fragment>(this, { type, inputs });\n    }\n\n    /**\n     *  Returns a string representation of this fragment.\n     */\n    abstract format(format?: FormatType): string;\n\n    /**\n     *  Creates a new **Fragment** for %%obj%%, wich can be any supported\n     *  ABI frgament type.\n     */\n    static from(obj: any): Fragment {\n        if (typeof(obj) === \"string\") {\n\n            // Try parsing JSON...\n            try {\n                Fragment.from(JSON.parse(obj));\n            } catch (e) { }\n\n            // ...otherwise, use the human-readable lexer\n            return Fragment.from(lex(obj));\n        }\n\n        if (obj instanceof TokenString) {\n            // Human-readable ABI (already lexed)\n\n            const type = obj.peekKeyword(KwTypes);\n\n            switch (type) {\n                case \"constructor\": return ConstructorFragment.from(obj);\n                case \"error\": return ErrorFragment.from(obj);\n                case \"event\": return EventFragment.from(obj);\n                case \"fallback\": case \"receive\":\n                    return FallbackFragment.from(obj);\n                case \"function\": return FunctionFragment.from(obj);\n                case \"struct\": return StructFragment.from(obj);\n            }\n\n        } else if (typeof(obj) === \"object\") {\n            // JSON ABI\n\n            switch (obj.type) {\n                case \"constructor\": return ConstructorFragment.from(obj);\n                case \"error\": return ErrorFragment.from(obj);\n                case \"event\": return EventFragment.from(obj);\n                case \"fallback\": case \"receive\":\n                    return FallbackFragment.from(obj);\n                case \"function\": return FunctionFragment.from(obj);\n                case \"struct\": return StructFragment.from(obj);\n            }\n\n            assert(false, `unsupported type: ${ obj.type }`, \"UNSUPPORTED_OPERATION\", {\n                operation: \"Fragment.from\"\n            });\n        }\n\n        assertArgument(false, \"unsupported frgament object\", \"obj\", obj);\n    }\n\n    /**\n     *  Returns true if %%value%% is a [[ConstructorFragment]].\n     */\n    static isConstructor(value: any): value is ConstructorFragment {\n        return ConstructorFragment.isFragment(value);\n    }\n\n    /**\n     *  Returns true if %%value%% is an [[ErrorFragment]].\n     */\n    static isError(value: any): value is ErrorFragment {\n        return ErrorFragment.isFragment(value);\n    }\n\n    /**\n     *  Returns true if %%value%% is an [[EventFragment]].\n     */\n    static isEvent(value: any): value is EventFragment {\n        return EventFragment.isFragment(value);\n    }\n\n    /**\n     *  Returns true if %%value%% is a [[FunctionFragment]].\n     */\n    static isFunction(value: any): value is FunctionFragment {\n        return FunctionFragment.isFragment(value);\n    }\n\n    /**\n     *  Returns true if %%value%% is a [[StructFragment]].\n     */\n    static isStruct(value: any): value is StructFragment {\n        return StructFragment.isFragment(value);\n    }\n}\n\n/**\n *  An abstract class to represent An individual fragment\n *  which has a name from a parse ABI.\n */\nexport abstract class NamedFragment extends Fragment {\n    /**\n     *  The name of the fragment.\n     */\n    readonly name!: string;\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, type: FragmentType, name: string, inputs: ReadonlyArray<ParamType>) {\n        super(guard, type, inputs);\n        assertArgument(typeof(name) === \"string\" && name.match(regexId),\n            \"invalid identifier\", \"name\", name);\n        inputs = Object.freeze(inputs.slice());\n        defineProperties<NamedFragment>(this, { name });\n    }\n}\n\nfunction joinParams(format: FormatType, params: ReadonlyArray<ParamType>): string { \n    return \"(\" + params.map((p) => p.format(format)).join((format === \"full\") ? \", \": \",\") + \")\";\n}\n\n/**\n *  A Fragment which represents a //Custom Error//.\n */\nexport class ErrorFragment extends NamedFragment {\n    /**\n     *  @private\n     */\n    constructor(guard: any, name: string, inputs: ReadonlyArray<ParamType>) {\n        super(guard, \"error\", name, inputs);\n        Object.defineProperty(this, internal, { value: ErrorFragmentInternal });\n    }\n\n    /**\n     *  The Custom Error selector.\n     */\n    get selector(): string {\n        return id(this.format(\"sighash\")).substring(0, 10);\n    }\n\n    format(format?: FormatType): string {\n        if (format == null) { format = \"sighash\"; }\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"error\",\n                name: this.name,\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),\n            });\n        }\n\n        const result = [ ];\n        if (format !== \"sighash\") { result.push(\"error\"); }\n        result.push(this.name + joinParams(format, this.inputs));\n        return result.join(\" \");\n    }\n\n    static from(obj: any): ErrorFragment {\n        if (ErrorFragment.isFragment(obj)) { return obj; }\n\n        if (typeof(obj) === \"string\") {\n            return ErrorFragment.from(lex(obj));\n\n        } else if (obj instanceof TokenString) {\n            const name = consumeName(\"error\", obj);\n            const inputs = consumeParams(obj);\n            consumeEoi(obj);\n\n            return new ErrorFragment(_guard, name, inputs);\n        }\n\n        return new ErrorFragment(_guard, obj.name,\n            obj.inputs ? obj.inputs.map(ParamType.from): [ ]);\n    }\n\n    static isFragment(value: any): value is ErrorFragment {\n        return (value && value[internal] === ErrorFragmentInternal);\n    }\n}\n\n/**\n *  A Fragment which represents an Event.\n */\nexport class EventFragment extends NamedFragment {\n    readonly anonymous!: boolean;\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, name: string, inputs: ReadonlyArray<ParamType>, anonymous: boolean) {\n        super(guard, \"event\", name, inputs);\n        Object.defineProperty(this, internal, { value: EventFragmentInternal });\n        defineProperties<EventFragment>(this, { anonymous });\n    }\n\n    /**\n     *  The Event topic hash.\n     */\n    get topicHash(): string {\n        return id(this.format(\"sighash\"));\n    }\n\n    format(format?: FormatType): string {\n        if (format == null) { format = \"sighash\"; }\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"event\",\n                anonymous: this.anonymous,\n                name: this.name,\n                inputs: this.inputs.map((i) => JSON.parse(i.format(format)))\n            });\n        }\n\n        const result = [ ];\n        if (format !== \"sighash\") { result.push(\"event\"); }\n        result.push(this.name + joinParams(format, this.inputs));\n        if (format !== \"sighash\" && this.anonymous) { result.push(\"anonymous\"); }\n        return result.join(\" \");\n    }\n\n    static getTopicHash(name: string, params?: Array<any>): string {\n        params = (params || []).map((p) => ParamType.from(p));\n        const fragment = new EventFragment(_guard, name, params, false);\n        return fragment.topicHash;\n    }\n\n    static from(obj: any): EventFragment {\n        if (EventFragment.isFragment(obj)) { return obj; }\n\n        if (typeof(obj) === \"string\") {\n            return EventFragment.from(lex(obj));\n\n        } else if (obj instanceof TokenString) {\n            const name = consumeName(\"event\", obj);\n            const inputs = consumeParams(obj, true);\n            const anonymous = !!consumeKeywords(obj, setify([ \"anonymous\" ])).has(\"anonymous\");\n            consumeEoi(obj);\n\n            return new EventFragment(_guard, name, inputs, anonymous);\n        }\n\n        return new EventFragment(_guard, obj.name,\n            obj.inputs ? obj.inputs.map((p: any) => ParamType.from(p, true)): [ ], !!obj.anonymous);\n    }\n\n    static isFragment(value: any): value is EventFragment {\n        return (value && value[internal] === EventFragmentInternal);\n    }\n}\n\n/**\n *  A Fragment which represents a constructor.\n */\nexport class ConstructorFragment extends Fragment {\n    readonly payable!: boolean;\n    readonly gas!: null | bigint;\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, type: FragmentType, inputs: ReadonlyArray<ParamType>, payable: boolean, gas: null | bigint) {\n        super(guard, type, inputs);\n        Object.defineProperty(this, internal, { value: ConstructorFragmentInternal });\n        defineProperties<ConstructorFragment>(this, { payable, gas });\n    }\n\n    format(format?: FormatType): string {\n        assert(format != null && format !== \"sighash\", \"cannot format a constructor for sighash\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"format(sighash)\" });\n\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"constructor\",\n                stateMutability: (this.payable ? \"payable\": \"undefined\"),\n                payable: this.payable,\n                gas: ((this.gas != null) ? this.gas: undefined),\n                inputs: this.inputs.map((i) => JSON.parse(i.format(format)))\n            });\n        }\n\n        const result = [ `constructor${ joinParams(format, this.inputs) }` ];\n        result.push((this.payable) ? \"payable\": \"nonpayable\");\n        if (this.gas != null) { result.push(`@${ this.gas.toString() }`); }\n        return result.join(\" \");\n    }\n\n    static from(obj: any): ConstructorFragment {\n        if (ConstructorFragment.isFragment(obj)) { return obj; }\n\n        if (typeof(obj) === \"string\") {\n            return ConstructorFragment.from(lex(obj));\n\n        } else if (obj instanceof TokenString) {\n            consumeKeywords(obj, setify([ \"constructor\" ]));\n            const inputs = consumeParams(obj);\n            const payable = !!consumeKeywords(obj, setify([ \"payable\" ])).has(\"payable\");\n            const gas = consumeGas(obj);\n            consumeEoi(obj);\n\n            return new ConstructorFragment(_guard, \"constructor\", inputs, payable, gas);\n        }\n\n        return new ConstructorFragment(_guard, \"constructor\",\n            obj.inputs ? obj.inputs.map(ParamType.from): [ ],\n            !!obj.payable, (obj.gas != null) ? obj.gas: null);\n    }\n\n    static isFragment(value: any): value is ConstructorFragment {\n        return (value && value[internal] === ConstructorFragmentInternal);\n    }\n}\n\n/**\n *  A Fragment which represents a method.\n */\nexport class FallbackFragment extends Fragment {\n\n    /**\n     *  If the function can be sent value during invocation.\n     */\n    readonly payable!: boolean;\n\n    constructor(guard: any, inputs: ReadonlyArray<ParamType>, payable: boolean) {\n        super(guard, \"fallback\", inputs);\n        Object.defineProperty(this, internal, { value: FallbackFragmentInternal });\n        defineProperties<FallbackFragment>(this, { payable });\n    }\n\n    format(format?: FormatType): string {\n        const type = ((this.inputs.length === 0) ? \"receive\": \"fallback\");\n\n        if (format === \"json\") {\n            const stateMutability = (this.payable ? \"payable\": \"nonpayable\");\n            return JSON.stringify({ type, stateMutability });\n        }\n\n        return `${ type }()${ this.payable ? \" payable\": \"\" }`;\n    }\n\n    static from(obj: any): FallbackFragment {\n        if (FallbackFragment.isFragment(obj)) { return obj; }\n\n        if (typeof(obj) === \"string\") {\n             return FallbackFragment.from(lex(obj));\n\n        } else if (obj instanceof TokenString) {\n            const errorObj = obj.toString();\n\n            const topIsValid = obj.peekKeyword(setify([ \"fallback\", \"receive\" ]));\n            assertArgument(topIsValid, \"type must be fallback or receive\", \"obj\", errorObj);\n\n            const type = obj.popKeyword(setify([ \"fallback\", \"receive\" ]));\n\n            // receive()\n            if (type === \"receive\") {\n                const inputs = consumeParams(obj);\n                assertArgument(inputs.length === 0, `receive cannot have arguments`, \"obj.inputs\", inputs);\n                consumeKeywords(obj, setify([ \"payable\" ]));\n                consumeEoi(obj);\n                return new FallbackFragment(_guard, [ ], true);\n            }\n\n            // fallback() [payable]\n            // fallback(bytes) [payable] returns (bytes)\n            let inputs = consumeParams(obj);\n            if (inputs.length) {\n                assertArgument(inputs.length === 1 && inputs[0].type === \"bytes\",\n                    \"invalid fallback inputs\", \"obj.inputs\",\n                    inputs.map((i) => i.format(\"minimal\")).join(\", \"));\n            } else {\n                inputs = [ ParamType.from(\"bytes\") ];\n            }\n\n            const mutability = consumeMutability(obj);\n            assertArgument(mutability === \"nonpayable\" || mutability === \"payable\", \"fallback cannot be constants\", \"obj.stateMutability\", mutability);\n\n            if (consumeKeywords(obj, setify([ \"returns\" ])).has(\"returns\")) {\n                const outputs = consumeParams(obj);\n                assertArgument(outputs.length === 1 && outputs[0].type === \"bytes\",\n                    \"invalid fallback outputs\", \"obj.outputs\",\n                    outputs.map((i) => i.format(\"minimal\")).join(\", \"));\n            }\n\n            consumeEoi(obj);\n\n            return new FallbackFragment(_guard, inputs, mutability === \"payable\");\n        }\n\n        if (obj.type === \"receive\") {\n            return new FallbackFragment(_guard, [ ], true);\n        }\n\n        if (obj.type === \"fallback\") {\n            const inputs = [ ParamType.from(\"bytes\") ];\n            const payable = (obj.stateMutability === \"payable\");\n            return new FallbackFragment(_guard, inputs, payable);\n        }\n\n        assertArgument(false, \"invalid fallback description\", \"obj\", obj);\n    }\n\n    static isFragment(value: any): value is FallbackFragment {\n        return (value && value[internal] === FallbackFragmentInternal);\n    }\n}\n\n\n/**\n *  A Fragment which represents a method.\n */\nexport class FunctionFragment extends NamedFragment {\n    /**\n     *  If the function is constant (e.g. ``pure`` or ``view`` functions).\n     */\n    readonly constant!: boolean;\n\n    /**\n     *  The returned types for the result of calling this function.\n     */\n    readonly outputs!: ReadonlyArray<ParamType>;\n\n    /**\n     *  The state mutability (e.g. ``payable``, ``nonpayable``, ``view``\n     *  or ``pure``)\n     */\n    readonly stateMutability!: \"payable\" | \"nonpayable\" | \"view\" | \"pure\";\n\n    /**\n     *  If the function can be sent value during invocation.\n     */\n    readonly payable!: boolean;\n\n    /**\n     *  The amount of gas to send when calling this function\n     */\n    readonly gas!: null | bigint;\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, name: string, stateMutability: \"payable\" | \"nonpayable\" | \"view\" | \"pure\", inputs: ReadonlyArray<ParamType>, outputs: ReadonlyArray<ParamType>, gas: null | bigint) {\n        super(guard, \"function\", name, inputs);\n        Object.defineProperty(this, internal, { value: FunctionFragmentInternal });\n        outputs = Object.freeze(outputs.slice());\n        const constant = (stateMutability === \"view\" || stateMutability === \"pure\");\n        const payable = (stateMutability === \"payable\");\n        defineProperties<FunctionFragment>(this, { constant, gas, outputs, payable, stateMutability });\n    }\n\n    /**\n     *  The Function selector.\n     */\n    get selector(): string {\n        return id(this.format(\"sighash\")).substring(0, 10);\n    }\n\n    format(format?: FormatType): string {\n        if (format == null) { format = \"sighash\"; }\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"function\",\n                name: this.name,\n                constant: this.constant,\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability: undefined),\n                payable: this.payable,\n                gas: ((this.gas != null) ? this.gas: undefined),\n                inputs: this.inputs.map((i) => JSON.parse(i.format(format))),\n                outputs: this.outputs.map((o) => JSON.parse(o.format(format))),\n            });\n        }\n\n        const result = [];\n\n        if (format !== \"sighash\") { result.push(\"function\"); }\n\n        result.push(this.name + joinParams(format, this.inputs));\n\n        if (format !== \"sighash\") {\n            if (this.stateMutability !== \"nonpayable\") {\n                result.push(this.stateMutability);\n            }\n\n            if (this.outputs && this.outputs.length) {\n                result.push(\"returns\");\n                result.push(joinParams(format, this.outputs));\n            }\n\n            if (this.gas != null) { result.push(`@${ this.gas.toString() }`); }\n        }\n        return result.join(\" \");\n    }\n\n    static getSelector(name: string, params?: Array<any>): string {\n        params = (params || []).map((p) => ParamType.from(p));\n        const fragment = new FunctionFragment(_guard, name, \"view\", params, [ ], null);\n        return fragment.selector;\n    }\n\n    static from(obj: any): FunctionFragment {\n        if (FunctionFragment.isFragment(obj)) { return obj; }\n\n        if (typeof(obj) === \"string\") {\n             return FunctionFragment.from(lex(obj));\n\n        } else if (obj instanceof TokenString) {\n            const name = consumeName(\"function\", obj);\n            const inputs = consumeParams(obj);\n            const mutability = consumeMutability(obj);\n\n            let outputs: Array<ParamType> = [ ];\n            if (consumeKeywords(obj, setify([ \"returns\" ])).has(\"returns\")) {\n                outputs = consumeParams(obj);\n            }\n\n            const gas = consumeGas(obj);\n\n            consumeEoi(obj);\n\n            return new FunctionFragment(_guard, name, mutability, inputs, outputs, gas);\n        }\n\n        // @TODO: verifyState for stateMutability\n\n        return new FunctionFragment(_guard, obj.name, obj.stateMutability,\n             obj.inputs ? obj.inputs.map(ParamType.from): [ ],\n             obj.outputs ? obj.outputs.map(ParamType.from): [ ],\n             (obj.gas != null) ? obj.gas: null);\n    }\n\n    static isFragment(value: any): value is FunctionFragment {\n        return (value && value[internal] === FunctionFragmentInternal);\n    }\n}\n\n/**\n *  A Fragment which represents a structure.\n */\nexport class StructFragment extends NamedFragment {\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, name: string, inputs: ReadonlyArray<ParamType>) {\n        super(guard, \"struct\", name, inputs);\n        Object.defineProperty(this, internal, { value: StructFragmentInternal });\n    }\n\n    format(): string {\n        throw new Error(\"@TODO\");\n    }\n\n    static from(obj: any): StructFragment {\n        if (typeof(obj) === \"string\") {\n            return StructFragment.from(lex(obj));\n\n        } else if (obj instanceof TokenString) {\n            const name = consumeName(\"struct\", obj);\n            const inputs = consumeParams(obj);\n            consumeEoi(obj);\n            return new StructFragment(_guard, name, inputs);\n        }\n\n        return new StructFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from): [ ]);\n    }\n\n    static isFragment(value: any): value is FunctionFragment {\n        return (value && value[internal] === StructFragmentInternal);\n    }\n}\n\n","/**\n *  When sending values to or receiving values from a [[Contract]], the\n *  data is generally encoded using the [ABI standard](link-solc-abi).\n *\n *  The AbiCoder provides a utility to encode values to ABI data and\n *  decode values from ABI data.\n *\n *  Most of the time, developers should favour the [[Contract]] class,\n *  which further abstracts a lot of the finer details of ABI data.\n *\n *  @_section api/abi/abi-coder:ABI Encoding\n */\n\n// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\n\nimport { assertArgumentCount, assertArgument } from \"../utils/index.js\";\n\nimport { Coder, Reader, Result, Writer } from \"./coders/abstract-coder.js\";\nimport { AddressCoder } from \"./coders/address.js\";\nimport { ArrayCoder } from \"./coders/array.js\";\nimport { BooleanCoder } from \"./coders/boolean.js\";\nimport { BytesCoder } from \"./coders/bytes.js\";\nimport { FixedBytesCoder } from \"./coders/fixed-bytes.js\";\nimport { NullCoder } from \"./coders/null.js\";\nimport { NumberCoder } from \"./coders/number.js\";\nimport { StringCoder } from \"./coders/string.js\";\nimport { TupleCoder } from \"./coders/tuple.js\";\nimport { ParamType } from \"./fragments.js\";\n\nimport { getAddress } from \"../address/index.js\";\nimport { getBytes, hexlify, makeError } from \"../utils/index.js\";\n\nimport type {\n    BytesLike,\n    CallExceptionAction, CallExceptionError, CallExceptionTransaction\n} from \"../utils/index.js\";\n\n// https://docs.soliditylang.org/en/v0.8.17/control-structures.html\nconst PanicReasons: Map<number, string> = new Map();\nPanicReasons.set(0x00, \"GENERIC_PANIC\");\nPanicReasons.set(0x01, \"ASSERT_FALSE\");\nPanicReasons.set(0x11, \"OVERFLOW\");\nPanicReasons.set(0x12, \"DIVIDE_BY_ZERO\");\nPanicReasons.set(0x21, \"ENUM_RANGE_ERROR\");\nPanicReasons.set(0x22, \"BAD_STORAGE_DATA\");\nPanicReasons.set(0x31, \"STACK_UNDERFLOW\");\nPanicReasons.set(0x32, \"ARRAY_RANGE_ERROR\");\nPanicReasons.set(0x41, \"OUT_OF_MEMORY\");\nPanicReasons.set(0x51, \"UNINITIALIZED_FUNCTION_CALL\");\n\nconst paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\nconst paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\n\n\nlet defaultCoder: null | AbiCoder = null;\n\n\nfunction getBuiltinCallException(action: CallExceptionAction, tx: { to?: null | string, from?: null | string, data?: string }, data: null | BytesLike, abiCoder: AbiCoder): CallExceptionError {\n    let message = \"missing revert data\";\n\n    let reason: null | string = null;\n    const invocation = null;\n    let revert: null | { signature: string, name: string, args: Array<any> } = null;\n\n    if (data) {\n        message = \"execution reverted\";\n\n        const bytes = getBytes(data);\n        data = hexlify(data);\n\n        if (bytes.length === 0) {\n            message += \" (no data present; likely require(false) occurred\";\n            reason = \"require(false)\";\n\n        } else if (bytes.length % 32 !== 4) {\n            message += \" (could not decode reason; invalid data length)\";\n\n        } else if (hexlify(bytes.slice(0, 4)) === \"0x08c379a0\") {\n            // Error(string)\n            try {\n                reason = abiCoder.decode([ \"string\" ], bytes.slice(4))[0]\n                revert = {\n                    signature: \"Error(string)\",\n                    name: \"Error\",\n                    args: [ reason ]\n                };\n                message += `: ${ JSON.stringify(reason) }`;\n\n            } catch (error) {\n                message += \" (could not decode reason; invalid string data)\";\n            }\n\n        } else if (hexlify(bytes.slice(0, 4)) === \"0x4e487b71\") {\n            // Panic(uint256)\n            try {\n                const code = Number(abiCoder.decode([ \"uint256\" ], bytes.slice(4))[0]);\n                revert = {\n                    signature: \"Panic(uint256)\",\n                    name: \"Panic\",\n                    args: [ code ]\n                };\n                reason = `Panic due to ${ PanicReasons.get(code) || \"UNKNOWN\" }(${ code })`;\n                message += `: ${ reason }`;\n            } catch (error) {\n                message += \" (could not decode panic code)\";\n            }\n        } else {\n            message += \" (unknown custom error)\";\n        }\n    }\n\n    const transaction: CallExceptionTransaction = {\n        to: (tx.to ? getAddress(tx.to): null),\n        data: (tx.data || \"0x\")\n    };\n    if (tx.from) { transaction.from = getAddress(tx.from); }\n\n    return makeError(message, \"CALL_EXCEPTION\", {\n        action, data, reason, transaction, invocation, revert\n    });\n}\n\n/**\n  * About AbiCoder\n  */\nexport class AbiCoder {\n\n    #getCoder(param: ParamType): Coder {\n        if (param.isArray()) {\n            return new ArrayCoder(this.#getCoder(param.arrayChildren), param.arrayLength, param.name);\n        }\n\n        if (param.isTuple()) {\n            return new TupleCoder(param.components.map((c) => this.#getCoder(c)), param.name);\n        }\n\n        switch (param.baseType) {\n            case \"address\":\n                return new AddressCoder(param.name);\n            case \"bool\":\n                return new BooleanCoder(param.name);\n            case \"string\":\n                return new StringCoder(param.name);\n            case \"bytes\":\n                return new BytesCoder(param.name);\n            case \"\":\n                return new NullCoder(param.name);\n        }\n\n        // u?int[0-9]*\n        let match = param.type.match(paramTypeNumber);\n        if (match) {\n            let size = parseInt(match[2] || \"256\");\n            assertArgument(size !== 0 && size <= 256 && (size % 8) === 0,\n                \"invalid \" + match[1] + \" bit length\", \"param\", param);\n            return new NumberCoder(size / 8, (match[1] === \"int\"), param.name);\n        }\n\n        // bytes[0-9]+\n        match = param.type.match(paramTypeBytes);\n        if (match) {\n            let size = parseInt(match[1]);\n            assertArgument(size !== 0 && size <= 32, \"invalid bytes length\", \"param\", param);\n            return new FixedBytesCoder(size, param.name);\n        }\n\n        assertArgument(false, \"invalid type\", \"type\", param.type);\n    }\n\n    /**\n     *  Get the default values for the given %%types%%.\n     *\n     *  For example, a ``uint`` is by default ``0`` and ``bool``\n     *  is by default ``false``.\n     */\n    getDefaultValue(types: ReadonlyArray<string | ParamType>): Result {\n        const coders: Array<Coder> = types.map((type) => this.#getCoder(ParamType.from(type)));\n        const coder = new TupleCoder(coders, \"_\");\n        return coder.defaultValue();\n    }\n\n    /**\n     *  Encode the %%values%% as the %%types%% into ABI data.\n     *\n     *  @returns DataHexstring\n     */\n    encode(types: ReadonlyArray<string | ParamType>, values: ReadonlyArray<any>): string {\n        assertArgumentCount(values.length, types.length, \"types/values length mismatch\");\n\n        const coders = types.map((type) => this.#getCoder(ParamType.from(type)));\n        const coder = (new TupleCoder(coders, \"_\"));\n\n        const writer = new Writer();\n        coder.encode(writer, values);\n        return writer.data;\n    }\n\n    /**\n     *  Decode the ABI %%data%% as the %%types%% into values.\n     *\n     *  If %%loose%% decoding is enabled, then strict padding is\n     *  not enforced. Some older versions of Solidity incorrectly\n     *  padded event data emitted from ``external`` functions.\n     */\n    decode(types: ReadonlyArray<string | ParamType>, data: BytesLike, loose?: boolean): Result {\n        const coders: Array<Coder> = types.map((type) => this.#getCoder(ParamType.from(type)));\n        const coder = new TupleCoder(coders, \"_\");\n        return coder.decode(new Reader(data, loose));\n    }\n\n    /**\n     *  Returns the shared singleton instance of a default [[AbiCoder]].\n     *\n     *  On the first call, the instance is created internally.\n     */\n    static defaultAbiCoder(): AbiCoder {\n        if (defaultCoder == null) {\n            defaultCoder = new AbiCoder();\n        }\n        return defaultCoder;\n    }\n\n    /**\n     *  Returns an ethers-compatible [[CallExceptionError]] Error for the given\n     *  result %%data%% for the [[CallExceptionAction]] %%action%% against\n     *  the Transaction %%tx%%.\n     */\n    static getBuiltinCallException(action: CallExceptionAction, tx: { to?: null | string, from?: null | string, data?: string }, data: null | BytesLike): CallExceptionError {\n        return getBuiltinCallException(action, tx, data, AbiCoder.defaultAbiCoder());\n    }\n}\n","/**\n *  About Interface\n *\n *  @_subsection api/abi:Interfaces  [interfaces]\n */\n\nimport { keccak256 } from \"../crypto/index.js\"\nimport { id } from \"../hash/index.js\"\nimport {\n    concat, dataSlice, getBigInt, getBytes, getBytesCopy,\n    hexlify, zeroPadValue, isHexString, defineProperties, assertArgument, toBeHex,\n    assert\n} from \"../utils/index.js\";\n\nimport { AbiCoder } from \"./abi-coder.js\";\nimport { checkResultErrors, Result } from \"./coders/abstract-coder.js\";\nimport {\n    ConstructorFragment, ErrorFragment, EventFragment, FallbackFragment,\n    Fragment, FunctionFragment, ParamType\n} from \"./fragments.js\";\nimport { Typed } from \"./typed.js\";\n\nimport type { BigNumberish, BytesLike, CallExceptionError, CallExceptionTransaction } from \"../utils/index.js\";\n\nimport type { JsonFragment } from \"./fragments.js\";\n\n\nexport { checkResultErrors, Result };\n\nexport class LogDescription {\n    readonly fragment!: EventFragment;\n    readonly name!: string;\n    readonly signature!: string;\n    readonly topic!: string;\n    readonly args!: Result\n\n    constructor(fragment: EventFragment, topic: string, args: Result) {\n        const name = fragment.name, signature = fragment.format();\n        defineProperties<LogDescription>(this, {\n            fragment, name, signature, topic, args\n        });\n    }\n}\n\nexport class TransactionDescription {\n    readonly fragment!: FunctionFragment;\n    readonly name!: string;\n    readonly args!: Result;\n    readonly signature!: string;\n    readonly selector!: string;\n    readonly value!: bigint;\n\n    constructor(fragment: FunctionFragment, selector: string, args: Result, value: bigint) {\n        const name = fragment.name, signature = fragment.format();\n        defineProperties<TransactionDescription>(this, {\n            fragment, name, args, signature, selector, value\n        });\n    }\n}\n\nexport class ErrorDescription {\n    readonly fragment!: ErrorFragment;\n    readonly name!: string;\n    readonly args!: Result;\n    readonly signature!: string;\n    readonly selector!: string;\n\n    constructor(fragment: ErrorFragment, selector: string, args: Result) {\n        const name = fragment.name, signature = fragment.format();\n        defineProperties<ErrorDescription>(this, {\n            fragment, name, args, signature, selector\n        });\n    }\n}\n\nexport class Indexed {\n    readonly hash!: null | string;\n    readonly _isIndexed!: boolean;\n\n    static isIndexed(value: any): value is Indexed {\n        return !!(value && value._isIndexed);\n    }\n\n    constructor(hash: null | string) {\n        defineProperties<Indexed>(this, { hash, _isIndexed: true })\n    }\n}\n\ntype ErrorInfo = {\n    signature: string,\n    inputs: Array<string>,\n    name: string,\n    reason: (...args: Array<any>) => string;\n};\n\n// https://docs.soliditylang.org/en/v0.8.13/control-structures.html?highlight=panic#panic-via-assert-and-error-via-require\nconst PanicReasons: Record<string, string> = {\n    \"0\": \"generic panic\",\n    \"1\": \"assert(false)\",\n    \"17\": \"arithmetic overflow\",\n    \"18\": \"division or modulo by zero\",\n    \"33\": \"enum overflow\",\n    \"34\": \"invalid encoded storage byte array accessed\",\n    \"49\": \"out-of-bounds array access; popping on an empty array\",\n    \"50\": \"out-of-bounds access of an array or bytesN\",\n    \"65\": \"out of memory\",\n    \"81\": \"uninitialized function\",\n}\n\nconst BuiltinErrors: Record<string, ErrorInfo> = {\n    \"0x08c379a0\": {\n        signature: \"Error(string)\",\n        name: \"Error\",\n        inputs: [ \"string\" ],\n        reason: (message: string) => {\n            return `reverted with reason string ${ JSON.stringify(message) }`;\n        }\n    },\n    \"0x4e487b71\": {\n        signature: \"Panic(uint256)\",\n        name: \"Panic\",\n        inputs: [ \"uint256\" ],\n        reason: (code: bigint) => {\n            let reason = \"unknown panic code\";\n            if (code >= 0 && code <= 0xff && PanicReasons[code.toString()]) {\n                reason = PanicReasons[code.toString()];\n            }\n            return `reverted with panic code 0x${ code.toString(16) } (${ reason })`;\n        }\n    }\n}\n\n/*\nfunction wrapAccessError(property: string, error: Error): Error {\n    const wrap = new Error(`deferred error during ABI decoding triggered accessing ${ property }`);\n    (<any>wrap).error = error;\n    return wrap;\n}\n*/\n/*\nfunction checkNames(fragment: Fragment, type: \"input\" | \"output\", params: Array<ParamType>): void {\n    params.reduce((accum, param) => {\n        if (param.name) {\n            if (accum[param.name]) {\n                logger.throwArgumentError(`duplicate ${ type } parameter ${ JSON.stringify(param.name) } in ${ fragment.format(\"full\") }`, \"fragment\", fragment);\n            }\n            accum[param.name] = true;\n        }\n        return accum;\n    }, <{ [ name: string ]: boolean }>{ });\n}\n*/\n\n/**\n *  @TODO\n */\nexport type InterfaceAbi = string | ReadonlyArray<Fragment | JsonFragment | string>;\n\n/**\n *  An Interface abstracts many of the low-level details for\n *  encoding and decoding the data on the blockchain.\n *\n *  An ABI provides information on how to encode data to send to\n *  a Contract, how to decode the results and events and how to\n *  interpret revert errors.\n *\n *  The ABI can be specified by [any supported format](InterfaceAbi).\n */\nexport class Interface {\n\n    /**\n     *  All the Contract ABI members (i.e. methods, events, errors, etc).\n     */\n    readonly fragments!: ReadonlyArray<Fragment>;\n\n    /**\n     *  The Contract constructor.\n     */\n    readonly deploy!: ConstructorFragment;\n\n    /**\n     *  The Fallback method, if any.\n     */\n    readonly fallback!: null | FallbackFragment;\n\n    /**\n     *  If receiving ether is supported.\n     */\n    readonly receive!: boolean;\n\n    #errors: Map<string, ErrorFragment>;\n    #events: Map<string, EventFragment>;\n    #functions: Map<string, FunctionFragment>;\n//    #structs: Map<string, StructFragment>;\n\n    #abiCoder: AbiCoder;\n\n    /**\n     *  Create a new Interface for the %%fragments%%.\n     */\n    constructor(fragments: InterfaceAbi) {\n        let abi: ReadonlyArray<Fragment | JsonFragment | string> = [ ];\n        if (typeof(fragments) === \"string\") {\n            abi = JSON.parse(fragments);\n        } else {\n            abi = fragments;\n        }\n\n        this.#functions = new Map();\n        this.#errors = new Map();\n        this.#events = new Map();\n//        this.#structs = new Map();\n\n\n        const frags: Array<Fragment> = [ ];\n        for (const a of abi) {\n            try {\n                frags.push(Fragment.from(a));\n            } catch (error) {\n                console.log(\"EE\", error);\n            }\n        }\n\n        defineProperties<Interface>(this, {\n            fragments: Object.freeze(frags)\n        });\n\n        let fallback: null | FallbackFragment = null;\n        let receive = false;\n\n        this.#abiCoder = this.getAbiCoder();\n\n        // Add all fragments by their signature\n        this.fragments.forEach((fragment, index) => {\n            let bucket: Map<string, Fragment>;\n            switch (fragment.type) {\n                case \"constructor\":\n                    if (this.deploy) {\n                        console.log(\"duplicate definition - constructor\");\n                        return;\n                    }\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    defineProperties<Interface>(this, { deploy: <ConstructorFragment>fragment });\n                    return;\n\n                case \"fallback\":\n                    if (fragment.inputs.length === 0) {\n                        receive = true;\n                    } else {\n                        assertArgument(!fallback || (<FallbackFragment>fragment).payable !== fallback.payable,\n                            \"conflicting fallback fragments\", `fragments[${ index }]`, fragment);\n                        fallback = <FallbackFragment>fragment;\n                        receive = fallback.payable;\n                    }\n                    return;\n\n                case \"function\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    //checkNames(fragment, \"output\", (<FunctionFragment>fragment).outputs);\n                    bucket = this.#functions;\n                    break;\n\n                case \"event\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    bucket = this.#events;\n                    break;\n\n                case \"error\":\n                    bucket = this.#errors;\n                    break;\n\n                default:\n                    return;\n            }\n\n            // Two identical entries; ignore it\n            const signature = fragment.format();\n            if (bucket.has(signature)) { return; }\n\n            bucket.set(signature, fragment);\n        });\n\n        // If we do not have a constructor add a default\n        if (!this.deploy) {\n            defineProperties<Interface>(this, {\n                deploy: ConstructorFragment.from(\"constructor()\")\n            });\n        }\n\n        defineProperties<Interface>(this, { fallback, receive });\n    }\n\n    /**\n     *  Returns the entire Human-Readable ABI, as an array of\n     *  signatures, optionally as %%minimal%% strings, which\n     *  removes parameter names and unneceesary spaces.\n     */\n    format(minimal?: boolean): Array<string> {\n        const format = (minimal ? \"minimal\": \"full\");\n        const abi = this.fragments.map((f) => f.format(format));\n        return abi;\n    }\n\n    /**\n     *  Return the JSON-encoded ABI. This is the format Solidiy\n     *  returns.\n     */\n    formatJson(): string {\n        const abi = this.fragments.map((f) => f.format(\"json\"));\n\n        // We need to re-bundle the JSON fragments a bit\n        return JSON.stringify(abi.map((j) => JSON.parse(j)));\n    }\n\n    /**\n     *  The ABI coder that will be used to encode and decode binary\n     *  data.\n     */\n    getAbiCoder(): AbiCoder {\n        return AbiCoder.defaultAbiCoder();\n    }\n\n    // Find a function definition by any means necessary (unless it is ambiguous)\n    #getFunction(key: string, values: null | Array<any | Typed>, forceUnique: boolean): null | FunctionFragment {\n\n        // Selector\n        if (isHexString(key)) {\n            const selector = key.toLowerCase();\n            for (const fragment of this.#functions.values()) {\n                if (selector === fragment.selector) { return fragment; }\n            }\n            return null;\n        }\n\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (key.indexOf(\"(\") === -1) {\n            const matching: Array<FunctionFragment> = [ ];\n            for (const [ name, fragment ] of this.#functions) {\n                if (name.split(\"(\"/* fix:) */)[0] === key) { matching.push(fragment); }\n            }\n\n            if (values) {\n                const lastValue = (values.length > 0) ? values[values.length - 1]: null;\n\n                let valueLength = values.length;\n                let allowOptions = true;\n                if (Typed.isTyped(lastValue) && lastValue.type === \"overrides\") {\n                    allowOptions = false;\n                    valueLength--;\n                }\n\n                // Remove all matches that don't have a compatible length. The args\n                // may contain an overrides, so the match may have n or n - 1 parameters\n                for (let i = matching.length - 1; i >= 0; i--) {\n                    const inputs = matching[i].inputs.length;\n                    if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {\n                        matching.splice(i, 1);\n                    }\n                }\n\n                // Remove all matches that don't match the Typed signature\n                for (let i = matching.length - 1; i >= 0; i--) {\n                    const inputs = matching[i].inputs;\n                    for (let j = 0; j < values.length; j++) {\n                        // Not a typed value\n                        if (!Typed.isTyped(values[j])) { continue; }\n\n                        // We are past the inputs\n                        if (j >= inputs.length) {\n                            if (values[j].type === \"overrides\") { continue; }\n                            matching.splice(i, 1);\n                            break;\n                        }\n\n                        // Make sure the value type matches the input type\n                        if (values[j].type !== inputs[j].baseType) {\n                            matching.splice(i, 1);\n                            break;\n                        }\n                    }\n                }\n            }\n\n            // We found a single matching signature with an overrides, but the\n            // last value is something that cannot possibly be an options\n            if (matching.length === 1 && values && values.length !== matching[0].inputs.length) {\n                const lastArg = values[values.length - 1];\n                if (lastArg == null || Array.isArray(lastArg) || typeof(lastArg) !== \"object\") {\n                    matching.splice(0, 1);\n                }\n            }\n\n            if (matching.length === 0) { return null; }\n\n            if (matching.length > 1 && forceUnique) {\n                const matchStr = matching.map((m) => JSON.stringify(m.format())).join(\", \");\n                assertArgument(false, `ambiguous function description (i.e. matches ${ matchStr })`, \"key\", key);\n            }\n\n            return matching[0];\n        }\n\n        // Normalize the signature and lookup the function\n        const result = this.#functions.get(FunctionFragment.from(key).format());\n        if (result) { return result; }\n\n        return null;\n    }\n\n    /**\n     *  Get the function name for %%key%%, which may be a function selector,\n     *  function name or function signature that belongs to the ABI.\n     */\n    getFunctionName(key: string): string {\n        const fragment = this.#getFunction(key, null, false);\n        assertArgument(fragment, \"no matching function\", \"key\", key);\n        return fragment.name;\n    }\n\n    /**\n     *  Get the [[FunctionFragment]] for %%key%%, which may be a function\n     *  selector, function name or function signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple functions match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single function in\n     *  the ABI, this will throw.\n     */\n    getFunction(key: string, values?: Array<any | Typed>): null | FunctionFragment {\n        return this.#getFunction(key, values || null, true);\n    }\n\n    /**\n     *  Iterate over all functions, calling %%callback%%, sorted by their name.\n     */\n    forEachFunction(callback: (func: FunctionFragment, index: number) => void): void {\n        const names = Array.from(this.#functions.keys());\n        names.sort((a, b) => a.localeCompare(b));\n        for (let i = 0; i < names.length; i++) {\n            const name = names[i];\n            callback(<FunctionFragment>(this.#functions.get(name)), i);\n        }\n    }\n\n\n    // Find an event definition by any means necessary (unless it is ambiguous)\n    #getEvent(key: string, values: null | Array<null | any | Typed>, forceUnique: boolean): null | EventFragment {\n\n        // EventTopic\n        if (isHexString(key)) {\n            const eventTopic = key.toLowerCase();\n            for (const fragment of this.#events.values()) {\n                if (eventTopic === fragment.topicHash) { return fragment; }\n            }\n            return null;\n        }\n\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (key.indexOf(\"(\") === -1) {\n            const matching = [ ];\n            for (const [ name, fragment ] of this.#events) {\n                if (name.split(\"(\"/* fix:) */)[0] === key) { matching.push(fragment); }\n            }\n\n            if (values) {\n                // Remove all matches that don't have a compatible length.\n                for (let i = matching.length - 1; i >= 0; i--) {\n                    if (matching[i].inputs.length < values.length) {\n                        matching.splice(i, 1);\n                    }\n                }\n\n                // Remove all matches that don't match the Typed signature\n                for (let i = matching.length - 1; i >= 0; i--) {\n                    const inputs = matching[i].inputs;\n                    for (let j = 0; j < values.length; j++) {\n                        // Not a typed value\n                        if (!Typed.isTyped(values[j])) { continue; }\n\n                        // Make sure the value type matches the input type\n                        if (values[j].type !== inputs[j].baseType) {\n                            matching.splice(i, 1);\n                            break;\n                        }\n                    }\n                }\n            }\n\n            if (matching.length === 0) { return null; }\n\n            if (matching.length > 1 && forceUnique) {\n                const matchStr = matching.map((m) => JSON.stringify(m.format())).join(\", \");\n                assertArgument(false, `ambiguous event description (i.e. matches ${ matchStr })`, \"key\", key);\n            }\n\n            return matching[0];\n        }\n\n        // Normalize the signature and lookup the function\n        const result = this.#events.get(EventFragment.from(key).format());\n        if (result) { return result; }\n\n        return null;\n    }\n\n    /**\n     *  Get the event name for %%key%%, which may be a topic hash,\n     *  event name or event signature that belongs to the ABI.\n     */\n    getEventName(key: string): string {\n        const fragment = this.#getEvent(key, null, false);\n        assertArgument(fragment, \"no matching event\", \"key\", key);\n\n        return fragment.name;\n    }\n\n    /**\n     *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,\n     *  event name or event signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple events match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single event in\n     *  the ABI, this will throw.\n     */\n    getEvent(key: string, values?: Array<any | Typed>): null | EventFragment {\n        return this.#getEvent(key, values || null, true)\n    }\n\n    /**\n     *  Iterate over all events, calling %%callback%%, sorted by their name.\n     */\n    forEachEvent(callback: (func: EventFragment, index: number) => void): void {\n        const names = Array.from(this.#events.keys());\n        names.sort((a, b) => a.localeCompare(b));\n        for (let i = 0; i < names.length; i++) {\n            const name = names[i];\n            callback(<EventFragment>(this.#events.get(name)), i);\n        }\n    }\n\n    /**\n     *  Get the [[ErrorFragment]] for %%key%%, which may be an error\n     *  selector, error name or error signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple errors match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single error in\n     *  the ABI, this will throw.\n     */\n    getError(key: string, values?: Array<any | Typed>): null | ErrorFragment {\n        if (isHexString(key)) {\n            const selector = key.toLowerCase();\n\n            if (BuiltinErrors[selector]) {\n                return ErrorFragment.from(BuiltinErrors[selector].signature);\n            }\n\n            for (const fragment of this.#errors.values()) {\n                if (selector === fragment.selector) { return fragment; }\n            }\n\n            return null;\n        }\n\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (key.indexOf(\"(\") === -1) {\n            const matching = [ ];\n            for (const [ name, fragment ] of this.#errors) {\n                if (name.split(\"(\"/* fix:) */)[0] === key) { matching.push(fragment); }\n            }\n\n            if (matching.length === 0) {\n                if (key === \"Error\") { return ErrorFragment.from(\"error Error(string)\"); }\n                if (key === \"Panic\") { return ErrorFragment.from(\"error Panic(uint256)\"); }\n                return null;\n            } else if (matching.length > 1) {\n                const matchStr = matching.map((m) => JSON.stringify(m.format())).join(\", \");\n                assertArgument(false, `ambiguous error description (i.e. ${ matchStr })`, \"name\", key);\n            }\n\n            return matching[0];\n        }\n\n        // Normalize the signature and lookup the function\n        key = ErrorFragment.from(key).format()\n        if (key === \"Error(string)\") { return ErrorFragment.from(\"error Error(string)\"); }\n        if (key === \"Panic(uint256)\") { return ErrorFragment.from(\"error Panic(uint256)\"); }\n\n        const result = this.#errors.get(key);\n        if (result) { return result; }\n\n        return null;\n    }\n\n    /**\n     *  Iterate over all errors, calling %%callback%%, sorted by their name.\n     */\n    forEachError(callback: (func: ErrorFragment, index: number) => void): void {\n        const names = Array.from(this.#errors.keys());\n        names.sort((a, b) => a.localeCompare(b));\n        for (let i = 0; i < names.length; i++) {\n            const name = names[i];\n            callback(<ErrorFragment>(this.#errors.get(name)), i);\n        }\n    }\n\n    // Get the 4-byte selector used by Solidity to identify a function\n        /*\n    getSelector(fragment: ErrorFragment | FunctionFragment): string {\n        if (typeof(fragment) === \"string\") {\n            const matches: Array<Fragment> = [ ];\n\n            try { matches.push(this.getFunction(fragment)); } catch (error) { }\n            try { matches.push(this.getError(<string>fragment)); } catch (_) { }\n\n            if (matches.length === 0) {\n                logger.throwArgumentError(\"unknown fragment\", \"key\", fragment);\n            } else if (matches.length > 1) {\n                logger.throwArgumentError(\"ambiguous fragment matches function and error\", \"key\", fragment);\n            }\n\n            fragment = matches[0];\n        }\n\n        return dataSlice(id(fragment.format()), 0, 4);\n    }\n        */\n\n    // Get the 32-byte topic hash used by Solidity to identify an event\n    /*\n    getEventTopic(fragment: EventFragment): string {\n        //if (typeof(fragment) === \"string\") { fragment = this.getEvent(eventFragment); }\n        return id(fragment.format());\n    }\n    */\n\n\n    _decodeParams(params: ReadonlyArray<ParamType>, data: BytesLike): Result {\n        return this.#abiCoder.decode(params, data)\n    }\n\n    _encodeParams(params: ReadonlyArray<ParamType>, values: ReadonlyArray<any>): string {\n        return this.#abiCoder.encode(params, values)\n    }\n\n    /**\n     *  Encodes a ``tx.data`` object for deploying the Contract with\n     *  the %%values%% as the constructor arguments.\n     */\n    encodeDeploy(values?: ReadonlyArray<any>): string {\n        return this._encodeParams(this.deploy.inputs, values || [ ]);\n    }\n\n    /**\n     *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the\n     *  specified error (see [[getError]] for valid values for\n     *  %%key%%).\n     *\n     *  Most developers should prefer the [[parseCallResult]] method instead,\n     *  which will automatically detect a ``CALL_EXCEPTION`` and throw the\n     *  corresponding error.\n     */\n    decodeErrorResult(fragment: ErrorFragment | string, data: BytesLike): Result {\n        if (typeof(fragment) === \"string\") {\n            const f = this.getError(fragment);\n            assertArgument(f, \"unknown error\", \"fragment\", fragment);\n            fragment = f;\n        }\n\n        assertArgument(dataSlice(data, 0, 4) === fragment.selector,\n            `data signature does not match error ${ fragment.name }.`, \"data\", data);\n\n        return this._decodeParams(fragment.inputs, dataSlice(data, 4));\n    }\n\n    /**\n     *  Encodes the transaction revert data for a call result that\n     *  reverted from the the Contract with the sepcified %%error%%\n     *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.\n     *\n     *  This is generally not used by most developers, unless trying to mock\n     *  a result from a Contract.\n     */\n    encodeErrorResult(fragment: ErrorFragment | string, values?: ReadonlyArray<any>): string {\n        if (typeof(fragment) === \"string\") {\n            const f = this.getError(fragment);\n            assertArgument(f, \"unknown error\", \"fragment\", fragment);\n            fragment = f;\n        }\n\n        return concat([\n            fragment.selector,\n            this._encodeParams(fragment.inputs, values || [ ])\n        ]);\n    }\n\n    /**\n     *  Decodes the %%data%% from a transaction ``tx.data`` for\n     *  the function specified (see [[getFunction]] for valid values\n     *  for %%fragment%%).\n     *\n     *  Most developers should prefer the [[parseTransaction]] method\n     *  instead, which will automatically detect the fragment.\n     */\n    decodeFunctionData(fragment: FunctionFragment | string, data: BytesLike): Result {\n        if (typeof(fragment) === \"string\") {\n            const f = this.getFunction(fragment);\n            assertArgument(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n\n        assertArgument(dataSlice(data, 0, 4) === fragment.selector,\n            `data signature does not match function ${ fragment.name }.`, \"data\", data);\n\n        return this._decodeParams(fragment.inputs, dataSlice(data, 4));\n    }\n\n    /**\n     *  Encodes the ``tx.data`` for a transaction that calls the function\n     *  specified (see [[getFunction]] for valid values for %%fragment%%) with\n     *  the %%values%%.\n     */\n    encodeFunctionData(fragment: FunctionFragment | string, values?: ReadonlyArray<any>): string {\n        if (typeof(fragment) === \"string\") {\n            const f = this.getFunction(fragment);\n            assertArgument(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n\n        return concat([\n            fragment.selector,\n            this._encodeParams(fragment.inputs, values || [ ])\n        ]);\n    }\n\n    /**\n     *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the\n     *  specified function (see [[getFunction]] for valid values for\n     *  %%key%%).\n     *\n     *  Most developers should prefer the [[parseCallResult]] method instead,\n     *  which will automatically detect a ``CALL_EXCEPTION`` and throw the\n     *  corresponding error.\n     */\n    decodeFunctionResult(fragment: FunctionFragment | string, data: BytesLike): Result {\n        if (typeof(fragment) === \"string\") {\n            const f = this.getFunction(fragment);\n            assertArgument(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n\n        let message = \"invalid length for result data\";\n\n        const bytes = getBytesCopy(data);\n        if ((bytes.length % 32) === 0) {\n            try {\n                return this.#abiCoder.decode(fragment.outputs, bytes);\n            } catch (error) {\n                message = \"could not decode result data\";\n            }\n        }\n\n        // Call returned data with no error, but the data is junk\n        assert(false, message, \"BAD_DATA\", {\n            value: hexlify(bytes),\n            info: { method: fragment.name, signature: fragment.format() }\n        });\n    }\n\n    makeError(_data: BytesLike, tx: CallExceptionTransaction): CallExceptionError {\n        const data = getBytes(_data, \"data\");\n\n        const error = AbiCoder.getBuiltinCallException(\"call\", tx, data);\n\n        // Not a built-in error; try finding a custom error\n        const customPrefix = \"execution reverted (unknown custom error)\";\n        if (error.message.startsWith(customPrefix)) {\n            const selector = hexlify(data.slice(0, 4));\n\n            const ef = this.getError(selector);\n            if (ef) {\n                try {\n                    const args = this.#abiCoder.decode(ef.inputs, data.slice(4));\n                    error.revert = {\n                        name: ef.name, signature: ef.format(), args\n                    };\n                    error.reason = error.revert.signature;\n                    error.message = `execution reverted: ${ error.reason }`\n                 } catch (e) {\n                    error.message = `execution reverted (coult not decode custom error)`\n                }\n            }\n        }\n\n        // Add the invocation, if available\n        const parsed = this.parseTransaction(tx);\n        if (parsed) {\n            error.invocation = {\n                method: parsed.name,\n                signature: parsed.signature,\n                args: parsed.args\n            };\n        }\n\n        return error;\n    }\n\n    /**\n     *  Encodes the result data (e.g. from an ``eth_call``) for the\n     *  specified function (see [[getFunction]] for valid values\n     *  for %%fragment%%) with %%values%%.\n     *\n     *  This is generally not used by most developers, unless trying to mock\n     *  a result from a Contract.\n     */\n    encodeFunctionResult(fragment: FunctionFragment | string, values?: ReadonlyArray<any>): string {\n        if (typeof(fragment) === \"string\") {\n            const f = this.getFunction(fragment);\n            assertArgument(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n        return hexlify(this.#abiCoder.encode(fragment.outputs, values || [ ]));\n    }\n/*\n    spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {\n        const promises: Array<Promise<>> = [ ];\n        const process = function(type: ParamType, value: any): any {\n            if (type.baseType === \"array\") {\n                return descend(type.child\n            }\n            if (type. === \"address\") {\n            }\n        };\n\n        const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {\n            if (inputs.length !== values.length) { throw new Error(\"length mismatch\"); }\n            \n        };\n\n        const result: Array<any> = [ ];\n        values.forEach((value, index) => {\n            if (value == null) {\n                topics.push(null);\n            } else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                logger.throwArgumentError(\"filtering with tuples or arrays not supported\", (\"contract.\" + param.name), value);\n            } else if (Array.isArray(value)) {\n                topics.push(value.map((value) => encodeTopic(param, value)));\n            } else {\n                topics.push(encodeTopic(param, value));\n            }\n        });\n    }\n*/\n    // Create the filter for the event with search criteria (e.g. for eth_filterLog)\n    encodeFilterTopics(fragment: EventFragment | string, values: ReadonlyArray<any>): Array<null | string | Array<string>> {\n        if (typeof(fragment) === \"string\") {\n            const f = this.getEvent(fragment);\n            assertArgument(f, \"unknown event\", \"eventFragment\", fragment);\n            fragment = f;\n        }\n\n        assert(values.length <= fragment.inputs.length, `too many arguments for ${ fragment.format() }`,\n            \"UNEXPECTED_ARGUMENT\", { count: values.length, expectedCount: fragment.inputs.length })\n\n        const topics: Array<null | string | Array<string>> = [];\n        if (!fragment.anonymous) { topics.push(fragment.topicHash); }\n\n        // @TODO: Use the coders for this; to properly support tuples, etc.\n        const encodeTopic = (param: ParamType, value: any): string => {\n            if (param.type === \"string\") {\n                 return id(value);\n            } else if (param.type === \"bytes\") {\n                 return keccak256(hexlify(value));\n            }\n\n            if (param.type === \"bool\" && typeof(value) === \"boolean\") {\n                value = (value ? \"0x01\": \"0x00\");\n            }\n\n            if (param.type.match(/^u?int/)) {\n                value = toBeHex(value);\n            }\n\n            // Check addresses are valid\n            if (param.type === \"address\") { this.#abiCoder.encode( [ \"address\" ], [ value ]); }\n            return zeroPadValue(hexlify(value), 32);\n            //@TOOD should probably be return toHex(value, 32)\n        };\n\n        values.forEach((value, index) => {\n\n            const param = (<EventFragment>fragment).inputs[index];\n\n            if (!param.indexed) {\n                assertArgument(value == null,\n                    \"cannot filter non-indexed parameters; must be null\", (\"contract.\" + param.name), value);\n                return;\n            }\n\n            if (value == null) {\n                topics.push(null);\n            } else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                assertArgument(false, \"filtering with tuples or arrays not supported\", (\"contract.\" + param.name), value);\n            } else if (Array.isArray(value)) {\n                topics.push(value.map((value) => encodeTopic(param, value)));\n            } else {\n                topics.push(encodeTopic(param, value));\n            }\n        });\n\n        // Trim off trailing nulls\n        while (topics.length && topics[topics.length - 1] === null) {\n            topics.pop();\n        }\n\n        return topics;\n    }\n\n    encodeEventLog(fragment: EventFragment | string, values: ReadonlyArray<any>): { data: string, topics: Array<string> } {\n        if (typeof(fragment) === \"string\") {\n            const f = this.getEvent(fragment);\n            assertArgument(f, \"unknown event\", \"eventFragment\", fragment);\n            fragment = f;\n        }\n\n        const topics: Array<string> = [ ];\n\n        const dataTypes: Array<ParamType> = [ ];\n        const dataValues: Array<string> = [ ];\n\n        if (!fragment.anonymous) {\n            topics.push(fragment.topicHash);\n        }\n\n        assertArgument(values.length === fragment.inputs.length,\n            \"event arguments/values mismatch\", \"values\", values);\n\n        fragment.inputs.forEach((param, index) => {\n            const value = values[index];\n            if (param.indexed) {\n                if (param.type === \"string\") {\n                    topics.push(id(value))\n                } else if (param.type === \"bytes\") {\n                    topics.push(keccak256(value))\n                } else if (param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    // @TODO\n                    throw new Error(\"not implemented\");\n                } else {\n                    topics.push(this.#abiCoder.encode([ param.type] , [ value ]));\n                }\n            } else {\n                dataTypes.push(param);\n                dataValues.push(value);\n            }\n        });\n\n        return {\n            data: this.#abiCoder.encode(dataTypes , dataValues),\n            topics: topics\n        };\n    }\n\n    // Decode a filter for the event and the search criteria\n    decodeEventLog(fragment: EventFragment | string, data: BytesLike, topics?: ReadonlyArray<string>): Result {\n        if (typeof(fragment) === \"string\") {\n            const f = this.getEvent(fragment);\n            assertArgument(f, \"unknown event\", \"eventFragment\", fragment);\n            fragment = f;\n        }\n\n        if (topics != null && !fragment.anonymous) {\n            const eventTopic = fragment.topicHash;\n            assertArgument(isHexString(topics[0], 32) && topics[0].toLowerCase() === eventTopic,\n                \"fragment/topic mismatch\", \"topics[0]\", topics[0]);\n            topics = topics.slice(1);\n        }\n\n        const indexed: Array<ParamType> = [];\n        const nonIndexed: Array<ParamType> = [];\n        const dynamic: Array<boolean> = [];\n\n        fragment.inputs.forEach((param, index) => {\n            if (param.indexed) {\n                if (param.type === \"string\" || param.type === \"bytes\" || param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    indexed.push(ParamType.from({ type: \"bytes32\", name: param.name }));\n                    dynamic.push(true);\n                } else {\n                    indexed.push(param);\n                    dynamic.push(false);\n                }\n            } else {\n                nonIndexed.push(param);\n                dynamic.push(false);\n            }\n        });\n\n        const resultIndexed = (topics != null) ? this.#abiCoder.decode(indexed, concat(topics)): null;\n        const resultNonIndexed = this.#abiCoder.decode(nonIndexed, data, true);\n\n        //const result: (Array<any> & { [ key: string ]: any }) = [ ];\n        const values: Array<any> = [ ];\n        const keys: Array<null | string> = [ ];\n        let nonIndexedIndex = 0, indexedIndex = 0;\n        fragment.inputs.forEach((param, index) => {\n            let value = null;\n            if (param.indexed) {\n                if (resultIndexed == null) {\n                    value = new Indexed(null);\n\n                } else if (dynamic[index]) {\n                    value = new Indexed(resultIndexed[indexedIndex++]);\n\n                } else {\n                    try {\n                        value = resultIndexed[indexedIndex++];\n                    } catch (error) {\n                        value = error;\n                    }\n                }\n            } else {\n                try {\n                    value = resultNonIndexed[nonIndexedIndex++];\n                } catch (error) {\n                    value = error;\n                }\n            }\n\n            values.push(value);\n            keys.push(param.name || null);\n        });\n\n        return Result.fromItems(values, keys);\n    }\n\n    /**\n     *  Parses a transaction, finding the matching function and extracts\n     *  the parameter values along with other useful function details.\n     *\n     *  If the matching function cannot be found, return null.\n     */\n    parseTransaction(tx: { data: string, value?: BigNumberish }): null | TransactionDescription {\n        const data = getBytes(tx.data, \"tx.data\");\n        const value = getBigInt((tx.value != null) ? tx.value: 0, \"tx.value\");\n\n        const fragment = this.getFunction(hexlify(data.slice(0, 4)));\n\n        if (!fragment) { return null; }\n\n        const args = this.#abiCoder.decode(fragment.inputs, data.slice(4));\n        return new TransactionDescription(fragment, fragment.selector, args, value);\n    }\n\n    parseCallResult(data: BytesLike): Result {\n        throw new Error(\"@TODO\");\n    }\n\n    /**\n     *  Parses a receipt log, finding the matching event and extracts\n     *  the parameter values along with other useful event details.\n     *\n     *  If the matching event cannot be found, returns null.\n     */\n    parseLog(log: { topics: Array<string>, data: string}): null | LogDescription {\n        const fragment = this.getEvent(log.topics[0]);\n\n        if (!fragment || fragment.anonymous) { return null; }\n\n        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?\n        //        Probably not, because just because it is the only event in the ABI does\n        //        not mean we have the full ABI; maybe just a fragment?\n\n\n       return new LogDescription(fragment, fragment.topicHash, this.decodeEventLog(fragment, log.data, log.topics));\n    }\n\n    /**\n     *  Parses a revert data, finding the matching error and extracts\n     *  the parameter values along with other useful error details.\n     *\n     *  If the matching event cannot be found, returns null.\n     */\n    parseError(data: BytesLike): null | ErrorDescription {\n        const hexData = hexlify(data);\n\n        const fragment = this.getError(dataSlice(hexData, 0, 4));\n\n        if (!fragment) { return null; }\n\n        const args = this.#abiCoder.decode(fragment.inputs, dataSlice(hexData, 4));\n        return new ErrorDescription(fragment, fragment.selector, args);\n    }\n\n    /**\n     *  Creates a new [[Interface]] from the ABI %%value%%.\n     *\n     *  The %%value%% may be provided as an existing [[Interface]] object,\n     *  a JSON-encoded ABI or any Human-Readable ABI format.\n     */\n    static from(value: InterfaceAbi | Interface): Interface {\n        // Already an Interface, which is immutable\n        if (value instanceof Interface) { return value; }\n\n        // JSON\n        if (typeof(value) === \"string\") { return new Interface(JSON.parse(value)); }\n\n        // Maybe an interface from an older version, or from a symlinked copy\n        if (typeof((<any>value).format) === \"function\") {\n            return new Interface((<any>value).format(\"json\"));\n        }\n\n        // Array of fragments\n        return new Interface(value);\n    }\n}\n","import { assert, assertArgument } from \"../utils/index.js\";\n\nimport { getAddress } from \"./address.js\";\n\nimport type { Addressable, AddressLike, NameResolver } from \"./index.js\";\n\n\n/**\n *  Returns true if %%value%% is an object which implements the\n *  [[Addressable]] interface.\n *\n *  @example:\n *    // Wallets and AbstractSigner sub-classes\n *    isAddressable(Wallet.createRandom())\n *    //_result:\n *\n *    // Contracts\n *    contract = new Contract(\"dai.tokens.ethers.eth\", [ ], provider)\n *    isAddressable(contract)\n *    //_result:\n */\nexport function isAddressable(value: any): value is Addressable {\n    return (value && typeof(value.getAddress) === \"function\");\n}\n\n/**\n *  Returns true if %%value%% is a valid address.\n *\n *  @example:\n *    // Valid address\n *    isAddress(\"0x8ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_result:\n *\n *    // Valid ICAP address\n *    isAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\")\n *    //_result:\n *\n *    // Invalid checksum\n *    isAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBa72\")\n *    //_result:\n *\n *    // Invalid ICAP checksum\n *    isAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_result:\n *\n *    // Not an address (an ENS name requires a provided and an\n *    // asynchronous API to access)\n *    isAddress(\"ricmoo.eth\")\n *    //_result:\n */\nexport function isAddress(value: any): value is string {\n    try {\n        getAddress(value);\n        return true;\n    } catch (error) { }\n    return false;\n}\n\nasync function checkAddress(target: any, promise: Promise<null | string>): Promise<string> {\n    const result = await promise;\n    if (result == null || result === \"0x0000000000000000000000000000000000000000\") {\n        assert(typeof(target) !== \"string\", \"unconfigured name\", \"UNCONFIGURED_NAME\", { value: target });\n        assertArgument(false, \"invalid AddressLike value; did not resolve to a value address\", \"target\", target);\n    }\n    return getAddress(result);\n}\n\n/**\n *  Resolves to an address for the %%target%%, which may be any\n *  supported address type, an [[Addressable]] or a Promise which\n *  resolves to an address.\n *\n *  If an ENS name is provided, but that name has not been correctly\n *  configured a [[UnconfiguredNameError]] is thrown.\n *\n *  @example:\n *    addr = \"0x6B175474E89094C44Da98b954EedeAC495271d0F\"\n *\n *    // Addresses are return synchronously\n *    resolveAddress(addr, provider)\n *    //_result:\n *\n *    // Address promises are resolved asynchronously\n *    resolveAddress(Promise.resolve(addr))\n *    //_result:\n *\n *    // ENS names are resolved asynchronously\n *    resolveAddress(\"dai.tokens.ethers.eth\", provider)\n *    //_result:\n *\n *    // Addressable objects are resolved asynchronously\n *    contract = new Contract(addr, [ ])\n *    resolveAddress(contract, provider)\n *    //_result:\n *\n *    // Unconfigured ENS names reject\n *    resolveAddress(\"nothing-here.ricmoo.eth\", provider)\n *    //_error:\n *\n *    // ENS names require a NameResolver object passed in\n *    // (notice the provider was omitted)\n *    resolveAddress(\"nothing-here.ricmoo.eth\")\n *    //_error:\n */\nexport function resolveAddress(target: AddressLike, resolver?: null | NameResolver): string | Promise<string> {\n\n    if (typeof(target) === \"string\") {\n        if (target.match(/^0x[0-9a-f]{40}$/i)) { return getAddress(target); }\n\n        assert(resolver != null, \"ENS resolution requires a provider\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"resolveName\" });\n\n        return checkAddress(target, resolver.resolveName(target));\n\n    } else if (isAddressable(target)) {\n        return checkAddress(target, target.getAddress());\n\n    } else if (target && typeof(target.then) === \"function\") {\n        return checkAddress(target, target);\n    }\n\n    assertArgument(false, \"unsupported addressable value\", \"target\", target);\n}\n","import { getAddress } from \"../address/index.js\";\nimport { assertArgument, isHexString } from \"../utils/index.js\";\n\nimport type { AccessList, AccessListish } from \"./index.js\";\n\n\nfunction accessSetify(addr: string, storageKeys: Array<string>): { address: string,storageKeys: Array<string> } {\n    return {\n        address: getAddress(addr),\n        storageKeys: storageKeys.map((storageKey, index) => {\n            assertArgument(isHexString(storageKey, 32), \"invalid slot\", `storageKeys[${ index }]`, storageKey);\n            return storageKey.toLowerCase();\n        })\n    };\n}\n\n/**\n *  Returns a [[AccessList]] from any ethers-supported access-list structure.\n */\nexport function accessListify(value: AccessListish): AccessList {\n    if (Array.isArray(value)) {\n        return (<Array<[ string, Array<string>] | { address: string, storageKeys: Array<string>}>>value).map((set, index) => {\n            if (Array.isArray(set)) {\n                assertArgument(set.length === 2, \"invalid slot set\", `value[${ index }]`, set);\n                return accessSetify(set[0], set[1])\n            }\n            assertArgument(set != null && typeof(set) === \"object\", \"invalid address-slot set\", \"value\", value);\n            return accessSetify(set.address, set.storageKeys);\n        });\n    }\n\n    assertArgument(value != null && typeof(value) === \"object\", \"invalid access list\", \"value\", value);\n\n    const result: Array<{ address: string, storageKeys: Array<string> }> = Object.keys(value).map((addr) => {\n        const storageKeys: Record<string, true> = value[addr].reduce((accum, storageKey) => {\n            accum[storageKey] = true;\n            return accum;\n        }, <Record<string, true>>{ });\n        return accessSetify(addr, Object.keys(storageKeys).sort())\n    });\n    result.sort((a, b) => (a.address.localeCompare(b.address)));\n    return result;\n}\n","//import { resolveAddress } from \"@ethersproject/address\";\nimport {\n    defineProperties, getBigInt, getNumber, hexlify, resolveProperties,\n    assert, assertArgument, isError, makeError\n} from \"../utils/index.js\";\nimport { accessListify } from \"../transaction/index.js\";\n\nimport type { AddressLike, NameResolver } from \"../address/index.js\";\nimport type { BigNumberish, EventEmitterable } from \"../utils/index.js\";\nimport type { Signature } from \"../crypto/index.js\";\nimport type { AccessList, AccessListish, TransactionLike } from \"../transaction/index.js\";\n\nimport type { ContractRunner } from \"./contracts.js\";\nimport type { Network } from \"./network.js\";\n\n\nconst BN_0 = BigInt(0);\n\nexport type BlockTag = BigNumberish | string;\n\nimport {\n    BlockParams, LogParams, TransactionReceiptParams,\n    TransactionResponseParams\n} from \"./formatting.js\";\n\n// -----------------------\n\nfunction getValue<T>(value: undefined | null | T): null | T {\n    if (value == null) { return null; }\n    return value;\n}\n\nfunction toJson(value: null | bigint): null | string {\n    if (value == null) { return null; }\n    return value.toString();\n}\n\n// @TODO? <T extends FeeData = { }> implements Required<T>\n\n/**\n *  A **FeeData** wraps all the fee-related values associated with\n *  the network.\n */\nexport class FeeData {\n    /**\n     *  The gas price for legacy networks.\n     */\n    readonly gasPrice!: null | bigint;\n\n    /**\n     *  The maximum fee to pay per gas.\n     *\n     *  The base fee per gas is defined by the network and based on\n     *  congestion, increasing the cost during times of heavy load\n     *  and lowering when less busy.\n     *\n     *  The actual fee per gas will be the base fee for the block\n     *  and the priority fee, up to the max fee per gas.\n     *\n     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))\n     */\n    readonly maxFeePerGas!: null | bigint;\n\n    /**\n     *  The additional amout to pay per gas to encourage a validator\n     *  to include the transaction.\n     *\n     *  The purpose of this is to compensate the validator for the\n     *  adjusted risk for including a given transaction.\n     *\n     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))\n     */\n    readonly maxPriorityFeePerGas!: null | bigint;\n\n    /**\n     *  Creates a new FeeData for %%gasPrice%%, %%maxFeePerGas%% and\n     *  %%maxPriorityFeePerGas%%.\n     */\n    constructor(gasPrice?: null | bigint, maxFeePerGas?: null | bigint, maxPriorityFeePerGas?: null | bigint) {\n        defineProperties<FeeData>(this, {\n            gasPrice: getValue(gasPrice),\n            maxFeePerGas: getValue(maxFeePerGas),\n            maxPriorityFeePerGas: getValue(maxPriorityFeePerGas)\n        });\n    }\n\n    /**\n     *  Returns a JSON-friendly value.\n     */\n    toJSON(): any {\n        const {\n            gasPrice, maxFeePerGas, maxPriorityFeePerGas\n        } = this;\n        return {\n            _type: \"FeeData\",\n            gasPrice: toJson(gasPrice),\n            maxFeePerGas: toJson(maxFeePerGas),\n            maxPriorityFeePerGas: toJson(maxPriorityFeePerGas),\n        };\n    }\n}\n\n\nexport interface TransactionRequest {\n    type?: null | number;\n\n    to?: null | AddressLike;\n    from?: null | AddressLike;\n\n    nonce?: null | number;\n\n    gasLimit?: null | BigNumberish;\n    gasPrice?: null | BigNumberish;\n\n    maxPriorityFeePerGas?: null | BigNumberish;\n    maxFeePerGas?: null | BigNumberish;\n\n    data?: null | string;\n    value?: null | BigNumberish;\n    chainId?: null | BigNumberish;\n\n    accessList?: null | AccessListish;\n\n    customData?: any;\n\n    // Only meaningful when used for call\n    blockTag?: BlockTag;\n    enableCcipRead?: boolean;\n\n    // Todo?\n    //gasMultiplier?: number;\n};\n\nexport interface PreparedTransactionRequest {\n    type?: number;\n\n    to?: AddressLike;\n    from?: AddressLike;\n\n    nonce?: number;\n\n    gasLimit?: bigint;\n    gasPrice?: bigint;\n\n    maxPriorityFeePerGas?: bigint;\n    maxFeePerGas?: bigint;\n\n    data?: string;\n    value?: bigint;\n    chainId?: bigint;\n\n    accessList?: AccessList;\n\n    customData?: any;\n\n    blockTag?: BlockTag;\n    enableCcipRead?: boolean;\n}\n\nexport function copyRequest(req: TransactionRequest): PreparedTransactionRequest {\n    const result: any = { };\n\n    // These could be addresses, ENS names or Addressables\n    if (req.to) { result.to = req.to; }\n    if (req.from) { result.from = req.from; }\n\n    if (req.data) { result.data = hexlify(req.data); }\n\n    const bigIntKeys = \"chainId,gasLimit,gasPrice,maxFeePerGas,maxPriorityFeePerGas,value\".split(/,/);\n    for (const key of bigIntKeys) {\n        if (!(key in req) || (<any>req)[key] == null) { continue; }\n        result[key] = getBigInt((<any>req)[key], `request.${ key }`);\n    }\n\n    const numberKeys = \"type,nonce\".split(/,/);\n    for (const key of numberKeys) {\n        if (!(key in req) || (<any>req)[key] == null) { continue; }\n        result[key] = getNumber((<any>req)[key], `request.${ key }`);\n    }\n\n    if (req.accessList) {\n        result.accessList = accessListify(req.accessList);\n    }\n\n    if (\"blockTag\" in req) { result.blockTag = req.blockTag; }\n\n    if (\"enableCcipRead\" in req) {\n        result.enableCcipReadEnabled = !!req.enableCcipRead\n    }\n\n    if (\"customData\" in req) {\n        result.customData = req.customData;\n    }\n\n    return result;\n}\n\n//////////////////////\n// Block\n\n/**\n *  An Interface to indicate a [[Block]] has been included in the\n *  blockchain. This asserts a Type Guard that necessary properties\n *  are non-null.\n *\n *  Before a block is included, it is a //pending// block.\n */\nexport interface MinedBlock extends Block {\n    readonly number: number;\n    readonly hash: string;\n    readonly timestamp: number;\n    readonly date: Date;\n    readonly miner: string;\n}\n\n/**\n *  A **Block** represents the data associated with a full block on\n *  Ethereum.\n */\nexport class Block implements BlockParams, Iterable<string> {\n    /**\n     *  The provider connected to the block used to fetch additional details\n     *  if necessary.\n     */\n    readonly provider!: Provider;\n\n    /**\n     *  The block number, sometimes called the block height. This is a\n     *  sequential number that is one higher than the parent block.\n     */\n    readonly number!: number;\n\n    /**\n     *  The block hash.\n     */\n    readonly hash!: null | string;\n\n    /**\n     *  The timestamp for this block, which is the number of seconds since\n     *  epoch that this block was included.\n     */\n    readonly timestamp!: number;\n\n    /**\n     *  The block hash of the parent block.\n     */\n    readonly parentHash!: string;\n\n    /**\n     *  The nonce.\n     *\n     *  On legacy networks, this is the random number inserted which\n     *  permitted the difficulty target to be reached.\n     */\n    readonly nonce!: string;\n\n    /**\n     *  The difficulty target.\n     *\n     *  On legacy networks, this is the proof-of-work target required\n     *  for a block to meet the protocol rules to be included.\n     *\n     *  On modern networks, this is a random number arrived at using\n     *  randao.  @TODO: Find links?\n     */\n    readonly difficulty!: bigint;\n\n\n    /**\n     *  The total gas limit for this block.\n     */\n    readonly gasLimit!: bigint;\n\n    /**\n     *  The total gas used in this block.\n     */\n    readonly gasUsed!: bigint;\n\n    /**\n     *  The miner coinbase address, wihch receives any subsidies for\n     *  including this block.\n     */\n    readonly miner!: string;\n\n    /**\n     *  Any extra data the validator wished to include.\n     */\n    readonly extraData!: string;\n\n    /**\n     *  The base fee per gas that all transactions in this block were\n     *  charged.\n     *\n     *  This adjusts after each block, depending on how congested the network\n     *  is.\n     */\n    readonly baseFeePerGas!: null | bigint;\n\n    readonly #transactions: Array<string | TransactionResponse>;\n\n    /**\n     *  Create a new **Block** object.\n     *\n     *  This should generally not be necessary as the unless implementing a\n     *  low-level library.\n     */\n    constructor(block: BlockParams, provider: Provider) {\n\n        this.#transactions = block.transactions.map((tx) => {\n            if (typeof(tx) !== \"string\") {\n                return new TransactionResponse(tx, provider);\n            }\n            return tx;\n        });\n\n        defineProperties<Block>(this, {\n            provider,\n\n            hash: getValue(block.hash),\n\n            number: block.number,\n            timestamp: block.timestamp,\n\n            parentHash: block.parentHash,\n\n            nonce: block.nonce,\n            difficulty: block.difficulty,\n\n            gasLimit: block.gasLimit,\n            gasUsed: block.gasUsed,\n            miner: block.miner,\n            extraData: block.extraData,\n\n            baseFeePerGas: getValue(block.baseFeePerGas)\n        });\n    }\n\n    /**\n     *  Returns the list of transaction hashes.\n     */\n    get transactions(): ReadonlyArray<string> {\n        return this.#transactions.map((tx) => {\n            if (typeof(tx) === \"string\") { return tx; }\n            return tx.hash;\n        });\n    }\n\n    /**\n     *  Returns the complete transactions for blocks which\n     *  prefetched them, by passing ``true`` to %%prefetchTxs%%\n     *  into [[provider_getBlock]].\n     */\n    get prefetchedTransactions(): Array<TransactionResponse> {\n        const txs = this.#transactions.slice();\n\n        // Doesn't matter...\n        if (txs.length === 0) { return [ ]; }\n\n        // Make sure we prefetched the transactions\n        assert(typeof(txs[0]) === \"object\", \"transactions were not prefetched with block request\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"transactionResponses()\"\n        });\n\n        return <Array<TransactionResponse>>txs;\n    }\n\n    /**\n     *  Returns a JSON-friendly value.\n     */\n    toJSON(): any {\n        const {\n            baseFeePerGas, difficulty, extraData, gasLimit, gasUsed, hash,\n            miner, nonce, number, parentHash, timestamp, transactions\n        } = this;\n\n        return {\n            _type: \"Block\",\n            baseFeePerGas: toJson(baseFeePerGas),\n            difficulty: toJson(difficulty),\n            extraData,\n            gasLimit: toJson(gasLimit),\n            gasUsed: toJson(gasUsed),\n            hash, miner, nonce, number, parentHash, timestamp,\n            transactions,\n        };\n    }\n\n    [Symbol.iterator](): Iterator<string> {\n        let index = 0;\n        const txs = this.transactions;\n        return {\n            next: () => {\n                if (index < this.length) {\n                    return {\n                        value: txs[index++], done: false\n                    }\n                }\n                return { value: undefined, done: true };\n            }\n        };\n    }\n\n    /**\n     *  The number of transactions in this block.\n     */\n    get length(): number { return this.#transactions.length; }\n\n    /**\n     *  The [[link-js-date]] this block was included at.\n     */\n    get date(): null | Date {\n        if (this.timestamp == null) { return null; }\n        return new Date(this.timestamp * 1000);\n    }\n\n    /**\n     *  Get the transaction at %%indexe%% within this block.\n     */\n    async getTransaction(indexOrHash: number | string): Promise<TransactionResponse> {\n        // Find the internal value by its index or hash\n        let tx: string | TransactionResponse | undefined = undefined;\n        if (typeof(indexOrHash) === \"number\") {\n            tx = this.#transactions[indexOrHash];\n\n        } else {\n            const hash = indexOrHash.toLowerCase();\n            for (const v of this.#transactions) {\n                if (typeof(v) === \"string\") {\n                    if (v !== hash) { continue; }\n                    tx = v;\n                    break;\n                } else {\n                    if (v.hash === hash) { continue; }\n                    tx = v;\n                    break;\n                }\n            }\n        }\n        if (tx == null) { throw new Error(\"no such tx\"); }\n\n        if (typeof(tx) === \"string\") {\n            return <TransactionResponse>(await this.provider.getTransaction(tx));\n        } else {\n            return tx;\n        }\n    }\n\n    getPrefetchedTransaction(indexOrHash: number | string): TransactionResponse {\n        const txs = this.prefetchedTransactions;\n        if (typeof(indexOrHash) === \"number\") {\n            return txs[indexOrHash];\n        }\n\n        indexOrHash = indexOrHash.toLowerCase();\n        for (const tx of txs) {\n            if (tx.hash === indexOrHash) { return tx; }\n        }\n\n        assertArgument(false, \"no matching transaction\", \"indexOrHash\", indexOrHash);\n    }\n\n    /**\n     *  Has this block been mined.\n     *\n     *  If true, the block has been typed-gaurded that all mined\n     *  properties are non-null.\n     */\n    isMined(): this is MinedBlock { return !!this.hash; }\n\n    /**\n     *\n     */\n    isLondon(): this is (Block & { baseFeePerGas: bigint }) {\n        return !!this.baseFeePerGas;\n    }\n\n    orphanedEvent(): OrphanFilter {\n        if (!this.isMined()) { throw new Error(\"\"); }\n        return createOrphanedBlockFilter(this);\n    }\n}\n\n//////////////////////\n// Log\n\nexport class Log implements LogParams {\n    readonly provider: Provider;\n\n    readonly transactionHash!: string;\n    readonly blockHash!: string;\n    readonly blockNumber!: number;\n\n    readonly removed!: boolean;\n\n    readonly address!: string;\n    readonly data!: string;\n\n    readonly topics!: ReadonlyArray<string>;\n\n    readonly index!: number;\n    readonly transactionIndex!: number;\n\n\n    constructor(log: LogParams, provider: Provider) {\n        this.provider = provider;\n\n        const topics = Object.freeze(log.topics.slice());\n        defineProperties<Log>(this, {\n            transactionHash: log.transactionHash,\n            blockHash: log.blockHash,\n            blockNumber: log.blockNumber,\n\n            removed: log.removed,\n\n            address: log.address,\n            data: log.data,\n\n            topics,\n\n            index: log.index,\n            transactionIndex: log.transactionIndex,\n        });\n    }\n\n    toJSON(): any {\n        const {\n            address, blockHash, blockNumber, data, index,\n            removed, topics, transactionHash, transactionIndex\n        } = this;\n\n        return {\n            _type: \"log\",\n            address, blockHash, blockNumber, data, index,\n            removed, topics, transactionHash, transactionIndex\n        };\n    }\n\n    async getBlock(): Promise<Block> {\n        const block = await this.provider.getBlock(this.blockHash);\n        assert(!!block, \"failed to find transaction\", \"UNKNOWN_ERROR\", { });\n        return block;\n    }\n\n    async getTransaction(): Promise<TransactionResponse> {\n        const tx = await this.provider.getTransaction(this.transactionHash);\n        assert(!!tx, \"failed to find transaction\", \"UNKNOWN_ERROR\", { });\n        return tx;\n    }\n\n    async getTransactionReceipt(): Promise<TransactionReceipt> {\n        const receipt = await this.provider.getTransactionReceipt(this.transactionHash);\n        assert(!!receipt, \"failed to find transaction receipt\", \"UNKNOWN_ERROR\", { });\n        return receipt;\n    }\n\n    removedEvent(): OrphanFilter {\n        return createRemovedLogFilter(this);\n    }\n}\n\n//////////////////////\n// Transaction Receipt\n\n/*\nexport interface LegacyTransactionReceipt {\n    byzantium: false;\n    status: null;\n    root: string;\n}\n\nexport interface ByzantiumTransactionReceipt {\n    byzantium: true;\n    status: number;\n    root: null;\n}\n*/\n\nexport class TransactionReceipt implements TransactionReceiptParams, Iterable<Log> {\n    readonly provider!: Provider;\n\n    readonly to!: null | string;\n    readonly from!: string;\n    readonly contractAddress!: null | string;\n\n    readonly hash!: string;\n    readonly index!: number;\n\n    readonly blockHash!: string;\n    readonly blockNumber!: number;\n\n    readonly logsBloom!: string;\n\n    readonly gasUsed!: bigint;\n    readonly cumulativeGasUsed!: bigint;\n    readonly gasPrice!: bigint;\n\n    readonly type!: number;\n    //readonly byzantium!: boolean;\n    readonly status!: null | number;\n    readonly root!: null | string;\n\n    readonly #logs: ReadonlyArray<Log>;\n\n    constructor(tx: TransactionReceiptParams, provider: Provider) {\n        this.#logs = Object.freeze(tx.logs.map((log) => {\n            return new Log(log, provider);\n        }));\n\n        defineProperties<TransactionReceipt>(this, {\n            provider,\n\n            to: tx.to,\n            from: tx.from,\n            contractAddress: tx.contractAddress,\n\n            hash: tx.hash,\n            index: tx.index,\n\n            blockHash: tx.blockHash,\n            blockNumber: tx.blockNumber,\n\n            logsBloom: tx.logsBloom,\n\n            gasUsed: tx.gasUsed,\n            cumulativeGasUsed: tx.cumulativeGasUsed,\n            gasPrice: ((tx.effectiveGasPrice || tx.gasPrice) as bigint),\n\n            type: tx.type,\n            //byzantium: tx.byzantium,\n            status: tx.status,\n            root: tx.root\n        });\n    }\n\n    get logs(): ReadonlyArray<Log> { return this.#logs; }\n\n    toJSON(): any {\n        const {\n            to, from, contractAddress, hash, index, blockHash, blockNumber, logsBloom,\n            logs, //byzantium, \n            status, root\n        } = this;\n\n        return {\n            _type: \"TransactionReceipt\",\n            blockHash, blockNumber,\n            //byzantium, \n            contractAddress,\n            cumulativeGasUsed: toJson(this.cumulativeGasUsed),\n            from,\n            gasPrice: toJson(this.gasPrice),\n            gasUsed: toJson(this.gasUsed),\n            hash, index, logs, logsBloom, root, status, to\n        };\n    }\n\n    get length(): number { return this.logs.length; }\n\n    [Symbol.iterator](): Iterator<Log> {\n        let index = 0;\n        return {\n            next: () => {\n                if (index < this.length) {\n                    return { value: this.logs[index++], done: false }\n                }\n                return { value: undefined, done: true };\n            }\n        };\n    }\n\n    get fee(): bigint {\n        return this.gasUsed * this.gasPrice;\n    }\n\n    async getBlock(): Promise<Block> {\n        const block = await this.provider.getBlock(this.blockHash);\n        if (block == null) { throw new Error(\"TODO\"); }\n        return block;\n    }\n\n    async getTransaction(): Promise<TransactionResponse> {\n        const tx = await this.provider.getTransaction(this.hash);\n        if (tx == null) { throw new Error(\"TODO\"); }\n        return tx;\n    }\n\n    async getResult(): Promise<string> {\n        return <string>(await this.provider.getTransactionResult(this.hash));\n    }\n\n    async confirmations(): Promise<number> {\n        return (await this.provider.getBlockNumber()) - this.blockNumber + 1;\n    }\n\n    removedEvent(): OrphanFilter {\n        return createRemovedTransactionFilter(this);\n    }\n\n    reorderedEvent(other?: TransactionResponse): OrphanFilter {\n        assert(!other || other.isMined(), \"unmined 'other' transction cannot be orphaned\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"reorderedEvent(other)\" });\n        return createReorderedTransactionFilter(this, other);\n    }\n}\n\n\n//////////////////////\n// Transaction Response\n\nexport interface MinedTransactionResponse extends TransactionResponse {\n    blockNumber: number;\n    blockHash: string;\n    date: Date;\n}\n\n/*\nexport type ReplacementDetectionSetup = {\n    to: string;\n    from: string;\n    value: bigint;\n    data: string;\n    nonce: number;\n    block: number;\n};\n*/\nexport class TransactionResponse implements TransactionLike<string>, TransactionResponseParams {\n    /**\n     *  The provider this is connected to, which will influence how its\n     *  methods will resolve its async inspection methods.\n     */\n    readonly provider: Provider;\n\n    /**\n     *  The block number of the block that this transaction was included in.\n     *\n     *  This is ``null`` for pending transactions.\n     */\n    readonly blockNumber: null | number;\n\n    /**\n     *  The blockHash of the block that this transaction was included in.\n     *\n     *  This is ``null`` for pending transactions.\n     */\n    readonly blockHash: null | string;\n\n    /**\n     *  The index within the block that this transaction resides at.\n     */\n    readonly index!: number;\n\n    /**\n     *  The transaction hash.\n     */\n    readonly hash!: string;\n\n    /**\n     *  The [[link-eip-2718]] transaction envelope type. This is\n     *  ``0`` for legacy transactions types.\n     */\n    readonly type!: number;\n\n    /**\n     *  The receiver of this transaction.\n     *\n     *  If ``null``, then the transaction is an initcode transaction.\n     *  This means the result of executing the [[data]] will be deployed\n     *  as a new contract on chain (assuming it does not revert) and the\n     *  address may be computed using [[getCreateAddress]].\n     */\n    readonly to!: null | string;\n\n    /**\n     *  The sender of this transaction. It is implicitly computed\n     *  from the transaction pre-image hash (as the digest) and the\n     *  [[signature]] using ecrecover.\n     */\n    readonly from!: string;\n\n    /**\n     *  The nonce, which is used to prevent replay attacks and offer\n     *  a method to ensure transactions from a given sender are explicitly\n     *  ordered.\n     *\n     *  When sending a transaction, this must be equal to the number of\n     *  transactions ever sent by [[from]].\n     */\n    readonly nonce!: number;\n\n    /**\n     *  The maximum units of gas this transaction can consume. If execution\n     *  exceeds this, the entries transaction is reverted and the sender\n     *  is charged for the full amount, despite not state changes being made.\n     */\n    readonly gasLimit!: bigint;\n\n    /**\n     *  The gas price can have various values, depending on the network.\n     *\n     *  In modern networks, for transactions that are included this is\n     *  the //effective gas price// (the fee per gas that was actually\n     *  charged), while for transactions that have not been included yet\n     *  is the [[maxFeePerGas]].\n     *\n     *  For legacy transactions, or transactions on legacy networks, this\n     *  is the fee that will be charged per unit of gas the transaction\n     *  consumes.\n     */\n    readonly gasPrice!: bigint;\n\n    /**\n     *  The maximum priority fee (per unit of gas) to allow a\n     *  validator to charge the sender. This is inclusive of the\n     *  [[maxFeeFeePerGas]].\n     */\n    readonly maxPriorityFeePerGas!: null | bigint;\n\n    /**\n     *  The maximum fee (per unit of gas) to allow this transaction\n     *  to charge the sender.\n     */\n    readonly maxFeePerGas!: null | bigint;\n\n    /**\n     *  The data.\n     */\n    readonly data!: string;\n\n    /**\n     *  The value, in wei. Use [[formatEther]] to format this value\n     *  as ether.\n     */\n    readonly value!: bigint;\n\n    /**\n     *  The chain ID.\n     */\n    readonly chainId!: bigint;\n\n    /**\n     *  The signature.\n     */\n    readonly signature!: Signature;\n\n    /**\n     *  The [[link-eip-2930]] access list for transaction types that\n     *  support it, otherwise ``null``.\n     */\n    readonly accessList!: null | AccessList;\n\n    #startBlock: number;\n\n    /**\n     *  Create a new TransactionResponse with %%tx%% parameters\n     *  connected to %%provider%%.\n     */\n    constructor(tx: TransactionResponseParams, provider: Provider) {\n        this.provider = provider;\n\n        this.blockNumber = (tx.blockNumber != null) ? tx.blockNumber: null;\n        this.blockHash = (tx.blockHash != null) ? tx.blockHash: null;\n\n        this.hash = tx.hash;\n        this.index = tx.index;\n\n        this.type = tx.type;\n\n        this.from = tx.from;\n        this.to = tx.to || null;\n\n        this.gasLimit = tx.gasLimit;\n        this.nonce = tx.nonce;\n        this.data = tx.data;\n        this.value = tx.value;\n\n        this.gasPrice = tx.gasPrice;\n        this.maxPriorityFeePerGas = (tx.maxPriorityFeePerGas != null) ? tx.maxPriorityFeePerGas: null;\n        this.maxFeePerGas = (tx.maxFeePerGas != null) ? tx.maxFeePerGas: null;\n\n        this.chainId = tx.chainId;\n        this.signature = tx.signature;\n\n        this.accessList = (tx.accessList != null) ? tx.accessList: null;\n\n        this.#startBlock = -1;\n    }\n\n    /**\n     *  Returns a JSON representation of this transaction.\n     */\n    toJSON(): any {\n        const {\n            blockNumber, blockHash, index, hash, type, to, from, nonce,\n            data, signature, accessList\n        } = this;\n\n        return {\n            _type: \"TransactionReceipt\",\n            accessList, blockNumber, blockHash,\n            chainId: toJson(this.chainId),\n            data, from,\n            gasLimit: toJson(this.gasLimit),\n            gasPrice: toJson(this.gasPrice),\n            hash,\n            maxFeePerGas: toJson(this.maxFeePerGas),\n            maxPriorityFeePerGas: toJson(this.maxPriorityFeePerGas),\n            nonce, signature, to, index, type,\n            value: toJson(this.value),\n        };\n    }\n\n    /**\n     *  Resolves to the Block that this transaction was included in.\n     *\n     *  This will return null if the transaction has not been included yet.\n     */\n    async getBlock(): Promise<null | Block> {\n        let blockNumber = this.blockNumber;\n        if (blockNumber == null) {\n            const tx = await this.getTransaction();\n            if (tx) { blockNumber = tx.blockNumber; }\n        }\n        if (blockNumber == null) { return null; }\n        const block = this.provider.getBlock(blockNumber);\n        if (block == null) { throw new Error(\"TODO\"); }\n        return block;\n    }\n\n    /**\n     *  Resolves to this transaction being re-requested from the\n     *  provider. This can be used if you have an unmined transaction\n     *  and wish to get an up-to-date populated instance.\n     */\n    async getTransaction(): Promise<null | TransactionResponse> {\n        return this.provider.getTransaction(this.hash);\n    }\n\n    /**\n     *  Resolves once this transaction has been mined and has\n     *  %%confirms%% blocks including it (default: ``1``) with an\n     *  optional %%timeout%%.\n     *\n     *  This can resolve to ``null`` only if %%confirms%% is ``0``\n     *  and the transaction has not been mined, otherwise this will\n     *  wait until enough confirmations have completed.\n     */\n    async wait(_confirms?: number, _timeout?: number): Promise<null | TransactionReceipt> {\n        const confirms = (_confirms == null) ? 1: _confirms;\n        const timeout = (_timeout == null) ? 0: _timeout;\n\n        let startBlock = this.#startBlock\n        let nextScan = -1;\n        let stopScanning = (startBlock === -1) ? true: false;\n        const checkReplacement = async () => {\n            // Get the current transaction count for this sender\n            if (stopScanning) { return null; }\n            const { blockNumber, nonce } = await resolveProperties({\n                blockNumber: this.provider.getBlockNumber(),\n                nonce: this.provider.getTransactionCount(this.from)\n            });\n\n            // No transaction or our nonce has not been mined yet; but we\n            // can start scanning later when we do start\n            if (nonce < this.nonce) {\n                startBlock = blockNumber;\n                return;\n            }\n\n            // We were mined; no replacement\n            if (stopScanning) { return null; }\n            const mined = await this.getTransaction();\n            if (mined && mined.blockNumber != null) { return; }\n\n            // We were replaced; start scanning for that transaction\n\n            // Starting to scan; look back a few extra blocks for safety\n            if (nextScan === -1) {\n                nextScan = startBlock - 3;\n                if (nextScan < this.#startBlock) { nextScan = this.#startBlock; }\n            }\n\n            while (nextScan <= blockNumber) {\n                // Get the next block to scan\n                if (stopScanning) { return null; }\n                const block = await this.provider.getBlock(nextScan, true);\n\n                // This should not happen; but we'll try again shortly\n                if (block == null) { return; }\n\n                // We were mined; no replacement\n                for (const hash of block) {\n                    if (hash === this.hash) { return; }\n                }\n\n                // Search for the transaction that replaced us\n                for (let i = 0; i < block.length; i++) {\n                    const tx: TransactionResponse = await block.getTransaction(i);\n\n                    if (tx.from === this.from && tx.nonce === this.nonce) {\n                        // Get the receipt\n                        if (stopScanning) { return null; }\n                        const receipt = await this.provider.getTransactionReceipt(tx.hash);\n\n                        // This should not happen; but we'll try again shortly\n                        if (receipt == null) { return; }\n\n                        // We will retry this on the next block (this case could be optimized)\n                        if ((blockNumber - receipt.blockNumber + 1) < confirms) { return; }\n\n                        // The reason we were replaced\n                        let reason: \"replaced\" | \"repriced\" | \"cancelled\" = \"replaced\";\n                        if (tx.data === this.data && tx.to === this.to && tx.value === this.value) {\n                            reason = \"repriced\";\n                        } else  if (tx.data === \"0x\" && tx.from === tx.to && tx.value === BN_0) {\n                            reason = \"cancelled\"\n                        }\n\n                        assert(false, \"transaction was replaced\", \"TRANSACTION_REPLACED\", {\n                            cancelled: (reason === \"replaced\" || reason === \"cancelled\"),\n                            reason,\n                            replacement: tx.replaceableTransaction(startBlock),\n                            hash: tx.hash,\n                            receipt\n                        });\n                    }\n                }\n\n                nextScan++;\n            }\n            return;\n        };\n\n        const receipt = await this.provider.getTransactionReceipt(this.hash);\n\n        if (receipt) {\n            if ((await receipt.confirmations()) >= confirms) { return receipt; }\n\n        } else {\n            // Check for a replacement; throws if a replacement was found\n            await checkReplacement();\n\n            // Allow null only when the confirms is 0\n            if (confirms === 0) { return null; }\n        }\n\n        const waiter = new Promise((resolve, reject) => {\n            // List of things to cancel when we have a result (one way or the other)\n            const cancellers: Array<() => void> = [ ];\n            const cancel = () => { cancellers.forEach((c) => c()); };\n\n            // On cancel, stop scanning for replacements\n            cancellers.push(() => { stopScanning = true; });\n\n            // Set up any timeout requested\n            if (timeout > 0) {\n                const timer = setTimeout(() => {\n                    cancel();\n                    reject(makeError(\"wait for transaction timeout\", \"TIMEOUT\"));\n                }, timeout);\n                cancellers.push(() => { clearTimeout(timer); });\n            }\n\n            const txListener = async (receipt: TransactionReceipt) => {\n                // Done; return it!\n                if ((await receipt.confirmations()) >= confirms) {\n                    cancel();\n                    resolve(receipt);\n                }\n\n            };\n            cancellers.push(() => { this.provider.off(this.hash, txListener); });\n            this.provider.on(this.hash, txListener);\n            // We support replacement detection; start checking\n            if (startBlock >= 0) {\n                const replaceListener = async () => {\n                    try {\n                        // Check for a replacement; this throws only if one is found\n                        await checkReplacement();\n\n                    } catch (error) {\n                        // We were replaced (with enough confirms); re-throw the error\n                        if (isError(error, \"TRANSACTION_REPLACED\")) {\n                            cancel();\n                            reject(error);\n                            return;\n                        }\n                    }\n\n                    // Rescheudle a check on the next block\n                    if (!stopScanning) {\n                        this.provider.once(\"block\", replaceListener);\n                    }\n                };\n                cancellers.push(() => { this.provider.off(\"block\", replaceListener); });\n                this.provider.once(\"block\", replaceListener);\n            }\n        });\n\n        return await <Promise<TransactionReceipt>>waiter;\n    }\n\n    /**\n     *  Returns ``true`` if this transaction has been included.\n     *\n     *  This is effective only as of the time the TransactionResponse\n     *  was instantiated. To get up-to-date information, use\n     *  [[getTransaction]].\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  non-null property values for properties that are null for\n     *  unmined transactions.\n     */\n    isMined(): this is MinedTransactionResponse {\n        return (this.blockHash != null);\n    }\n\n    /**\n     *  Returns true if the transaction is a legacy (i.e. ``type == 0``)\n     *  transaction.\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  the ``null``-ness for hardfork-specific properties set correctly.\n     */\n    isLegacy(): this is (TransactionResponse & { accessList: null, maxFeePerGas: null, maxPriorityFeePerGas: null }) {\n        return (this.type === 0)\n    }\n\n    /**\n     *  Returns true if the transaction is a Berlin (i.e. ``type == 1``)\n     *  transaction. See [[link-eip-2070]].\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  the ``null``-ness for hardfork-specific properties set correctly.\n     */\n    isBerlin(): this is (TransactionResponse & { accessList: AccessList, maxFeePerGas: null, maxPriorityFeePerGas: null }) {\n        return (this.type === 1);\n    }\n\n    /**\n     *  Returns true if the transaction is a London (i.e. ``type == 2``)\n     *  transaction. See [[link-eip-1559]].\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  the ``null``-ness for hardfork-specific properties set correctly.\n     */\n    isLondon(): this is (TransactionResponse & { accessList: AccessList, maxFeePerGas: bigint, maxPriorityFeePerGas: bigint }){\n        return (this.type === 2);\n    }\n\n    /**\n     *  Returns a filter which can be used to listen for orphan events\n     *  that evict this transaction.\n     */\n    removedEvent(): OrphanFilter {\n        assert(this.isMined(), \"unmined transaction canot be orphaned\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"removeEvent()\" });\n        return createRemovedTransactionFilter(this);\n    }\n\n    /**\n     *  Returns a filter which can be used to listen for orphan events\n     *  that re-order this event against %%other%%.\n     */\n    reorderedEvent(other?: TransactionResponse): OrphanFilter {\n        assert(this.isMined(), \"unmined transaction canot be orphaned\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"removeEvent()\" });\n\n        assert(!other || other.isMined(), \"unmined 'other' transaction canot be orphaned\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"removeEvent()\" });\n\n        return createReorderedTransactionFilter(this, other);\n    }\n\n    /**\n     *  Returns a new TransactionResponse instance which has the ability to\n     *  detect (and throw an error) if the transaction is replaced, which\n     *  will begin scanning at %%startBlock%%.\n     *\n     *  This should generally not be used by developers and is intended\n     *  primarily for internal use. Setting an incorrect %%startBlock%% can\n     *  have devastating performance consequences if used incorrectly.\n     */\n    replaceableTransaction(startBlock: number): TransactionResponse {\n        assertArgument(Number.isInteger(startBlock) && startBlock >= 0, \"invalid startBlock\", \"startBlock\", startBlock);\n        const tx = new TransactionResponse(this, this.provider);\n        tx.#startBlock = startBlock;\n        return tx;\n    }\n}\n\n\n//////////////////////\n// OrphanFilter\n\n/**\n *  An Orphan Filter allows detecting when an orphan block has\n *  resulted in dropping a block or transaction or has resulted\n *  in transactions changing order.\n *\n *  Not currently fully supported.\n */\nexport type OrphanFilter = {\n    orphan: \"drop-block\",\n    hash: string,\n    number: number\n} | {\n    orphan: \"drop-transaction\",\n    tx: { hash: string, blockHash: string, blockNumber: number },\n    other?: { hash: string, blockHash: string, blockNumber: number }\n} | {\n    orphan: \"reorder-transaction\",\n    tx: { hash: string, blockHash: string, blockNumber: number },\n    other?: { hash: string, blockHash: string, blockNumber: number }\n} | {\n    orphan: \"drop-log\",\n    log: {\n        transactionHash: string,\n        blockHash: string,\n        blockNumber: number,\n        address: string,\n        data: string,\n        topics: ReadonlyArray<string>,\n        index: number\n    }\n};\n\nfunction createOrphanedBlockFilter(block: { hash: string, number: number }): OrphanFilter {\n    return { orphan: \"drop-block\", hash: block.hash, number: block.number };\n}\n\nfunction createReorderedTransactionFilter(tx: { hash: string, blockHash: string, blockNumber: number }, other?: { hash: string, blockHash: string, blockNumber: number }): OrphanFilter {\n    return { orphan: \"reorder-transaction\", tx, other };\n}\n\nfunction createRemovedTransactionFilter(tx: { hash: string, blockHash: string, blockNumber: number }): OrphanFilter {\n    return { orphan: \"drop-transaction\", tx };\n}\n\nfunction createRemovedLogFilter(log: { blockHash: string, transactionHash: string, blockNumber: number, address: string, data: string, topics: ReadonlyArray<string>, index: number }): OrphanFilter {\n    return { orphan: \"drop-log\", log: {\n        transactionHash: log.transactionHash,\n        blockHash: log.blockHash,\n        blockNumber: log.blockNumber,\n        address: log.address,\n        data: log.data,\n        topics: Object.freeze(log.topics.slice()),\n        index: log.index\n    } };\n}\n\n//////////////////////\n// EventFilter\n\n/**\n *  A **TopicFilter** provides a struture to define bloom-filter\n *  queries.\n *\n *  Each field that is ``null`` matches **any** value, a field that is\n *  a ``string`` must match exactly that value and and ``array`` is\n *  effectively an ``OR``-ed set, where any one of those values must\n *  match.\n */\nexport type TopicFilter = Array<null | string | Array<string>>;\n\n// @TODO:\n//export type DeferableTopicFilter = Array<null | string | Promise<string> | Array<string | Promise<string>>>;\n\nexport interface EventFilter {\n    address?: AddressLike | Array<AddressLike>;\n    topics?: TopicFilter;\n}\n\nexport interface Filter extends EventFilter {\n    fromBlock?: BlockTag;\n    toBlock?: BlockTag;\n}\n\nexport interface FilterByBlockHash extends EventFilter {\n    blockHash?: string;\n}\n\n\n//////////////////////\n// ProviderEvent\n\nexport type ProviderEvent = string | Array<string | Array<string>> | EventFilter | OrphanFilter;\n\n\n//////////////////////\n// Provider\n\n/**\n *  A **Provider** is the primary method to interact with the read-only\n *  content on Ethereum.\n *\n *  It allows access to details about accounts, blocks and transactions\n *  and the ability to query event logs and simulate contract execution.\n *\n *  Account data includes the [balance](getBalance),\n *  [transaction count](getTransactionCount), [code](getCode) and\n *  [state trie storage](getStorage).\n *\n *  Simulating execution can be used to [call](call),\n *  [estimate gas](estimateGas) and\n *  [get transaction results](getTransactionResult).\n *\n *  The [[broadcastTransaction]] is the only method which allows updating\n *  the blockchain, but it is usually accessed by a [[Signer]], since a\n *  private key must be used to sign the transaction before it can be\n *  broadcast.\n */\nexport interface Provider extends ContractRunner, EventEmitterable<ProviderEvent>, NameResolver {\n\n    /**\n     *  The provider iteself.\n     *\n     *  This is part of the necessary API for executing a contract, as\n     *  it provides a common property on any [[ContractRunner]] that\n     *  can be used to access the read-only portion of the runner.\n     */\n    provider: this;\n\n    /**\n     *  Shutdown any resources this provider is using. No additional\n     *  calls should be made to this provider after calling this.\n     */\n    destroy(): void;\n\n    ////////////////////\n    // State\n\n    /**\n     *  Get the current block number.\n     */\n    getBlockNumber(): Promise<number>;\n\n    /**\n     *  Get the connected [[Network]].\n     */\n    getNetwork(): Promise<Network>;\n\n    /**\n     *  Get the best guess at the recommended [[FeeData]].\n     */\n    getFeeData(): Promise<FeeData>;\n\n\n    ////////////////////\n    // Account\n\n    /**\n     *  Get the account balance (in wei) of %%address%%. If %%blockTag%%\n     *  is specified and the node supports archive access for that\n     *  %%blockTag%%, the balance is as of that [[BlockTag]].\n     *\n     *  @note On nodes without archive access enabled, the %%blockTag%% may be\n     *        **silently ignored** by the node, which may cause issues if relied on.\n     */\n    getBalance(address: AddressLike, blockTag?: BlockTag): Promise<bigint>;\n\n    /**\n     *  Get the number of transactions ever sent for %%address%%, which\n     *  is used as the ``nonce`` when sending a transaction. If\n     *  %%blockTag%% is specified and the node supports archive access\n     *  for that %%blockTag%%, the transaction count is as of that\n     *  [[BlockTag]].\n     *\n     *  @note On nodes without archive access enabled, the %%blockTag%% may be\n     *        **silently ignored** by the node, which may cause issues if relied on.\n     */\n    getTransactionCount(address: AddressLike, blockTag?: BlockTag): Promise<number>;\n\n    /**\n     *  Get the bytecode for %%address%%.\n     *\n     *  @note On nodes without archive access enabled, the %%blockTag%% may be\n     *        **silently ignored** by the node, which may cause issues if relied on.\n     */\n    getCode(address: AddressLike, blockTag?: BlockTag): Promise<string>\n\n    /**\n     *  Get the storage slot value for %%address%% at slot %%position%%.\n     *\n     *  @note On nodes without archive access enabled, the %%blockTag%% may be\n     *        **silently ignored** by the node, which may cause issues if relied on.\n     */\n    getStorage(address: AddressLike, position: BigNumberish, blockTag?: BlockTag): Promise<string>\n\n\n    ////////////////////\n    // Execution\n\n    /**\n     *  Estimates the amount of gas required to executre %%tx%%.\n     */\n    estimateGas(tx: TransactionRequest): Promise<bigint>;\n\n    /**\n     *  Simulate the execution of %%tx%%. If the call reverts, it will\n     *  throw a [[CallExceptionError]] which includes the revert data.\n     */\n    call(tx: TransactionRequest): Promise<string>\n\n    /**\n     *  Broadcasts the %%signedTx%% to the network, adding it to the\n     *  memory pool of any node for which the transaction meets the\n     *  rebroadcast requirements.\n     */\n    broadcastTransaction(signedTx: string): Promise<TransactionResponse>;\n\n\n    ////////////////////\n    // Queries\n\n    /**\n     *  Resolves to the block for %%blockHashOrBlockTag%%.\n     *\n     *  If %%prefetchTxs%%, and the backend supports including transactions\n     *  with block requests, all transactions will be included and the\n     *  [[Block]] object will not need to make remote calls for getting\n     *  transactions.\n     */\n    getBlock(blockHashOrBlockTag: BlockTag | string, prefetchTxs?: boolean): Promise<null | Block>;\n\n    /**\n     *  Resolves to the transaction for %%hash%%.\n     *\n     *  If the transaction is unknown or on pruning nodes which\n     *  discard old transactions this resolves to ``null``.\n     */\n    getTransaction(hash: string): Promise<null | TransactionResponse>;\n\n    /**\n     *  Resolves to the transaction receipt for %%hash%%, if mined.\n     *\n     *  If the transaction has not been mined, is unknown or on\n     *  pruning nodes which discard old transactions this resolves to\n     *  ``null``.\n     */\n    getTransactionReceipt(hash: string): Promise<null | TransactionReceipt>;\n\n    /**\n     *  Resolves to the result returned by the executions of %%hash%%.\n     *\n     *  This is only supported on nodes with archive access and with\n     *  the necessary debug APIs enabled.\n     */\n    getTransactionResult(hash: string): Promise<null | string>;\n\n\n    ////////////////////\n    // Bloom-filter Queries\n\n    /**\n     *  Resolves to the list of Logs that match %%filter%%\n     */\n    getLogs(filter: Filter | FilterByBlockHash): Promise<Array<Log>>;\n\n\n    ////////////////////\n    // ENS\n\n    /**\n     *  Resolves to the address configured for the %%ensName%% or\n     *  ``null`` if unconfigured.\n     */\n    resolveName(ensName: string): Promise<null | string>;\n\n    /**\n     *  Resolves to the ENS name associated for the %%address%% or\n     *  ``null`` if the //primary name// is not configured.\n     *\n     *  Users must perform additional steps to configure a //primary name//,\n     *  which is not currently common.\n     */\n    lookupAddress(address: string): Promise<null | string>;\n\n    /**\n     *  Waits until the transaction %%hash%% is mined and has %%confirms%%\n     *  confirmations.\n     */\n    waitForTransaction(hash: string, confirms?: number, timeout?: number): Promise<null | TransactionReceipt>;\n\n    /**\n     *  Resolves to the block at %%blockTag%% once it has been mined.\n     *\n     *  This can be useful for waiting some number of blocks by using\n     *  the ``currentBlockNumber + N``.\n     */\n    waitForBlock(blockTag?: BlockTag): Promise<Block>;\n}\n","/**\n *  Explain events...\n *\n *  @_section api/utils/events:Events  [about-events]\n */\nimport { defineProperties } from \"./properties.js\";\n\n/**\n *  A callback function called when a an event is triggered.\n */\nexport type Listener = (...args: Array<any>) => void;\n\n/**\n *  An **EventEmitterable** behaves similar to an EventEmitter\n *  except provides async access to its methods.\n *\n *  An EventEmitter implements the observer pattern.\n */\nexport interface EventEmitterable<T> {\n    /**\n     *  Registers a %%listener%% that is called whenever the\n     *  %%event%% occurs until unregistered.\n     */\n    on(event: T, listener: Listener): Promise<this>;\n\n    /**\n     *  Registers a %%listener%% that is called the next time\n     *  %%event%% occurs.\n     */\n    once(event: T, listener: Listener): Promise<this>;\n\n    /**\n     *  Triggers each listener for %%event%% with the %%args%%.\n     */\n    emit(event: T, ...args: Array<any>): Promise<boolean>;\n\n    /**\n     *  Resolves to the number of listeners for %%event%%.\n     */\n    listenerCount(event?: T): Promise<number>;\n\n    /**\n     *  Resolves to the listeners for %%event%%.\n     */\n    listeners(event?: T): Promise<Array<Listener>>;\n\n    /**\n     *  Unregister the %%listener%% for %%event%%. If %%listener%%\n     *  is unspecified, all listeners are unregistered.\n     */\n    off(event: T, listener?: Listener): Promise<this>;\n\n    /**\n     *  Unregister all listeners for %%event%%.\n     */\n    removeAllListeners(event?: T): Promise<this>;\n\n    /**\n     *  Alias for [[on]].\n     */\n    addListener(event: T, listener: Listener): Promise<this>;\n\n    /**\n     *  Alias for [[off]].\n     */\n    removeListener(event: T, listener: Listener): Promise<this>;\n}\n\n/**\n *  When an [[EventEmitterable]] triggers a [[Listener]], the\n *  callback always ahas one additional argument passed, which is\n *  an **EventPayload**.\n */\nexport class EventPayload<T> {\n    /**\n     *  The event filter.\n     */\n    readonly filter!: T;\n\n    /**\n     *  The **EventEmitterable**.\n     */\n    readonly emitter!: EventEmitterable<T>;\n\n    readonly #listener: null | Listener;\n\n    /**\n     *  Create a new **EventPayload** for %%emitter%% with\n     *  the %%listener%% and for %%filter%%.\n     */\n    constructor(emitter: EventEmitterable<T>, listener: null | Listener, filter: T) {\n        this.#listener = listener;\n        defineProperties<EventPayload<any>>(this, { emitter, filter });\n    }\n\n    /**\n     *  Unregister the triggered listener for future events.\n     */\n    async removeListener(): Promise<void> {\n        if (this.#listener == null) { return; }\n        await this.emitter.off(this.filter, this.#listener);\n    }\n}\n","// import from provider.ts instead of index.ts to prevent circular dep\n// from EtherscanProvider\nimport {\n    Block, Log, TransactionReceipt, TransactionResponse\n} from \"../providers/provider.js\";\nimport { defineProperties, EventPayload } from \"../utils/index.js\";\n\nimport type { EventFragment, Interface, Result } from \"../abi/index.js\";\nimport type { Listener } from \"../utils/index.js\";\nimport type {\n    Provider\n} from \"../providers/index.js\";\n\nimport type { BaseContract } from \"./contract.js\";\nimport type { ContractEventName } from \"./types.js\";\n\n\nexport class EventLog extends Log {\n    readonly interface!: Interface;\n    readonly fragment!: EventFragment;\n    readonly args!: Result;\n\n    constructor(log: Log, iface: Interface, fragment: EventFragment) {\n        super(log, log.provider);\n        const args = iface.decodeEventLog(fragment, log.data, log.topics);\n        defineProperties<EventLog>(this, { args, fragment, interface: iface });\n    }\n\n    get eventName(): string { return this.fragment.name; }\n    get eventSignature(): string { return this.fragment.format(); }\n}\n\nexport class ContractTransactionReceipt extends TransactionReceipt {\n    readonly #iface: Interface;\n\n    constructor(iface: Interface, provider: Provider, tx: TransactionReceipt) {\n        super(tx, provider);\n        this.#iface = iface;\n    }\n\n    get logs(): Array<EventLog | Log> {\n        return super.logs.map((log) => {\n            const fragment = log.topics.length ? this.#iface.getEvent(log.topics[0]): null;\n            if (fragment) {\n                return new EventLog(log, this.#iface, fragment)\n            } else {\n                return log;\n            }\n        });\n    }\n\n}\n\nexport class ContractTransactionResponse extends TransactionResponse {\n    readonly #iface: Interface;\n\n    constructor(iface: Interface, provider: Provider, tx: TransactionResponse) {\n        super(tx, provider);\n        this.#iface = iface;\n    }\n\n    async wait(confirms?: number): Promise<null | ContractTransactionReceipt> {\n        const receipt = await super.wait();\n        if (receipt == null) { return null; }\n        return new ContractTransactionReceipt(this.#iface, this.provider, receipt);\n    }\n}\n\nexport  class ContractUnknownEventPayload extends EventPayload<ContractEventName> {\n    readonly log!: Log;\n\n    constructor(contract: BaseContract, listener: null | Listener, filter: ContractEventName, log: Log) {\n        super(contract, listener, filter);\n        defineProperties<ContractUnknownEventPayload>(this, { log });\n    }\n\n    async getBlock(): Promise<Block> {\n        return await this.log.getBlock();\n    }\n\n    async getTransaction(): Promise<TransactionResponse> {\n        return await this.log.getTransaction();\n    }\n\n    async getTransactionReceipt(): Promise<TransactionReceipt> {\n        return await this.log.getTransactionReceipt();\n    }\n}\n\nexport class ContractEventPayload extends ContractUnknownEventPayload {\n\n    declare readonly fragment: EventFragment;\n    declare readonly log: EventLog;\n    declare readonly args: Result;\n\n    constructor(contract: BaseContract, listener: null | Listener, filter: ContractEventName, fragment: EventFragment, _log: Log) {\n        super(contract, listener, filter, new EventLog(_log, contract.interface, fragment));\n        const args = contract.interface.decodeEventLog(fragment, this.log.data, this.log.topics);\n        defineProperties<ContractEventPayload>(this, { args, fragment });\n    }\n\n    get eventName(): string {\n        return this.fragment.name;\n    }\n\n    get eventSignature(): string {\n        return this.fragment.format();\n    }\n}\n","import { Interface, Typed } from \"../abi/index.js\";\nimport { resolveAddress } from \"../address/index.js\";\n// import from provider.ts instead of index.ts to prevent circular dep\n// from EtherscanProvider\nimport { copyRequest, Log, TransactionResponse } from \"../providers/provider.js\";\nimport {\n    defineProperties, isCallException, isHexString, resolveProperties,\n    makeError, assert, assertArgument\n} from \"../utils/index.js\";\n\nimport {\n    ContractEventPayload, ContractUnknownEventPayload,\n    ContractTransactionResponse,\n    EventLog\n} from \"./wrappers.js\";\n\nimport type { EventFragment, FunctionFragment, InterfaceAbi, ParamType, Result } from \"../abi/index.js\";\nimport type { Addressable } from \"../address/index.js\";\nimport type { EventEmitterable, Listener } from \"../utils/index.js\";\nimport type {\n    BlockTag, ContractRunner, Provider, TransactionRequest, TopicFilter\n} from \"../providers/index.js\";\n\nimport type {\n    BaseContractMethod,\n    ContractEventName,\n    ContractInterface,\n    ContractMethodArgs,\n    ContractMethod,\n    ContractEventArgs,\n    ContractEvent,\n    ContractTransaction,\n    DeferredTopicFilter,\n    WrappedFallback\n} from \"./types.js\";\n\nconst BN_0 = BigInt(0);\n\ninterface ContractRunnerCaller extends ContractRunner {\n    call: (tx: TransactionRequest) => Promise<string>;\n}\n\ninterface ContractRunnerEstimater extends ContractRunner {\n    estimateGas: (tx: TransactionRequest) => Promise<bigint>;\n}\n\ninterface ContractRunnerSender extends ContractRunner {\n    sendTransaction: (tx: TransactionRequest) => Promise<TransactionResponse>;\n}\n\ninterface ContractRunnerResolver extends ContractRunner {\n    resolveName: (name: string | Addressable) => Promise<null | string>;\n}\n\nfunction canCall(value: any): value is ContractRunnerCaller {\n    return (value && typeof(value.call) === \"function\");\n}\n\nfunction canEstimate(value: any): value is ContractRunnerEstimater {\n    return (value && typeof(value.estimateGas) === \"function\");\n}\n\nfunction canResolve(value: any): value is ContractRunnerResolver {\n    return (value && typeof(value.resolveName) === \"function\");\n}\n\nfunction canSend(value: any): value is ContractRunnerSender {\n    return (value && typeof(value.sendTransaction) === \"function\");\n}\n\nclass PreparedTopicFilter implements DeferredTopicFilter {\n    #filter: Promise<TopicFilter>;\n    readonly fragment!: EventFragment;\n\n    constructor(contract: BaseContract, fragment: EventFragment, args: Array<any>) {\n        defineProperties<PreparedTopicFilter>(this, { fragment });\n        if (fragment.inputs.length < args.length) {\n            throw new Error(\"too many arguments\");\n        }\n\n        // Recursively descend into args and resolve any addresses\n        const runner = getRunner(contract.runner, \"resolveName\");\n        const resolver = canResolve(runner) ? runner: null;\n        this.#filter = (async function() {\n            const resolvedArgs = await Promise.all(fragment.inputs.map((param, index) => {\n                const arg = args[index];\n                if (arg == null) { return null; }\n\n                return param.walkAsync(args[index], (type, value) => {\n                    if (type === \"address\") {\n                        return resolveAddress(value, resolver);\n                    }\n                    return value;\n                });\n            }));\n\n            return contract.interface.encodeFilterTopics(fragment, resolvedArgs);\n        })();\n    }\n\n    getTopicFilter(): Promise<TopicFilter> {\n        return this.#filter;\n    }\n}\n\n\n// A = Arguments passed in as a tuple\n// R = The result type of the call (i.e. if only one return type,\n//     the qualified type, otherwise Result)\n// D = The type the default call will return (i.e. R for view/pure,\n//     TransactionResponse otherwise)\n//export interface ContractMethod<A extends Array<any> = Array<any>, R = any, D extends R | ContractTransactionResponse = ContractTransactionResponse> {\n\nfunction getRunner<T extends ContractRunner>(value: any, feature: keyof ContractRunner): null | T {\n    if (value == null) { return null; }\n    if (typeof(value[feature]) === \"function\") { return value; }\n    if (value.provider && typeof(value.provider[feature]) === \"function\") {\n        return value.provider;\n    }\n    return null;\n}\n\nfunction getProvider(value: null | ContractRunner): null | Provider {\n    if (value == null) { return null; }\n    return value.provider || null;\n}\n\n/**\n *  @_ignore:\n */\nexport async function copyOverrides<O extends string = \"data\" | \"to\">(arg: any, allowed?: Array<string>): Promise<Omit<ContractTransaction, O>> {\n\n    // Create a shallow copy (we'll deep-ify anything needed during normalizing)\n    const overrides = copyRequest(Typed.dereference(arg, \"overrides\"));\n\n    assertArgument(overrides.to == null || (allowed || [ ]).indexOf(\"to\") >= 0,\n      \"cannot override to\", \"overrides.to\", overrides.to);\n    assertArgument(overrides.data == null || (allowed || [ ]).indexOf(\"data\") >= 0,\n      \"cannot override data\", \"overrides.data\", overrides.data);\n\n    // Resolve any from\n    if (overrides.from) {\n        overrides.from = await resolveAddress(overrides.from);\n    }\n\n    return <Omit<ContractTransaction, O>>overrides;\n}\n\n/**\n *  @_ignore:\n */\nexport async function resolveArgs(_runner: null | ContractRunner, inputs: ReadonlyArray<ParamType>, args: Array<any>): Promise<Array<any>> {\n    // Recursively descend into args and resolve any addresses\n    const runner = getRunner(_runner, \"resolveName\");\n    const resolver = canResolve(runner) ? runner: null;\n    return await Promise.all(inputs.map((param, index) => {\n        return param.walkAsync(args[index], (type, value) => {\n            value = Typed.dereference(value, type);\n            if (type === \"address\") { return resolveAddress(value, resolver); }\n            return value;\n        });\n    }));\n}\n\nfunction buildWrappedFallback(contract: BaseContract): WrappedFallback {\n\n    const populateTransaction = async function(overrides?: Omit<TransactionRequest, \"to\">): Promise<ContractTransaction> {\n        // If an overrides was passed in, copy it and normalize the values\n\n        const tx: ContractTransaction = <any>(await copyOverrides<\"data\">(overrides, [ \"data\" ]));\n        tx.to = await contract.getAddress();\n\n        const iface = contract.interface;\n\n        // Only allow payable contracts to set non-zero value\n        const payable = iface.receive || (iface.fallback && iface.fallback.payable);\n        assertArgument(payable || (tx.value || BN_0) === BN_0,\n          \"cannot send value to non-payable contract\", \"overrides.value\", tx.value);\n\n        // Only allow fallback contracts to set non-empty data\n        assertArgument(iface.fallback || (tx.data || \"0x\") === \"0x\",\n          \"cannot send data to receive-only contract\", \"overrides.data\", tx.data);\n\n        return tx;\n    }\n\n    const staticCall = async function(overrides?: Omit<TransactionRequest, \"to\">): Promise<string> {\n        const runner = getRunner(contract.runner, \"call\");\n        assert(canCall(runner), \"contract runner does not support calling\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"call\" });\n\n        const tx = await populateTransaction(overrides);\n\n        try {\n            return await runner.call(tx);\n        } catch (error: any) {\n            if (isCallException(error) && error.data) {\n                throw contract.interface.makeError(error.data, tx);\n            }\n            throw error;\n        }\n    }\n\n    const send = async function(overrides?: Omit<TransactionRequest, \"to\">): Promise<ContractTransactionResponse> {\n        const runner = contract.runner;\n        assert(canSend(runner), \"contract runner does not support sending transactions\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"sendTransaction\" });\n\n        const tx = await runner.sendTransaction(await populateTransaction(overrides));\n        const provider = getProvider(contract.runner);\n        // @TODO: the provider can be null; make a custom dummy provider that will throw a\n        // meaningful error\n        return new ContractTransactionResponse(contract.interface, <Provider>provider, tx);\n    }\n\n    const estimateGas = async function(overrides?: Omit<TransactionRequest, \"to\">): Promise<bigint> {\n        const runner = getRunner(contract.runner, \"estimateGas\");\n        assert(canEstimate(runner), \"contract runner does not support gas estimation\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"estimateGas\" });\n\n        return await runner.estimateGas(await populateTransaction(overrides));\n    }\n\n    const method = async (overrides?: Omit<TransactionRequest, \"to\">) => {\n        return await send(overrides);\n    };\n\n    defineProperties<any>(method, {\n        _contract: contract,\n\n        estimateGas,\n        populateTransaction,\n        send, staticCall\n    });\n\n    return <WrappedFallback>method;\n}\n\n/*\nclass WrappedFallback {\n\n    constructor (contract: BaseContract) {\n        defineProperties<WrappedFallback>(this, { _contract: contract });\n\n        const proxy = new Proxy(this, {\n            // Perform send when called\n            apply: async (target, thisArg, args: Array<any>) => {\n                return await target.send(...args);\n            },\n        });\n\n        return proxy;\n    }\n\n    async populateTransaction(overrides?: Omit<TransactionRequest, \"to\">): Promise<ContractTransaction> {\n        // If an overrides was passed in, copy it and normalize the values\n\n        const tx: ContractTransaction = <any>(await copyOverrides<\"data\">(overrides, [ \"data\" ]));\n        tx.to = await this._contract.getAddress();\n\n        const iface = this._contract.interface;\n\n        // Only allow payable contracts to set non-zero value\n        const payable = iface.receive || (iface.fallback && iface.fallback.payable);\n        assertArgument(payable || (tx.value || BN_0) === BN_0,\n          \"cannot send value to non-payable contract\", \"overrides.value\", tx.value);\n\n        // Only allow fallback contracts to set non-empty data\n        assertArgument(iface.fallback || (tx.data || \"0x\") === \"0x\",\n          \"cannot send data to receive-only contract\", \"overrides.data\", tx.data);\n\n        return tx;\n    }\n\n    async staticCall(overrides?: Omit<TransactionRequest, \"to\">): Promise<string> {\n        const runner = getRunner(this._contract.runner, \"call\");\n        assert(canCall(runner), \"contract runner does not support calling\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"call\" });\n\n        const tx = await this.populateTransaction(overrides);\n\n        try {\n            return await runner.call(tx);\n        } catch (error: any) {\n            if (isCallException(error) && error.data) {\n                throw this._contract.interface.makeError(error.data, tx);\n            }\n            throw error;\n        }\n    }\n\n    async send(overrides?: Omit<TransactionRequest, \"to\">): Promise<ContractTransactionResponse> {\n        const runner = this._contract.runner;\n        assert(canSend(runner), \"contract runner does not support sending transactions\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"sendTransaction\" });\n\n        const tx = await runner.sendTransaction(await this.populateTransaction(overrides));\n        const provider = getProvider(this._contract.runner);\n        // @TODO: the provider can be null; make a custom dummy provider that will throw a\n        // meaningful error\n        return new ContractTransactionResponse(this._contract.interface, <Provider>provider, tx);\n    }\n\n    async estimateGas(overrides?: Omit<TransactionRequest, \"to\">): Promise<bigint> {\n        const runner = getRunner(this._contract.runner, \"estimateGas\");\n        assert(canEstimate(runner), \"contract runner does not support gas estimation\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"estimateGas\" });\n\n        return await runner.estimateGas(await this.populateTransaction(overrides));\n    }\n}\n*/\n\nfunction buildWrappedMethod<A extends Array<any> = Array<any>, R = any, D extends R | ContractTransactionResponse = ContractTransactionResponse>(contract: BaseContract, key: string): BaseContractMethod<A, R, D> {\n\n    const getFragment = function(...args: ContractMethodArgs<A>): FunctionFragment {\n        const fragment = contract.interface.getFunction(key, args);\n        assert(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fragment\"\n        });\n        return fragment;\n    }\n\n    const populateTransaction = async function(...args: ContractMethodArgs<A>): Promise<ContractTransaction> {\n        const fragment = getFragment(...args);\n\n        // If an overrides was passed in, copy it and normalize the values\n        let overrides: Omit<ContractTransaction, \"data\" | \"to\"> = { };\n        if (fragment.inputs.length + 1 === args.length) {\n            overrides = await copyOverrides(args.pop());\n        }\n\n        if (fragment.inputs.length !== args.length) {\n            throw new Error(\"internal error: fragment inputs doesn't match arguments; should not happen\");\n        }\n\n        const resolvedArgs = await resolveArgs(contract.runner, fragment.inputs, args);\n\n        return Object.assign({ }, overrides, await resolveProperties({\n            to: contract.getAddress(),\n            data: contract.interface.encodeFunctionData(fragment, resolvedArgs)\n        }));\n    }\n\n    const staticCall = async function(...args: ContractMethodArgs<A>): Promise<R> {\n        const result = await staticCallResult(...args);\n        if (result.length === 1) { return result[0]; }\n        return <R><unknown>result;\n    }\n\n    const send = async function(...args: ContractMethodArgs<A>): Promise<ContractTransactionResponse> {\n        const runner = contract.runner;\n        assert(canSend(runner), \"contract runner does not support sending transactions\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"sendTransaction\" });\n\n        const tx = await runner.sendTransaction(await populateTransaction(...args));\n        const provider = getProvider(contract.runner);\n        // @TODO: the provider can be null; make a custom dummy provider that will throw a\n        // meaningful error\n        return new ContractTransactionResponse(contract.interface, <Provider>provider, tx);\n    }\n\n    const estimateGas = async function(...args: ContractMethodArgs<A>): Promise<bigint> {\n        const runner = getRunner(contract.runner, \"estimateGas\");\n        assert(canEstimate(runner), \"contract runner does not support gas estimation\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"estimateGas\" });\n\n        return await runner.estimateGas(await populateTransaction(...args));\n    }\n\n    const staticCallResult = async function(...args: ContractMethodArgs<A>): Promise<Result> {\n        const runner = getRunner(contract.runner, \"call\");\n        assert(canCall(runner), \"contract runner does not support calling\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"call\" });\n\n        const tx = await populateTransaction(...args);\n\n        let result = \"0x\";\n        try {\n            result = await runner.call(tx);\n        } catch (error: any) {\n            if (isCallException(error) && error.data) {\n                throw contract.interface.makeError(error.data, tx);\n            }\n            throw error;\n        }\n\n        const fragment = getFragment(...args);\n        return contract.interface.decodeFunctionResult(fragment, result);\n    };\n\n    const method = async (...args: ContractMethodArgs<A>) => {\n        const fragment = getFragment(...args);\n        if (fragment.constant) { return await staticCall(...args); }\n        return await send(...args);\n    };\n\n    defineProperties<any>(method, {\n        name: contract.interface.getFunctionName(key),\n        _contract: contract, _key: key,\n\n        getFragment,\n\n        estimateGas,\n        populateTransaction,\n        send, staticCall, staticCallResult,\n    });\n\n    // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)\n    Object.defineProperty(method, \"fragment\", {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n            const fragment = contract.interface.getFunction(key);\n            assert(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"fragment\"\n            });\n            return fragment;\n        }\n    });\n\n    return <BaseContractMethod<A, R, D>>method;\n}\n\nfunction buildWrappedEvent<A extends Array<any> = Array<any>>(contract: BaseContract, key: string): ContractEvent<A> {\n\n    const getFragment = function(...args: ContractEventArgs<A>): EventFragment {\n        const fragment = contract.interface.getEvent(key, args);\n\n        assert(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fragment\"\n        });\n\n        return fragment;\n    }\n\n    const method = function(...args: ContractMethodArgs<A>): PreparedTopicFilter {\n        return new PreparedTopicFilter(contract, getFragment(...args), args);\n    };\n\n    defineProperties<any>(method, {\n        name: contract.interface.getEventName(key),\n        _contract: contract, _key: key,\n\n        getFragment\n    });\n\n    // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)\n    Object.defineProperty(method, \"fragment\", {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n            const fragment = contract.interface.getEvent(key);\n\n            assert(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"fragment\"\n            });\n\n            return fragment;\n        }\n    });\n\n    return <ContractEvent<A>><unknown>method;\n}\n\ntype Sub = {\n    tag: string;\n    listeners: Array<{ listener: Listener, once: boolean }>,\n    start: () => void;\n    stop: () => void;\n};\n\n\n// The combination of TypeScrype, Private Fields and Proxies makes\n// the world go boom; so we hide variables with some trickery keeping\n// a symbol attached to each BaseContract which its sub-class (even\n// via a Proxy) can reach and use to look up its internal values.\n\nconst internal = Symbol.for(\"_ethersInternal_contract\");\ntype Internal = {\n    addrPromise: Promise<string>;\n    addr: null | string;\n\n    deployTx: null | ContractTransactionResponse;\n\n    subs: Map<string, Sub>;\n};\n\nconst internalValues: WeakMap<BaseContract, Internal> = new WeakMap();\n\nfunction setInternal(contract: BaseContract, values: Internal): void {\n    internalValues.set(contract[internal], values);\n}\n\nfunction getInternal(contract: BaseContract): Internal {\n    return internalValues.get(contract[internal]) as Internal;\n}\n\nfunction isDeferred(value: any): value is DeferredTopicFilter {\n    return (value && typeof(value) === \"object\" && (\"getTopicFilter\" in value) &&\n      (typeof(value.getTopicFilter) === \"function\") && value.fragment);\n}\n\nasync function getSubInfo(contract: BaseContract, event: ContractEventName): Promise<{ fragment: null | EventFragment, tag: string, topics: TopicFilter }> {\n    let topics: Array<null | string | Array<string>>;\n    let fragment: null | EventFragment = null;\n\n    // Convert named events to topicHash and get the fragment for\n    // events which need deconstructing.\n\n    if (Array.isArray(event)) {\n        const topicHashify = function(name: string): string {\n            if (isHexString(name, 32)) { return name; }\n            const fragment = contract.interface.getEvent(name);\n            assertArgument(fragment, \"unknown fragment\", \"name\", name);\n            return fragment.topicHash;\n        }\n\n        // Array of Topics and Names; e.g. `[ \"0x1234...89ab\", \"Transfer(address)\" ]`\n        topics = event.map((e) => {\n            if (e == null) { return null; }\n            if (Array.isArray(e)) { return e.map(topicHashify); }\n            return topicHashify(e);\n        });\n\n    } else if (event === \"*\") {\n        topics = [ null ];\n\n    } else if (typeof(event) === \"string\") {\n        if (isHexString(event, 32)) {\n            // Topic Hash\n            topics = [ event ];\n        } else {\n           // Name or Signature; e.g. `\"Transfer\", `\"Transfer(address)\"`\n            fragment = contract.interface.getEvent(event);\n            assertArgument(fragment, \"unknown fragment\", \"event\", event);\n            topics = [ fragment.topicHash ];\n        }\n\n    } else if (isDeferred(event)) {\n        // Deferred Topic Filter; e.g. `contract.filter.Transfer(from)`\n        topics = await event.getTopicFilter();\n\n    } else if (\"fragment\" in event) {\n        // ContractEvent; e.g. `contract.filter.Transfer`\n        fragment = event.fragment;\n        topics = [ fragment.topicHash ];\n\n    } else {\n        assertArgument(false, \"unknown event name\", \"event\", event);\n    }\n\n    // Normalize topics and sort TopicSets\n    topics = topics.map((t) => {\n        if (t == null) { return null; }\n        if (Array.isArray(t)) {\n            const items = Array.from(new Set(t.map((t) => t.toLowerCase())).values());\n            if (items.length === 1) { return items[0]; }\n            items.sort();\n            return items;\n        }\n        return t.toLowerCase();\n    });\n\n    const tag = topics.map((t) => {\n        if (t == null) { return \"null\"; }\n        if (Array.isArray(t)) { return t.join(\"|\"); }\n        return t;\n    }).join(\"&\");\n\n    return { fragment, tag, topics }\n}\n\nasync function hasSub(contract: BaseContract, event: ContractEventName): Promise<null | Sub> {\n    const { subs } = getInternal(contract);\n    return subs.get((await getSubInfo(contract, event)).tag) || null;\n}\n\nasync function getSub(contract: BaseContract, operation: string, event: ContractEventName): Promise<Sub> {\n    // Make sure our runner can actually subscribe to events\n    const provider = getProvider(contract.runner);\n    assert(provider, \"contract runner does not support subscribing\",\n        \"UNSUPPORTED_OPERATION\", { operation });\n\n    const { fragment, tag, topics } = await getSubInfo(contract, event);\n\n    const { addr, subs } = getInternal(contract);\n\n    let sub = subs.get(tag);\n    if (!sub) {\n        const address: string | Addressable = (addr ? addr: contract);\n        const filter = { address, topics };\n        const listener = (log: Log) => {\n            let foundFragment = fragment;\n            if (foundFragment == null) {\n                try {\n                    foundFragment = contract.interface.getEvent(log.topics[0]);\n                } catch (error) { }\n            }\n\n            // If fragment is null, we do not deconstruct the args to emit\n\n            if (foundFragment) {\n                const _foundFragment = foundFragment;\n                const args = fragment ? contract.interface.decodeEventLog(fragment, log.data, log.topics): [ ];\n                emit(contract, event, args, (listener: null | Listener) => {\n                    return new ContractEventPayload(contract, listener, event, _foundFragment, log);\n                });\n            } else {\n                emit(contract, event, [ ], (listener: null | Listener) => {\n                    return new ContractUnknownEventPayload(contract, listener, event, log);\n                });\n            }\n        };\n\n        let starting: Array<Promise<any>> = [ ];\n        const start = () => {\n            if (starting.length) { return; }\n            starting.push(provider.on(filter, listener));\n        };\n\n        const stop = async () => {\n            if (starting.length == 0) { return; }\n\n            let started = starting;\n            starting = [ ];\n            await Promise.all(started);\n            provider.off(filter, listener);\n        };\n\n        sub = { tag, listeners: [ ], start, stop };\n        subs.set(tag, sub);\n    }\n    return sub;\n}\n\n// We use this to ensure one emit resolves before firing the next to\n// ensure correct ordering (note this cannot throw and just adds the\n// notice to the event queu using setTimeout).\nlet lastEmit: Promise<any> = Promise.resolve();\n\ntype PayloadFunc = (listener: null | Listener) => ContractUnknownEventPayload;\n\nasync function _emit(contract: BaseContract, event: ContractEventName, args: Array<any>, payloadFunc: null | PayloadFunc): Promise<boolean> {\n    await lastEmit;\n\n    const sub = await hasSub(contract, event);\n    if (!sub) { return false; }\n\n    const count = sub.listeners.length;\n    sub.listeners = sub.listeners.filter(({ listener, once }) => {\n        const passArgs = Array.from(args);\n        if (payloadFunc) {\n            passArgs.push(payloadFunc(once ? null: listener));\n        }\n        try {\n            listener.call(contract, ...passArgs);\n        } catch (error) { }\n        return !once;\n    });\n    return (count > 0);\n}\n\nasync function emit(contract: BaseContract, event: ContractEventName, args: Array<any>, payloadFunc: null | PayloadFunc): Promise<boolean> {\n    try {\n        await lastEmit;\n    } catch (error) { }\n\n    const resultPromise = _emit(contract, event, args, payloadFunc);\n    lastEmit = resultPromise;\n    return await resultPromise;\n}\n\nconst passProperties = [ \"then\" ];\nexport class BaseContract implements Addressable, EventEmitterable<ContractEventName> {\n    readonly target!: string | Addressable;\n    readonly interface!: Interface;\n    readonly runner!: null | ContractRunner;\n\n    readonly filters!: Record<string, ContractEvent>;\n\n    readonly [internal]: any;\n\n    readonly fallback!: null | WrappedFallback;\n\n    constructor(target: string | Addressable, abi: Interface | InterfaceAbi, runner?: null | ContractRunner, _deployTx?: null | TransactionResponse) {\n        if (runner == null) { runner = null; }\n        const iface = Interface.from(abi);\n        defineProperties<BaseContract>(this, { target, runner, interface: iface });\n\n        Object.defineProperty(this, internal, { value: { } });\n\n        let addrPromise;\n        let addr = null;\n\n        let deployTx: null | ContractTransactionResponse = null;\n        if (_deployTx) {\n            const provider = getProvider(runner);\n            // @TODO: the provider can be null; make a custom dummy provider that will throw a\n            // meaningful error\n            deployTx = new ContractTransactionResponse(this.interface, <Provider>provider, _deployTx);\n        }\n\n        let subs = new Map();\n\n        // Resolve the target as the address\n        if (typeof(target) === \"string\") {\n            if (isHexString(target)) {\n                addr = target;\n                addrPromise = Promise.resolve(target);\n\n            } else {\n                const resolver = getRunner(runner, \"resolveName\");\n                if (!canResolve(resolver)) {\n                    throw makeError(\"contract runner does not support name resolution\", \"UNSUPPORTED_OPERATION\", {\n                        operation: \"resolveName\"\n                    });\n                }\n\n                addrPromise = resolver.resolveName(target).then((addr) => {\n                    if (addr == null) { throw new Error(\"TODO\"); }\n                    getInternal(this).addr = addr;\n                    return addr;\n                });\n            }\n        } else {\n            addrPromise = target.getAddress().then((addr) => {\n                if (addr == null) { throw new Error(\"TODO\"); }\n                getInternal(this).addr = addr;\n                return addr;\n            });\n        }\n\n        // Set our private values\n        setInternal(this, { addrPromise, addr, deployTx, subs });\n\n        // Add the event filters\n        const filters = new Proxy({ }, {\n            get: (target, _prop, receiver) => {\n                // Pass important checks (like `then` for Promise) through\n                if (passProperties.indexOf(<string>_prop) >= 0) {\n                    return Reflect.get(target, _prop, receiver);\n                }\n\n                const prop = String(_prop);\n\n                const result = this.getEvent(prop);\n                if (result) { return result; }\n\n                throw new Error(`unknown contract event: ${ prop }`);\n            }\n        });\n        defineProperties<BaseContract>(this, { filters });\n\n        defineProperties<BaseContract>(this, {\n            fallback: ((iface.receive || iface.fallback) ? (buildWrappedFallback(this)): null)\n        });\n\n        // Return a Proxy that will respond to functions\n        return new Proxy(this, {\n            get: (target, _prop, receiver) => {\n                if (_prop in target || passProperties.indexOf(<string>_prop) >= 0) {\n                    return Reflect.get(target, _prop, receiver);\n                }\n\n                const prop = String(_prop);\n\n                const result = target.getFunction(prop);\n                if (result) { return result; }\n\n                throw new Error(`unknown contract method: ${ prop }`);\n            }\n        });\n\n    }\n\n    connect(runner: null | ContractRunner): BaseContract {\n        return new BaseContract(this.target, this.interface, runner);\n    }\n\n    async getAddress(): Promise<string> { return await getInternal(this).addrPromise; }\n\n    async getDeployedCode(): Promise<null | string> {\n        const provider = getProvider(this.runner);\n        assert(provider, \"runner does not support .provider\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"getDeployedCode\" });\n\n        const code = await provider.getCode(await this.getAddress());\n        if (code === \"0x\") { return null; }\n        return code;\n    }\n\n    async waitForDeployment(): Promise<this> {\n        // We have the deployement transaction; just use that (throws if deployement fails)\n        const deployTx = this.deploymentTransaction();\n        if (deployTx) {\n            await deployTx.wait();\n            return this;\n        }\n\n        // Check for code\n        const code = await this.getDeployedCode();\n        if (code != null) { return this; }\n\n        // Make sure we can subscribe to a provider event\n        const provider = getProvider(this.runner);\n        assert(provider != null, \"contract runner does not support .provider\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"waitForDeployment\" });\n\n        return new Promise((resolve, reject) => {\n            const checkCode = async () => {\n                try {\n                    const code = await this.getDeployedCode();\n                    if (code != null) { return resolve(this); }\n                    provider.once(\"block\", checkCode);\n                } catch (error) {\n                    reject(error);\n                }\n            };\n            checkCode();\n        });\n    }\n\n    deploymentTransaction(): null | ContractTransactionResponse {\n        return getInternal(this).deployTx;\n    }\n\n    getFunction<T extends ContractMethod = ContractMethod>(key: string | FunctionFragment): T {\n        if (typeof(key) !== \"string\") { key = key.format(); }\n        const func = buildWrappedMethod(this, key);\n        return <T>func;\n    }\n\n    getEvent(key: string | EventFragment): ContractEvent {\n        if (typeof(key) !== \"string\") { key = key.format(); }\n        return buildWrappedEvent(this, key);\n    }\n\n    async queryTransaction(hash: string): Promise<Array<EventLog>> {\n        // Is this useful?\n        throw new Error(\"@TODO\");\n    }\n\n    async queryFilter(event: ContractEventName, fromBlock?: BlockTag, toBlock?: BlockTag): Promise<Array<EventLog | Log>> {\n        if (fromBlock == null) { fromBlock = 0; }\n        if (toBlock == null) { toBlock = \"latest\"; }\n        const { addr, addrPromise } = getInternal(this);\n        const address = (addr ? addr: (await addrPromise));\n        const { fragment, topics } = await getSubInfo(this, event);\n        const filter = { address, topics, fromBlock, toBlock };\n\n        const provider = getProvider(this.runner);\n        assert(provider, \"contract runner does not have a provider\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"queryFilter\" });\n\n        return (await provider.getLogs(filter)).map((log) => {\n            let foundFragment = fragment;\n            if (foundFragment == null) {\n                try {\n                    foundFragment = this.interface.getEvent(log.topics[0]);\n                } catch (error) { }\n            }\n\n            if (foundFragment) {\n                return new EventLog(log, this.interface, foundFragment);\n            } else {\n                return new Log(log, provider);\n            }\n        });\n    }\n\n    async on(event: ContractEventName, listener: Listener): Promise<this> {\n        const sub = await getSub(this, \"on\", event);\n        sub.listeners.push({ listener, once: false });\n        sub.start();\n        return this;\n    }\n\n    async once(event: ContractEventName, listener: Listener): Promise<this> {\n        const sub = await getSub(this, \"once\", event);\n        sub.listeners.push({ listener, once: true });\n        sub.start();\n        return this;\n    }\n\n    async emit(event: ContractEventName, ...args: Array<any>): Promise<boolean> {\n        return await emit(this, event, args, null);\n    }\n\n    async listenerCount(event?: ContractEventName): Promise<number> {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) { return 0; }\n            return sub.listeners.length;\n        }\n\n        const { subs } = getInternal(this);\n\n        let total = 0;\n        for (const { listeners } of subs.values()) {\n            total += listeners.length;\n        }\n        return total;\n    }\n\n    async listeners(event?: ContractEventName): Promise<Array<Listener>> {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) { return [ ]; }\n            return sub.listeners.map(({ listener }) => listener);\n        }\n\n        const { subs } = getInternal(this);\n\n        let result: Array<Listener> = [ ];\n        for (const { listeners } of subs.values()) {\n            result = result.concat(listeners.map(({ listener }) => listener));\n        }\n        return result;\n    }\n\n    async off(event: ContractEventName, listener?: Listener): Promise<this> {\n        const sub = await hasSub(this, event);\n        if (!sub) { return this; }\n\n        if (listener) {\n            const index = sub.listeners.map(({ listener }) => listener).indexOf(listener);\n            if (index >= 0) { sub.listeners.splice(index, 1); }\n        }\n\n        if (listener == null || sub.listeners.length === 0) {\n            sub.stop();\n            getInternal(this).subs.delete(sub.tag);\n        }\n\n        return this;\n    }\n\n    async removeAllListeners(event?: ContractEventName): Promise<this> {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) { return this; }\n            sub.stop();\n            getInternal(this).subs.delete(sub.tag);\n        } else {\n            const { subs } = getInternal(this);\n            for (const { tag, stop } of subs.values()) {\n                stop();\n                subs.delete(tag);\n            }\n        }\n\n        return this;\n    }\n\n    // Alias for \"on\"\n    async addListener(event: ContractEventName, listener: Listener): Promise<this> {\n        return await this.on(event, listener);\n    }\n\n    // Alias for \"off\"\n    async removeListener(event: ContractEventName, listener: Listener): Promise<this> {\n        return await this.off(event, listener);\n    }\n\n    static buildClass<T = ContractInterface>(abi: InterfaceAbi): new (target: string, runner?: null | ContractRunner) => BaseContract & Omit<T, keyof BaseContract> {\n        class CustomContract extends BaseContract {\n            constructor(address: string, runner: null | ContractRunner = null) {\n                super(address, abi, runner);\n            }\n        }\n        return CustomContract as any;\n    };\n\n    static from<T = ContractInterface>(target: string, abi: InterfaceAbi, runner?: null | ContractRunner): BaseContract & Omit<T, keyof BaseContract> {\n        if (runner == null) { runner = null; }\n        const contract = new this(target, abi, runner );\n        return contract as any;\n    }\n}\n\nfunction _ContractBase(): new (target: string, abi: InterfaceAbi, runner?: null | ContractRunner) => BaseContract & Omit<ContractInterface, keyof BaseContract> {\n    return BaseContract as any;\n}\n\nexport class Contract extends _ContractBase() { }\n"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","this","_objectWithoutProperties","excluded","sourceKeys","keys","indexOf","_objectWithoutPropertiesLoose","getOwnPropertySymbols","sourceSymbolKeys","propertyIsEnumerable","AtSign","forwardRef","_ref","ref","_ref$color","color","_ref$size","size","rest","React","xmlns","width","height","viewBox","fill","stroke","strokeWidth","strokeLinecap","strokeLinejoin","cx","cy","r","d","propTypes","PropTypes","displayName","Calendar","x","y","rx","ry","x1","y1","x2","y2","MapPin","_typeof","obj","Symbol","iterator","constructor","_toPropertyKey","arg","input","hint","prim","toPrimitive","undefined","res","TypeError","String","Number","_defineProperty","value","defineProperty","enumerable","configurable","writable","_checkPrivateRedeclaration","privateCollection","has","privateMap","set","_classExtractFieldDescriptor","receiver","action","get","descriptor","checkType","type","name","types","split","map","t","trim","error","Error","code","argument","async","resolveProperties","Promise","all","k","resolve","reduce","accum","v","index","defineProperties","values","stringify","Array","isArray","join","Uint8Array","HEX","result","toJSON","toString","BigInt","JSON","sort","isError","isCallException","makeError","message","info","details","push","RangeError","assert","check","assertArgument","assertArgumentCount","count","expectedCount","_normalizeForms","form","normalize","fromCharCode","assertPrivate","givenGuard","guard","className","method","operation","_gaurd","n","signed","Typed","b","_typedSymbol","for","gaurd","options","format","defaultValue","minValue","maxValue","isBigInt","match","isData","startsWith","isString","tupleName","arrayLength","static","dynamic","isTyped","_classPrivateMethodInitSpec","privateSet","add","_classPrivateMethodGet","fn","number","isSafeInteger","bytes","lengths","includes","bool","hash","create","outputLen","blockLen","exists","instance","checkFinished","destroyed","finished","output","out","min","U32_MASK64","_32n","fromBig","le","h","l","u64","lst","Ah","Uint32Array","Al","toBig","shrSH","s","shrSL","rotrSH","rotrSL","rotrBH","rotrBL","rotr32H","rotr32L","rotlSH","rotlSL","rotlBH","rotlBL","Bh","Bl","add3L","Cl","add3H","low","Ch","add4L","Dl","add4H","Dh","add5H","Eh","add5L","El","self","crypto","buffer","from","padStart","toBytes","data","str","TextEncoder","encode","utf8ToBytes","Hash","clone","_cloneInto","SHA3_PI","SHA3_ROTL","_SHA3_IOTA","_0n","_1n","_2n","_7n","_256n","_0x71n","round","R","j","SHA3_IOTA_H","SHA3_IOTA_L","rotlH","rotlL","Keccak","suffix","enableXOF","rounds","super","pos","posOut","arr","state","state32","byteOffset","Math","floor","byteLength","keccak","B","idx1","idx0","B0","B1","Th","Tl","curH","curL","shift","PI","keccakP","update","len","take","finish","writeInto","bufferOut","subarray","xofInto","xof","digestInto","destroy","digest","to","gen","hashConstructor","hashC","tmp","wrapConstructor","keccak_256","genShake","hashCons","msg","opts","wrapConstructorWithOpts","dkLen","_getBytes","copy","offset","parseInt","substring","getBytes","getBytesCopy","isHexString","HexCharacters","hexlify","concat","datas","dataSlice","start","end","slice","zeroPad","left","locked","_keccak256","__keccak256","keccak256","_data","ignoreFunc","reason","badCodepoint","o","_","lock","register","func","freeze","Utf8ErrorFuncs","ignore","replace","getUtf8CodePoints","_bytes","onError","c","extraLength","overlongMask","nextChar","toUtf8Bytes","assertNormalize","charCodeAt","c2","pair","toUtf8String","codePoint","id","BN_0","BN_1","mask","_value","_bits","getUint","bits","getNumber","getBigInt","isInteger","e","fault","Nibbles","toBigInt","toBeHex","_width","toBeArray","hex","WordSize","Padding","passProperties","_guard","throwError","wrapped","Result","args","items","names","wrap","forEach","item","nameCounts","Map","Proxy","prop","Reflect","Function","getValue","toArray","toObject","filter","callback","thisArg","Coder","localName","_throwError","Writer","appendWriter","writer","writeBytes","paddingOffset","writeValue","writeUpdatableValue","Reader","allowLoose","dataLength","consumed","subReader","readBytes","loose","readValue","readIndex","alignedLength","ceil","BN_36","getChecksumAddress","address","chars","toLowerCase","expanded","hashed","toUpperCase","ibanLookup","ibanChecksum","block","checksum","Base36","getAddress","fromBase36","AddressCoder","dereference","decode","reader","AnonymousCoder","coder","pack","coders","arrayValues","unique","staticWriter","dynamicWriter","updateFuncs","dynamicOffset","updateFunc","baseOffset","unpack","baseReader","offsetReader","baseType","fromItems","ArrayCoder","defaultChild","BooleanCoder","DynamicBytesCoder","BytesCoder","FixedBytesCoder","Empty","NullCoder","BN_MAX_UINT256","NumberCoder","maxUintValue","bounds","limit","toTwos","fromTwos","StringCoder","TupleCoder","uniqueNames","setify","Set","_kwVisib","KwVisib","_kwTypes","KwTypes","_kwModifiers","KwModifiers","Keywords","SimpleTokens","regexWhitespacePrefix","RegExp","regexNumberPrefix","regexIdPrefix","regexId","regexType","TokenString","tokens","reset","popKeyword","allowed","top","peek","text","pop","popType","popParen","popParams","link","linkNext","peekKeyword","peekType","token","linkBack","lex","brackets","commas","cur","depth","allowSingle","included","consumeName","keyword","consumeKeywords","keywords","consumeMutability","modifiers","consumeParams","allowIndexed","ParamType","consumeGas","consumeEoi","regexArrayType","verifyBasicType","internal","ParamTypeInternal","ErrorFragmentInternal","EventFragmentInternal","ConstructorFragmentInternal","FallbackFragmentInternal","FunctionFragmentInternal","StructFragmentInternal","indexed","components","arrayChildren","isTuple","parse","comp","isIndexable","walk","process","_this","promises","isParamType","comps","bracket","arrayMatch","setValue","childType","param","then","Fragment","inputs","ConstructorFragment","ErrorFragment","EventFragment","FallbackFragment","FunctionFragment","StructFragment","isFragment","NamedFragment","joinParams","params","p","selector","anonymous","topicHash","payable","gas","stateMutability","errorObj","mutability","outputs","constant","PanicReasons","paramTypeBytes","paramTypeNumber","defaultCoder","AbiCoder","getDefaultValue","tx","abiCoder","revert","signature","transaction","invocation","getBuiltinCallException","defaultAbiCoder","LogDescription","fragment","topic","TransactionDescription","ErrorDescription","Indexed","_isIndexed","BuiltinErrors","Interface","fragments","abi","frags","a","console","log","fallback","receive","getAbiCoder","bucket","deploy","minimal","f","formatJson","getFunctionName","getFunction","forEachFunction","localeCompare","getEventName","getEvent","forEachEvent","getError","matching","m","forEachError","_decodeParams","_encodeParams","encodeDeploy","decodeErrorResult","encodeErrorResult","decodeFunctionData","encodeFunctionData","decodeFunctionResult","ef","parsed","parseTransaction","encodeFunctionResult","encodeFilterTopics","topics","encodeTopic","encodeEventLog","dataTypes","dataValues","decodeEventLog","eventTopic","nonIndexed","resultIndexed","resultNonIndexed","nonIndexedIndex","indexedIndex","parseCallResult","parseLog","parseError","hexData","forceUnique","lastValue","valueLength","allowOptions","splice","lastArg","checkAddress","promise","resolveAddress","resolver","resolveName","accessSetify","addr","storageKeys","storageKey","toJson","copyRequest","req","bigIntKeys","numberKeys","accessList","accessListify","blockTag","enableCcipReadEnabled","enableCcipRead","customData","Log","provider","transactionHash","blockHash","blockNumber","removed","transactionIndex","_type","getBlock","getTransaction","receipt","getTransactionReceipt","removedEvent","orphan","TransactionReceipt","logs","contractAddress","logsBloom","gasUsed","cumulativeGasUsed","gasPrice","effectiveGasPrice","status","root","next","done","fee","getTransactionResult","getBlockNumber","createRemovedTransactionFilter","reorderedEvent","other","isMined","createReorderedTransactionFilter","TransactionResponse","gasLimit","nonce","maxPriorityFeePerGas","maxFeePerGas","chainId","_confirms","_timeout","confirms","timeout","startBlock","nextScan","stopScanning","checkReplacement","getTransactionCount","mined","cancelled","replacement","replaceableTransaction","confirmations","waiter","reject","cancellers","cancel","timer","setTimeout","clearTimeout","txListener","off","on","replaceListener","once","isLegacy","isBerlin","isLondon","EventPayload","emitter","listener","EventLog","iface","interface","eventName","eventSignature","ContractTransactionReceipt","ContractTransactionResponse","wait","ContractUnknownEventPayload","contract","ContractEventPayload","_log","canCall","canEstimate","estimateGas","canResolve","canSend","sendTransaction","PreparedTopicFilter","runner","getRunner","resolvedArgs","walkAsync","getTopicFilter","feature","getProvider","copyOverrides","overrides","resolveArgs","_runner","buildWrappedFallback","populateTransaction","send","_contract","staticCall","internalValues","WeakMap","getInternal","getSubInfo","event","topicHashify","tag","hasSub","subs","getSub","sub","foundFragment","_foundFragment","emit","starting","listeners","stop","started","lastEmit","payloadFunc","resultPromise","passArgs","_emit","BaseContract","_deployTx","addrPromise","deployTx","filters","_prop","connect","getCode","deploymentTransaction","getDeployedCode","checkCode","getFragment","staticCallResult","_key","buildWrappedMethod","buildWrappedEvent","fromBlock","toBlock","getLogs","total","delete","Contract","_ContractBase"],"sourceRoot":""}